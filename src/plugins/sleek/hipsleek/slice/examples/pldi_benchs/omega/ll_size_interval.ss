/* singly linked lists *//* representation of a node */data node {	int val; 	node next;	}/* view for a singly linked list *//*ll<n, mn, mx> == self = null & n = 0 & mn = mx 	or self::node<x, q> * q::ll<n-1, mn1, mx1> & mn = min(x, mn1) & mx = max(x,mx1)   inv n >= 0 & mn <= mx;  lseg<p, n, mn, mx> == self = p & n=0 & mn = mx 	or self::node<x, q> * q::lseg<p, n-1, mn1, mx1> & mn = min(x, mn1) & mx = max(x,mx1) 	inv n >= 0 & mn <= mx;*/ll<n, mn, mx> == self = null & n = 0 & mn = mx	or self::node<x, q> * q::ll<n-1, mn, mx> & mn <= x < mx //& mn = min(x, mn1) & mx = max(x, mx1)  inv n >= 0 & mn <= mx;  lseg<p, n, mn, mx> == self = p & n=0 & mn = mx	or self::node<x, q> * q::lseg<p, n-1, mn, mx> & mn <= x < mx 	inv n >= 0 & mn <= mx;/* append two singly linked lists */	node append3(node x, node y)	requires x::lseg<null, n, mn, mx>	case {		x = null -> ensures res = y & n = 0;		x != null -> ensures res::lseg<y, n, mn, mx> & res=x & n>0;	}{	if (x==null) return y;	node tmp=x.next;	//assume tmp'=null or tmp'!=null;	x.next = append3(tmp,y);	return x;}void append2(node x, node y)	requires x::ll<n1, mn1, mx1> * y::ll<n2, mn2, mx2> & x!=null	//ensures x::ll<n1+n2, mn, mx> & mn=min(mn1, mn2) & mx=max(mx1, mx2);	case {		y = null -> ensures x::ll<n1, mn1, mx1>;		y != null -> ensures x::ll<n1+n2, mn, mx> & mn=min(mn1, mn2) & mx=max(mx1, mx2);	}{    	if (x.next == null)         x.next = y;	else        append2(x.next, y);}void append(node x, node y)	requires x::ll<n1, mn1, mx1> * y::ll<n2, mn2, mx2> & n1>0	//ensures x::ll<n1+n2, mn, mx> & mn=min(mn1, mn2) & mx=max(mx1, mx2);	case {		y = null -> ensures x::ll<n1, mn1, mx1>;		y != null -> ensures x::ll<n1+n2, mn, mx> & mn=min(mn1, mn2) & mx=max(mx1, mx2);	}{	if (x.next == null)	      x.next = y;	else 		append(x.next, y);}/* return the first element of a singly linked list */node ret_first(node x)	requires x::ll<n, mn1, mx1> * y::ll<m, mn2, mx2> & n < m 	ensures x::ll<n, mn1, mx1>;{	return x;}/* return the tail of a singly linked list */node get_next(node x)	requires x::ll<n, mn, mx> & n>0	ensures x::node<v, null> * res::ll<n-1, mn, mx> & mn <= v < mx;	//ensures x::ll<1, mn, mx> * res::ll<n-1, mn, mx>;{	node tmp = x.next;	x.next = null;	return tmp;}/* function to set the tail of a list */ void set_next(node x, node y)	//requires x::ll<i, mn1, mx1> * y::ll<j, mn2, mx2> & i > 0 	//ensures x::ll<j+1, mn, mx> & mn = min(x.val, mn2) & mx = max(x.val, mx2); 	requires x::node<v, z> * z::ll<i, mn1, mx1> * y::ll<j, mn2, mx2>	ensures x::node<v, y> * y::ll<j, mn2, mx2>;	/*	case {		y = null -> ensures x::node<v, null>;		y != null -> ensures x::node<v, y> * y::ll<j, mn2, mx2>;			//ensures x::ll<j+1, mn, mx> & mn = min(v, mn2) & mx = max(v, mx2);	}	*/{	x.next = y;}/* function to set null the tail of a list */void set_null(node x)	requires x::ll<i, mn, mx> & i > 0 	ensures x::node<v, null> & mn <= v < mx;{	x.next = null;}/* function to get the third element of a list */node get_next_next(node x) 	requires x::ll<n, mn, mx> & n > 1	ensures res::ll<n-2, mn, mx>;{	return x.next.next;}/* function to insert a node in a singly linked list */void insert(node x, int a)	requires x::ll<n, mn, mx> & n > 0 	ensures x::ll<n+1, mn1, mx1> & mn1 = min(mn, a) & mx1 = max(mx, a);	/*	case {		a < mn -> ensures x::ll<n+1, a, mx>;		a >= mn -> case {			a <= mx -> ensures x::ll<n+1, mn, mx>;			a > mx -> ensures x::ll<n+1, mn, a>; 		}	}	*/{	node tmp = null;	if (x.next == null)		x.next = new node(a, tmp);	else 		insert(x.next, a);} /* function to delete the a-th node in a singly linked list */void delete(node x, int a)	requires x::ll<n, mn, mx> & n > a & a > 0 	ensures x::ll<n-1, mn, mx>;{    if (a == 1)	{        x.next = x.next.next;	}	else	{		delete(x.next, a-1);	}	}/*/* function to create a singly linked list with a nodes */node create_list(int a)	requires a >= 0 	ensures res::ll<a, mn, mx> & (mn=mx | mn <= 0 <= mx);	{	node tmp;	if (a == 0) {		return null;	}	else {    		//assume false;		a  = a - 1;        tmp = create_list(a);        return new node (0, tmp);	}		}*//* function to reverse a singly linked list */void reverse(ref node xs, ref node ys)	requires xs::ll<n, mn, mx> * ys::ll<m, mn, mx> 	ensures ys'::ll<n+m, mn, mx> & xs' = null;	/*	requires xs::ll<n, mn1, mx1> * ys::ll<m, mn2, mx2> 	ensures ys'::ll<n+m, mn, mx> & xs' = null & mn = min(mn1, mn2) & mx = max(mx1, mx2);	*/	{	if (xs != null) {		node tmp;		tmp = xs.next;    	xs.next = ys;		ys = xs;		xs = tmp;    	reverse(xs, ys);	}}