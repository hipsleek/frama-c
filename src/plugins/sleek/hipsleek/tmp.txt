astsimp.ml:    | IF.HeapNode2 h2 -> IF.HeapNode (###x_add ###x_add node2_to_node 1 prog h2)
astsimp.ml:            (try let todo_unk = I.###x_add look_up_view_def_raw 7 view_decls0 c in [ (vname, c) ]
astsimp.ml:          then aux (LO.###x_add ###x_add comb_norm 1 l l2) (CP.mkAnd f f2 no_pos) rest
astsimp.ml:    Tpdispatcher.###x_add is_sat_sub_no 11 f_sat sat_subno
astsimp.ml:	  let f_sat f = TP.###x_add is_sat_sub_no 12 f (ref 0) in
astsimp.ml:		let f_aux = !force_verbose_###x_add xpure in
astsimp.ml:		let not_fact,_, _ = (x_add Cvutil.###x_add xpure_symbolic 11 cp d) in
astsimp.ml:                let sfact = TP.###x_add simplify fact in
astsimp.ml:      (* Start calling is_sat,imply,###x_add simplify from trans_proc *)
astsimp.ml:          (ignore (List.map (fun vdef ->  (compute_view_x_formula cprog vdef !Globals.n_###x_add xpure )) cviews2);
astsimp.ml:(* TODO CG : should normalise n###x_add xpure better *)
astsimp.ml:(*        let (xform', addr_vars', ms) = Solver.###x_add xpure_symbolic prog (C.formula_of_unstruc_view_f vdef) in    *)
astsimp.ml:(*        let xform = MCP.simpl_memo_pure_formula Solver.simpl_b_formula Solver.simpl_pure_formula xform' (TP.###x_add simplify_a 10) in *)
astsimp.ml:	  let (xform', addr_vars', ms) = x_add Cvutil.###x_add xpure_symbolic 1 prog (C.formula_of_unstruc_view_f vdef) in
astsimp.ml:	  let xform = MCP.simpl_memo_pure_formula Cvutil.simpl_b_formula Cvutil.simpl_pure_formula xform' (TP.###x_add simplify_a 10) in
astsimp.ml:          let xform1 = (TP.###x_add simplify_with_pairwise 1 (CP.drop_rel_formula (MCP.pure_of_mix xform))) in
astsimp.ml:                      Some (Expure.###x_add simplify unf_baga)
astsimp.ml:                    else Some (Expure.###x_add simplify lst) (* baga_over *)
astsimp.ml:        (* let () = Debug.info_zprint (lazy ("code when -n###x_add xpure 0 !")) no_pos in *)
astsimp.ml:      let ###x_add form_body_inv  vdef =
astsimp.ml:        let (xform', _ (*addr_vars'*), ms) = x_add Cvutil.###x_add xpure_symbolic 2 prog uns_view in
astsimp.ml:        let xform = MCP.simpl_memo_pure_formula Cvutil.simpl_b_formula Cvutil.simpl_pure_formula xform' (TP.###x_add simplify_a 10) in
astsimp.ml:      let ###x_add form_body_inv i  vdef =
astsimp.ml:        Debug.no_1_num i "form_body_inv" pr Cprinter.string_of_formula ###x_add form_body_inv vdef in
astsimp.ml:        else (###x_add form_body_inv 1),(form_body_inv 2) in
astsimp.ml:        (* ###x_add unfold helper, now unfold 3 times *)
astsimp.ml:        let rec helper_###x_add unfold no bfs ifs =
astsimp.ml:            new_bfs@(helper_###x_add unfold (no - 1) new_bfs ifs)
astsimp.ml:        let helper_###x_add unfold no bfs ifs =
astsimp.ml:          Debug.no_2 "helper_unfold" pr pr pr (fun _ _ -> helper_###x_add unfold no bfs ifs) bfs ifs in
astsimp.ml:        let bfs = bfs@(helper_###x_add unfold no bfs ifs) in
astsimp.ml:  let inv_pf = Cpure.arith_###x_add simplify 1 inv_pf in
astsimp.ml:                    let cpf = Cpure.arith_###x_add simplify 1 cpf in
astsimp.ml:                  Some lst (* ###x_add unfold once *)
astsimp.ml:              Tpdispatcher.###x_add simplify new_pf
astsimp.ml:          let rec ###x_add unfold precise old_invs =
astsimp.ml:                ###x_add unfold precise new_invs
astsimp.ml:                ###x_add unfold precise new_invs
astsimp.ml:          (* WN : Looping at ###x_add unfold with imprecise inv *)
astsimp.ml:          let new_invs = ###x_add unfold (List.for_all (fun a -> a) precise_list) combined_invs in
astsimp.ml:      let (xform', _ , _) = x_add Cvutil.###x_add xpure_symbolic 3 prog f in
astsimp.ml:      let xform = simpl_memo_pure_formula Cvutil.simpl_b_formula Cvutil.simpl_pure_formula xform' (TP.###x_add simplify_a 10) in
astsimp.ml:      let bcg = List.fold_left (fun a p -> a@(CP.split_conjunctions (TP.###x_add simplify_a (-1) p))) [] guards in
astsimp.ml:	  (fun d-> not (TP.###x_add is_sat_sub_no 10 (CP.mkAnd c d no_pos) sat_subno)) co ) bcg in
astsimp.ml:    let wf,_ = ###x_add case_normalize_struc_formula 2 prog h p (IF.formula_to_struc_formula new_head) false 
astsimp.ml:  let wf,_ = ###x_add case_normalize_struc_formula 1 prog h p (IF.formula_to_struc_formula i_rhs (* coer.I.coercion_body *)) false 
astsimp.ml:  (* let wf,_ = ###x_add case_normalize_struc_formula 2 prog h p (IF.formula_to_struc_formula new_head) false  *)
astsimp.ml:                let new_body = CF.###x_add normalize 1 c.C.coercion_body (CF.formula_of_mix_formula c_guard no_pos) no_pos in
astsimp.ml:                              let vdef = I.###x_add look_up_view_def_raw 8 prog.I.prog_view_decls v in
astsimp.ml:(*               Tpdispatcher.###x_add is_sat_sub_no 11 f_sat sat_subno *)
astsimp.ml:(*                       if (Tpdispatcher.###x_add is_sat_sub_no 12 (Cpure.mkAnd p1i c no_pos) sat_subno) then  *)
astsimp.ml:(*                           if (Tpdispatcher.###x_add is_sat_sub_no 13 (Cpure.mkAnd p1 c no_pos) sat_subno) then  *)
astsimp.ml:                                if (Tpdispatcher.###x_add is_sat_sub_no 12 (Cpure.mkAnd p1i c no_pos) sat_subno) then 
astsimp.ml:                                  if (Tpdispatcher.###x_add is_sat_sub_no 13 (Cpure.mkAnd p1 c no_pos) sat_subno) then 
astsimp.ml:                (*       Tpdispatcher.###x_add is_sat_sub_no 11 f_sat sat_subno *)
astsimp.ml:              CF.formula_assume_simpl = CF.###x_add normalize 2 b.CF.formula_assume_simpl f no_pos;
astsimp.ml:                          let f1 = Cpure.arith_###x_add simplify 2 cf1 in
astsimp.ml:                        let vdef = I.###x_add look_up_view_def_raw 9 prog.I.prog_view_decls c in
astsimp.ml:                        let new_dl = Cpure.arith_###x_add simplify 5 new_dl in
astsimp.ml:              CF.h_formula_thread_name = CF.###x_add get_node_name 1 dataNode2;
astsimp.ml:                                    let vdef = I.###x_add look_up_view_def_raw 9 prog.I.prog_view_decls c in
astsimp.ml:      let new_p = Cpure.arith_###x_add simplify 5 new_p in
astsimp.ml:      let new_dl = Cpure.arith_###x_add simplify 5 new_dl in
astsimp.ml:      let new_p = Cpure.arith_###x_add simplify 5 new_p in
astsimp.ml:              let vdef = I.###x_add look_up_view_def_raw 11 prog.I.prog_view_decls b.IF.h_formula_heap_name in
astsimp.ml:and ###x_add case_normalize_struc_formula i prog (h:(ident*primed) list)(p:(ident*primed) list)(f:IF.struc_formula) allow_primes
astsimp.ml:  (* let () = print_string ("###x_add case_normalize_struc_formula :: CHECK POINT 0 ==> f = " ^ Iprinter.string_of_struc_formula f ^ "\n") in *)
astsimp.ml:  (* let () = print_string ("\n###x_add case_normalize_struc_formula :: CHECK POINT 0.5 ==> f = " ^ Iprinter.string_of_struc_formula nf) in *)
astsimp.ml:  (* let () = print_string ("\n###x_add case_normalize_struc_formula :: CHECK POINT 1 ==> nf = " ^ Iprinter.string_of_struc_formula nf ) in *)
astsimp.ml:  (* let () = print_string ("\n###x_add case_normalize_struc_formula :: CHECK POINT 2 ==> nf = " ^ Iprinter.string_of_struc_formula nf) in *)
astsimp.ml:  (* let () = print_string ("###x_add case_normalize_struc_formula :: CHECK POINT 3 ==> nf = " ^ Iprinter.string_of_struc_formula nf ^ "\n") in *)
astsimp.ml:and simpl_###x_add case_normalize_struc_formula id prog (h_vars:(ident*primed) list)(f:IF.struc_formula) 
astsimp.ml:		let r2 = simpl_###x_add case_normalize_struc_formula i prog h f in
astsimp.ml:		(*let r1 = fst (###x_add case_normalize_struc_formula i prog h p f allow_primes allow_post_vars lax_implicit strad_vs) in
astsimp.ml:	else fst (###x_add case_normalize_struc_formula i prog h p f allow_primes allow_post_vars lax_implicit strad_vs)
astsimp.ml:                      let r, _ = ###x_add case_normalize_struc_formula 3 prog h p (fst asserted_f) true 
astsimp.ml:              (*let ns,_ = ###x_add case_normalize_struc_formula 4 prog h p b.Iast.exp_while_specs false false strad in*)
astsimp.ml:  let nst,h11 = ###x_add case_normalize_struc_formula 5 prog h p f.Iast.proc_static_specs false 
astsimp.ml:  let ndn, h12 = ###x_add case_normalize_struc_formula 6 prog h p f.Iast.proc_dynamic_specs false 
astsimp.ml:  let fct f = fst (###x_add case_normalize_struc_formula 7 prog u p f false 
astsimp.ml:              let tpi = fun f1 f2 -> TP.###x_add imply_one 7 f1 f2 "" false None in
astsimp.ml:          let (b,_,_) = TP.###x_add imply_one 8 f (CP.BForm (c,None)) "" false None in
astsimp.ml:        let r,_,_ = TP.###x_add imply_one 9 all_r (CP.BForm (c,None)) "" false None in
astsimp.ml:    (*     let r,_,_ = TP.###x_add imply_one 10 all_r (CP.BForm (c,None)) "" false None in *)
astsimp.ml:                      in (TP.###x_add is_sat 2 new_f "get_safe_prune_conds" false)
astsimp.ml:            (* if Solver1.###x_add unsat_base_nth "0" prog (ref 0) p1 then raise  (Err.Malformed_barrier (" unsat pre for transition "^t_str ))
astsimp.ml:               else if Solver1.###x_add unsat_base_nth "0" prog (ref 0) p2 then raise  (Err.Malformed_barrier (" unsat post for transition  "^t_str))
astsimp.ml:              let f = Solver.###x_add normalize_formula_w_coers 8 prog empty_es f (Lem_store.all_lemma # get_left_coercion) (*prog.C.prog_left_coercions*) in
astsimp.ml:              if Solver.###x_add unsat_base_nth 3 prog (ref 0) f then (p1,p2)
astsimp.ml:    let tot_pre = Solver.###x_add normalize_formula_w_coers 9 prog empty_es tot_pre (Lem_store.all_lemma # get_left_coercion) (*prog.C.prog_left_coercions*) in
astsimp.ml:    if Solver.###x_add unsat_base_nth 4 prog (ref 0) tot_pre then raise  (Err.Malformed_barrier (" contradiction in pres for transition "^t_str ))
astsimp.ml:        let tot_post = Solver.###x_add normalize_formula_w_coers 10 prog empty_es tot_post (Lem_store.all_lemma # get_left_coercion) (*prog.C.prog_left_coercions*) in
astsimp.ml:        if Solver.###x_add unsat_base_nth 5 prog (ref 0) tot_post then raise (Err.Malformed_barrier (" contradiction in post for transition "^t_str ))
astsimp.ml:        let nf = Solver.###x_add normalize_formula_w_coers 11 prog empty_es nf (Lem_store.all_lemma # get_left_coercion)(*prog.C.prog_left_coercions*) in
astsimp.ml:      if  Solver.###x_add unsat_base_nth 6 prog (ref 0) nf then ()
astsimp.ml:    Tpdispatcher.###x_add is_sat_sub_no 14 (Cpure.Not (f,None,no_pos)) sat_subno
astsimp.ml:            MCP.simpl_memo_pure_formula Solver.simpl_b_formula Solver.simpl_pure_formula calcmem (TP.###x_add simplify_a 10) in 
astsimp.ml:	    let todo_unk = I.###x_add look_up_view_def_raw 3 iprog.I.prog_view_decls name in false
cast.ml:and exp_###x_add unfold = { 
cast.ml:let ###x_add ###x_add subst_mater_list fr t l = 
cast.ml:  Debug.no_2_num i "subst_mater_list" pr_svl pr_svl pr_no (fun _ _ -> ###x_add ###x_add subst_mater_list fr t l) fr t 
cast.ml:  Debug.no_3_num i "subst_mater_list" pr_svl pr_svl !print_mater_prop_list !print_mater_prop_list  ###x_add ###x_add subst_mater_list fr t l
cast.ml:let rec ###x_add look_up_view_def_raw (defs : view_decl list) (name : ident) = match defs with
cast.ml:  | d :: rest -> if d.view_name = name then d else ###x_add look_up_view_def_raw rest name
cast.ml:let ###x_add look_up_view_def_raw i (defs : view_decl list) (name : ident) = 
cast.ml:  Debug.no_1_num i "look_up_view_def_raw" pr pr_out (fun _ -> ###x_add look_up_view_def_raw defs name) name
cast.ml:  let vdcl = ###x_add look_up_view_def_raw 46 defs name in
cast.ml:let rec ###x_add look_up_view_def (pos : loc) (defs : view_decl list) (name : ident) = match defs with
cast.ml:	    else ###x_add look_up_view_def pos rest name
cast.ml:      (fun _ -> ###x_add look_up_view_def pos defs name) name
cast.ml:  let vdef = ###x_add look_up_view_def_raw 1 prog.prog_view_decls name in
cast.ml:  let vdef = ###x_add look_up_view_def_raw 2 prog.prog_view_decls name in
cast.ml:  let vdef = ###x_add look_up_view_def no_pos prog.prog_view_decls c in
cast.ml:            | F.ViewNode _-> F.###x_add get_node_name 2 h
cast.ml:	let pr1 r = match r with | Simple -> "simple" | Complex -> "complex" | Ramify -> "ramify" | Normalize b-> "###x_add normalize "^string_of_bool b in
cast.ml:      let vd = ###x_add look_up_view_def_raw 3 prog.prog_view_decls vn.F.h_formula_view_name in
cast.ml:                        let vd = ###x_add look_up_view_def_raw 13 prog.prog_view_decls vn.F.h_formula_view_name in
cast.ml:(*                         let vd = ###x_add look_up_view_def_raw 13 prog.prog_view_decls vn.F.h_formula_view_name in *)
cast.ml:        (* if !force_verbose_###x_add xpure then Some vdef.view_x_formula  else *) None
cast.ml:				let vdef = ###x_add look_up_view_def_raw 4 cprog.prog_view_decls vn.F.h_formula_view_name in
cast.ml:  let vdef = ###x_add look_up_view_def_raw 5 cviews vname in
cast.ml:(* ###x_add unfold the occurences of a view in a formula by its base case *)
cast.ml:      (* ###x_add unfold the inductive formulathen collect residents *)
cast.ml:  let is_core_dnode node = eq_str (F.###x_add get_node_name 3 node) dname in
cast.ml:  let is_core_vnode node = eq_str (F.###x_add get_node_name 4 node) vname in
cast.ml:            (* ###x_add unfold the inductive formulathen collect residents *)
cast.ml:            let vdef = ###x_add look_up_view_def v.h_formula_view_pos prog.prog_view_decls v.h_formula_view_name in
cformula.ml:and ###x_add get_node_name i (h : h_formula) =
cformula.ml:        let name = ###x_add get_node_name 5 h in
cformula.ml:and ###x_add normalize i (f1 : formula) (f2 : formula) (pos : loc) =
cformula.ml:			(* let () = print_string("###x_add normalize 1\n") in *)
cformula.ml:			(* let () = print_string("###x_add normalize 2\n") in *)
cformula.ml:(* WN : can ###x_add simplify ignore other type of pure ctrs? *)
cformula.ml:              if (CP.isConstTrue p2 || CP.is_###x_add xpure p2) then
cformula.ml:            if (CP.isConstTrue p2 || CP.is_###x_add xpure p2) then
cformula.ml:            if (CP.isConstTrue p2 || CP.is_###x_add xpure p2) then
cformula.ml:            CP.get_###x_add xpure (MCP.pure_of_mix p1)
cformula.ml:(*   let view_def =  Cast.###x_add look_up_view_def no_pos prog.Cast.prog_view_decls hv.CF.h_formula_view_name in *)
cformula.ml:  (*check onl_ptrs are ###x_add unfold points - view*)
cformula.ml:            let np2 = CP.###x_add filter_var np1 keep_svl in
cformula.ml:                    (CP.###x_add filter_var (MCP.pure_of_mix b.formula_base_pure)
cformula.ml:            let np = CP.remove_redundant (CP.###x_add filter_var p null_diff) in
cformula.ml:        let unk_hp_args = CP.get_###x_add xpure p in
cformula.ml:          (CP.drop_###x_add xpure p, true)
cformula.ml:  let xpures = List.fold_left (fun ls p -> ls@(CP.get_###x_add xpure p)) [] com_eqPures in
cformula.ml:            let g_pure = (* CP.###x_add filter_var *) (* CP.subst ss *) p in
cformula.ml:            let g_pure_base = (* CP.###x_add filter_var *) p_base (* g_svl *) in
cformula.ml:          let refined_inv = CP.###x_add filter_var inv1 hv.h_formula_view_arguments in
cformula.ml:    let p1 = CP.###x_add filter_var p keep_svl in
cformula.ml:    (* let filtered_inv = CP.###x_add filter_var inv keep_svl in *)
cformula.ml:    (* to be used for ###x_add xpure conversion *)
cformula.ml:     to be used by ###x_add infer_lhs_contra to determine if
cformula.ml:let failesc_context_###x_add simplify ((l,a,cs) : failesc_context) : failesc_context =  (l,a,remove_dupl_false cs)
cformula.ml:let failesc_context_###x_add simplify (ctx: failesc_context) : failesc_context =
cformula.ml:    failesc_context_###x_add simplify ctx
cformula.ml:let list_failesc_context_###x_add simplify (l : list_failesc_context) : list_failesc_context = 
cformula.ml:  List.map failesc_context_###x_add simplify l
cformula.ml:let list_failesc_context_###x_add simplify (l : list_failesc_context) : list_failesc_context = 
cformula.ml:  Debug.no_1 "list_failesc_context_simplify" pr pr list_failesc_context_###x_add simplify l 
cformula.ml:  let ###x_add simplify x = (* context_list_simplify *) x in
cformula.ml:  | FailCtx t1 ,SuccCtx t2 -> SuccCtx (###x_add simplify t2)
cformula.ml:  | SuccCtx t1 ,FailCtx t2 -> SuccCtx (###x_add simplify t1)
cformula.ml:and ###x_add fold_context_left i c_l = 
cformula.ml:  (* let cl = list_failesc_context_###x_add simplify cl in *)
cformula.ml:(*TODO: expand simplify_context to ###x_add normalize by flow type *)
cformula.ml:  Debug.no_2 "normalize_es" pr pr_e pr_c (fun _ _ -> normalize_es_x  f pos  result_###x_add is_sat es) f es
cformula.ml:	Ctx {es with es_formula = ###x_add normalize 3 es.es_formula f pos; es_unsat_flag = es.es_unsat_flag&&result_is_sat} 
cformula.ml:  Debug.no_2 "normalize_clash_es" pr pr_e pr_c (fun _ _ -> normalize_clash_es_x  f pos  result_###x_add is_sat es) f es
cformula.ml:		let new_c1 = normalize_clash_es phi1 pos result_###x_add is_sat es in
cformula.ml:		let new_c2 = normalize_clash_es phi2 pos result_###x_add is_sat es in
cformula.ml:  (* let () = print_string("cris: ###x_add normalize 11\n") in *)
cformula.ml:  (* let () = print_string("cris: ###x_add normalize 12\n") in *)
cformula.ml:  (* let () = print_string("cris: ###x_add normalize 13\n") in *)
cformula.ml:  (* let () = print_string("cris: ###x_add normalize 14\n") in *)
cformula.ml:  (* let () = print_string("cris: ###x_add normalize 15\n") in *)
cformula.ml:let ###x_add add_to_context (c:context) (s:string) =
cformula.ml:  Debug.no_1_num i "add_to_context" pr pr_no (fun _ -> ###x_add add_to_context c s) c
cformula.ml:				List.map (fun (d1,d2)-> ((###x_add normalize 4 d1 (formula_of_pure_N c1 b.formula_case_pos) b.formula_case_pos),d2)) ll) b.formula_case_branches) in
cformula.ml:				let e = List.map (fun (c1,c2)-> ((###x_add normalize 5 c1 b.formula_struc_base b.formula_struc_pos),c2)) ll in
cformula.ml:(** An Hoa : ###x_add simplify a heap formula with the constraints, bv stores the base variables **)
cformula.ml:    let p = CP.mkExists_with_simpl (* Omega.###x_add simplify *)!CP.simplify post_vars (MCP.pure_of_mix p) None no_pos in
cformula.ml:              let rel_fm = CP.###x_add filter_var p sel_svl in
cformula.ml:            let rel_fm = CP.###x_add filter_var p sel_svl in
cformula.ml:  let post = ###x_add normalize 5 inv tmp pos in
cformula.ml:  let pre = ###x_add normalize 5 inv tmp_pre pos in
cformula.ml:          if (b) then [(get_node_args h, ###x_add get_node_name 6 h)] else []
cfutil.ml:              let vdcecl = Cast.###x_add look_up_view_def_raw 58 prog.Cast.prog_view_decls vn.h_formula_view_name in
cfutil.ml:            let vdef = Cast.###x_add look_up_view_def pos prog.Cast.prog_view_decls c in
cfutil.ml:          (* let () = print_endline ("-- ###x_add unfold lsh on " ^ (Cprinter.string_of_spec_var sv)) in *)
cfutil.ml:            (*###x_add unfold case*)
cfutil.ml:            let rvdcl = Cast.###x_add look_up_view_def_raw 57 prog.Cast.prog_view_decls rvn.h_formula_view_name in
cfutil.ml:  let pure_constr = CP.###x_add filter_var (get_pure f) pure_svl in
cfutil.ml:    let vdcl = Cast.###x_add look_up_view_def_raw 61 prog.Cast.prog_view_decls lvnode.h_formula_view_name in
cfutil.ml:    (*check root has ###x_add unfold information??*)
cfutil.ml:      (*         let rvdcl = Cast.###x_add look_up_view_def_raw 57 prog.Cast.prog_view_decls rvn.h_formula_view_name in *)
cfutil.ml:      let vdcl = Cast.###x_add look_up_view_def_raw 59 prog.Cast.prog_view_decls lvnode.h_formula_view_name in
cfutil.ml:    let vdecl = Cast.###x_add look_up_view_def_raw 60 prog.Cast.prog_view_decls rvnode.h_formula_view_name in
cfutil.ml:    let vdcl = Cast.###x_add look_up_view_def_raw 59 prog.Cast.prog_view_decls rvnode.h_formula_view_name in
cfutil.ml:  let vdecl = Cast.###x_add look_up_view_def_raw 60 prog.Cast.prog_view_decls lvnode.h_formula_view_name in
cfutil.ml:  let vdecl = Cast.###x_add look_up_view_def_raw 60 prog.Cast.prog_view_decls rvnode.h_formula_view_name in
cfutil.ml:let need_cycle_checkpoint_###x_add unfold prog lvnode lhs rdnode rhs reqset=
cfutil.ml:        (*###x_add normalize the paras (convert back to the orig)*)
cfutil.ml:  let vdcl = Cast.###x_add look_up_view_def_raw 62 prog.Cast.prog_view_decls vn.h_formula_view_name in
cilparser.ml:                  (* ###x_add simplify conditional expression in if-statement *)
context.ml:  | M_###x_add unfold  of (match_res * int) (* zero denotes no counting *)
context.ml:  | M_base_case_###x_add unfold of match_res
context.ml:        (*match * number_of_###x_add unfold * unfold_or_fold * type_lemma_syn*)
context.ml:    | M_###x_add unfold  (m,_)
context.ml:    | M_base_case_###x_add unfold m
context.ml:  | M_###x_add unfold (e,i) -> fmt_string ("Unfold "^(string_of_int i))
context.ml:  | M_base_case_###x_add unfold e -> fmt_string "BaseCaseUnfold"
context.ml:  | M_###x_add unfold (e,i) -> fmt_string ("Unfold "^(string_of_int i)^" =>"); pr_mr e
context.ml:  | M_base_case_###x_add unfold e -> fmt_string "BaseCaseUnfold =>"; pr_mr e
context.ml:  | M_###x_add unfold (e,_)
context.ml:  | M_base_case_###x_add unfold e
context.ml:  let vdef = ###x_add look_up_view_def_raw 11 prog.prog_view_decls c in
context.ml:(*         let vdecl = ###x_add look_up_view_def_raw 0 prog.prog_view_decls vname in                      *)
context.ml:                  let vl_vdef = ###x_add look_up_view_def_raw 12 view_decls vl_name in
context.ml:                  let vr_vdef = ###x_add look_up_view_def_raw 13 view_decls vr_name in
context.ml:          let vdecl = ###x_add look_up_view_def_raw 1 prog.prog_view_decls vr_name in
context.ml:                (* let l1 = [(1,M_base_case_###x_add unfold m_res)] in *)
context.ml:                let vl_vdef = ###x_add look_up_view_def_raw 14 view_decls vl_name in
context.ml:                let vr_vdef = ###x_add look_up_view_def_raw 14 view_decls vr_name in
context.ml:                       let a1 = (2,M_base_case_###x_add unfold m_res) in
context.ml:                      (*Do not fold/###x_add unfold LOCKs, only match*)
context.ml:                        if (String.compare vl_name vr_name)==0 then Some (if !dis_base_case_###x_add unfold then a2 else (1, Cond_action [a1;a2]))
context.ml:                      (*Do not fold/###x_add unfold LOCKs*)
context.ml:                        if not(vl_is_rec) && not(vl_is_prim) then Some (2,M_###x_add unfold (m_res,0))
context.ml:                            (*Do not fold/###x_add unfold LOCKs*)
context.ml:                            (*Do not fold/###x_add unfold LOCKs*)
context.ml:                              then [(2,M_###x_add unfold (m_res,0))]
context.ml:                        (* TO m_resHECK : MUST ensure not fold/###x_add unfold LOCKs*)
context.ml:                        (* let lst=[(1,M_base_case_###x_add unfold m_res);(1,M_Nothing_to_do ("mis-matched LHS:"^(vl_name)^" and RHS: "^(vr_name)))] in *)
context.ml:                        (*cyclic: add lemma_unsafe then ###x_add unfold lhs*)
context.ml:                                [(1,M_cyclic (m_res,uf_i,0, syn_lem_typ, None))(* ;(1,M_###x_add unfold (m_res, uf_i)) *)]
context.ml:                                let acts = [(3,M_base_case_###x_add unfold m_res) (* ;(1,M_cyclic m_res) *)] in
context.ml:                            (*let lst = [(1,M_base_case_###x_add unfold m_res);(1,M_unmatched_rhs_data_node (rhs_node,m_res.match_res_rhs_rest))] in*)
context.ml:                let vr_vdef = ###x_add look_up_view_def_raw 15 view_decls vr_name in
context.ml:                  let vl_vdef = ###x_add look_up_view_def_raw 16 view_decls vl_name in
context.ml:                  (* let a1 = if (new_orig || vl_self_pts==[]) then [(1,M_###x_add unfold (m_res,uf_i))] else [] in *)
context.ml:                      (*then [(1,M_###x_add unfold (m_res,uf_i))] else [] in*)
context.ml:                          let syn_lem_typ = CFU.need_cycle_checkpoint_###x_add unfold prog vl estate.CF.es_formula dr rhs reqset in
context.ml:                               if lvs = [] then [(1,M_###x_add unfold (m_res,uf_i))] else
context.ml:                          [(1,M_###x_add unfold (m_res,uf_i))] 
context.ml:                          let () = pr_debug "###x_add unfold for meterialised!\n" in  
context.ml:                          M_###x_add unfold (m_res,uf_i) (* uf_i to prevent infinite unfolding *)
context.ml:                  let l1 = if !dis_base_case_###x_add unfold then  [] else [(4,M_base_case_unfold m_res)] in
context.ml:                  (*   | View_mater -> (1,M_###x_add unfold (m_res,uf_i))  *)
context.ml:                      | View_mater -> (uf_i,M_###x_add unfold (m_res,uf_i))
context.ml:                  let vdef = C.###x_add look_up_view_def_raw 43 prog.C.prog_view_decls vl.CF.h_formula_view_name in
context.ml:                      let l1 = if !dis_base_case_###x_add unfold then [] else [(5,M_base_case_unfold m_res)] in
context.ml:        let vl_vdef = ###x_add look_up_view_def_raw 24 prog.Cast.prog_view_decls vl_name in
context.ml:        let vr_vdef = ###x_add look_up_view_def_raw 24 prog.Cast.prog_view_decls vr_name in
context.ml:    | M_base_case_###x_add unfold _ 
context.ml:    | M_###x_add unfold _
context.ml:    | M_###x_add unfold _ -> [(w,a)]
context.ml:      | M_fold _ | M_###x_add unfold _ -> true
coqinf.ml:if !Globals.allow_inf_qe_coq_simp then Gen.Profiling.do_1 "CoqSolverZE" transform_ZE_to_string_###x_add simplify f
coqinf.ml:  let r = (Omega.###x_add simplify f) in
coqinf.ml:      Omega.###x_add simplify f
coqinf.ml:      let flist = List.map (fun c -> Omega.###x_add simplify (Infinity.normalize_inf_formula_sat (mkAnd f c no_pos))) inf_inst in
coqinf.ml:        Omega.###x_add simplify (add_exists (mkAnd c (strongest_inv fu) no_pos) vl)) 
coqinf.ml:        (*Omega.###x_add simplify (add_exists (mkOr f1 c None no_pos) vl))*)
coqinf.ml:       (* Omega.###x_add simplify (mkExists vl (mkOr fa (mkNot fu None no_pos) None no_pos) None no_pos))*)
coq.ml:	output_string log_file ("\n[coq.ml]: ####x_add is_sat " ^ sat_no ^ "\n");
coq.ml:	  if !log_all_flag == true then output_string log_file "[coq.ml]: ###x_add is_sat --> false\n";
coq.ml:	  if !log_all_flag == true then output_string log_file "[coq.ml]: ###x_add is_sat --> true\n";
coq.ml:let ###x_add is_sat (f : CP.formula) (sat_no : string) : bool =
coq.ml:let ###x_add simplify (pe : CP.formula) : CP.formula = begin
cprinter.ml:  | Unfold ({exp_unfold_var = sv}) -> "###x_add unfold " ^ (string_of_spec_var sv)
cpure.ml:(* WN : is this ###x_add simplify to help other provers? *)
cpure.ml:and should_###x_add simplify (f : formula) =
cpure.ml:      | Or (f1,f2,_,_)-> should_###x_add simplify f1 || should_simplify f2
cpure.ml:      | AndList b -> exists_l_snd should_###x_add simplify b
cpure.ml:and is_###x_add xpure p=
cpure.ml:  | BForm (b,_) ->  is_b_form_###x_add xpure b
cpure.ml:and is_b_form_###x_add xpure (b: b_formula) :bool = let (pf,_) = b in
cpure.ml:and ###x_add simplify = ref (fun (c:formula) -> mkTrue no_pos)
cpure.ml:	  let rl,vl,rf = List.fold_left (fun (al,avs,af) (cl,cvs,cf)-> (LO.###x_add ###x_add comb_norm 2 al cl,avs@cvs, mkAnd af cf pos)) (List.hd lf) (List.tl lf) in
cpure.ml:      let xps1,rems1=List.partition is_###x_add xpure ps1 in
cpure.ml:      let xps2,rems2=List.partition is_###x_add xpure ps2 in
cpure.ml:(* prior to sending a formula for Omega to ###x_add simplify *)
cpure.ml:let rec ###x_add filter_var (f0 : formula) (rele_vars0 : spec_var list) : formula =
cpure.ml:let ###x_add filter_var (f0 : formula) (keep_slv : spec_var list) : formula =
cpure.ml:      (fun _ _ -> ###x_add filter_var f0 keep_slv) f0 keep_slv
cpure.ml:  let antes = List.map (fun reles -> ###x_add filter_var ante reles) fvars in
cpure.ml:and b_form_###x_add simplify (pf : b_formula) :  b_formula =   
cpure.ml:  Debug.no_1 "b_form_###x_add simplify " !print_b_formula !print_b_formula 
cpure.ml:and arith_###x_add simplify (i:int) (pf : formula) :  formula =
cpure.ml:  Debug.no_1 ("arith_###x_add simplify LHS") !print_formula !print_formula
cpure.ml:    |  BForm (b,lbl) -> BForm (b_form_###x_add simplify b,lbl)
cpure.ml:	    | XPure _ (* WN : ###x_add xpure *)
cpure.ml:(* ###x_add normalize add/sub expression *)
cpure.ml:(* normalise and ###x_add simplify expression *)
cpure.ml:(* normalise and ###x_add simplify b_formula *)
cpure.ml:  (*let bf = b_form_###x_add simplify bf in *)
cpure.ml:  (*###x_add normalize lhs and rhs*)
cpure.ml:let store_tp_###x_add is_sat : (formula -> bool) ref = ref (fun _ -> true)
cpure.ml:      let f = !store_tp_###x_add is_sat in
cpure.ml:  if not(xp01) && !Globals.super_smart_###x_add xpure && not(one_ante_only) then
cpure.ml:(* to be implemented : use GCD, then ###x_add simplify fraction *)
cpure.ml:(* normalise and ###x_add simplify b_formula *)
cpure.ml:  (*let bf = b_form_###x_add simplify bf in *)
cpure.ml:let rec extract_###x_add xpure p=
cpure.ml:  | BForm (b,_) ->  extract_xpure_b_form_###x_add xpure b
cpure.ml:and extract_xpure_b_form_###x_add xpure (b: b_formula) = let (pf,_) = b in
cpure.ml:let rec get_###x_add xpure p0=
cpure.ml:      | BForm (b,_) -> get_xpure_b_form_###x_add xpure b
cpure.ml:and get_xpure_b_form_###x_add xpure (b: b_formula) = let (pf,_) = b in
cpure.ml:and drop_###x_add xpure f0 =
cpure.ml: * aggressive ###x_add simplify and normalize
cpure.ml:   * also ###x_add simplify the case coeff = 0 or 1 and empty mult_terms list
cpure.ml:let inner_###x_add simplify simpl f =
cpure.ml:  (* Thai: Why only ###x_add simplify with Exists stms? *)
cpure.ml:  inner_###x_add simplify simpl f
cpure.ml:(* result of ###x_add xpure with baga and memset/diffset *)
cpure.ml:  let ante = ###x_add filter_var ante fvar in
cpure.ml:  let new_ante = ###x_add filter_var ante fvar in
cpure.ml:let part_contradiction ###x_add is_sat pairs =
cpure.ml:  let (p1,p2) = List.partition (fun (a,c) -> not(###x_add is_sat c)) pairs in
cpure.ml:let part_must_failures ###x_add is_sat pairs = List.partition (fun (a,c) ->not(is_sat (mkAnd a c no_pos))) pairs
cpure.ml:let part_must_failures ###x_add is_sat pairs = List.partition (fun (a,c) -> not(is_sat (mkAnd a c no_pos))) pairs
cpure.ml:let imply ###x_add is_sat a c = not (is_sat (mkAnd a (mkNot c None no_pos) no_pos))
cpure.ml:let refine_one_must ###x_add is_sat (ante,conseq) : (formula * formula) list =
cpure.ml:      not(###x_add is_sat f)) cs in
cpure.ml:let refine_one_must ###x_add is_sat (ante,conseq) : (formula * formula) list =
cpure.ml:  Debug.no_1 "refine_one_must" (pr_pair pr pr) pr2 (fun  _ ->refine_one_must ###x_add is_sat (ante, conseq)) (ante, conseq)
cpure.ml:let refine_must ###x_add is_sat (pairs:(formula * formula) list) : (formula * formula) list =
cpure.ml:let find_all_failures ###x_add is_sat ante cons =
cpure.ml:  let (contra_list,cand_pairs) = part_contradiction ###x_add is_sat cand_pairs in
cpure.ml:  let (must_list,cand_pairs) = part_must_failures ###x_add is_sat cand_pairs in
cpure.ml:  let must_list = refine_must ###x_add is_sat must_list in
cpure.ml:let find_all_failures ###x_add is_sat  ante cons =
cpure.ml:  Debug.no_2 "find_all_failures" pr pr (pr_triple pr2 pr2 pr2) (fun _ _ -> find_all_failures ###x_add is_sat ante cons) ante cons 
cpure.ml:let find_must_failures ###x_add is_sat ante cons =
cpure.ml:  let (contra_list,must_list,_) = find_all_failures ###x_add is_sat ante cons in
cpure.ml:let find_must_failures ###x_add is_sat ante cons =
cpure.ml:  Debug.no_2 "find_must_failures" pr pr pr2 (fun _ _ -> find_must_failures ###x_add is_sat ante cons) ante cons 
cpure.ml:let check_maymust_failure ###x_add is_sat ante cons =
cpure.ml:  let c_l = find_must_failures ###x_add is_sat ante cons in
cpure.ml:let check_maymust_failure ###x_add is_sat ante cons =
cpure.ml:  Debug.no_2 "check_maymust_failure" pr pr string_of_bool (fun _ _ -> check_maymust_failure ###x_add is_sat ante cons) ante cons 
cpure.ml:(* For assigning <IL> fields after doing ###x_add simplify  
cpure.ml:   Used by TP.###x_add simplify to recover <IL> information *)
cpure.ml:let assumption_filter_aggressive ###x_add is_sat (ante : formula) (conseq : formula) : (formula * formula) =
cpure.ml:    let ante_ls = List.filter ###x_add is_sat (split_disjunctions ante) in
cpure.ml:(*First ###x_add normalize waitlevel into its normal form of 2 types
cpure.ml:  (*First ###x_add normalize waitlevel into its normal form of 2 types
cpure.ml:let check_pointer_d###x_add is_sat c= 
cpure.ml:    let simp_f = !###x_add simplify f in
cvc3.ml:(*###x_add simplify f formula and return the simplified formula *)
cvc3.ml:  let () = log_text_to_cvc3 ("%%% ###x_add is_sat " ^ sat_no ^ "\n") in
cvc3.ml:        (log_text_to_cvc3   "%%% ###x_add is_sat --> true (from unknown)\n\n";  flush !cvc3_log);
cvc3.ml:let  ###x_add is_sat (f : CP.formula) (sat_no : string) : bool =
cvclite.ml:	  output_string !cvcl_log ("%%% ###x_add is_sat " ^ sat_no ^ "\n");
cvclite.ml:					if not (Omega.###x_add is_sat f) then
cvclite.ml:and ###x_add is_sat (f : CP.formula) (sat_no : string) : bool =
cvclite.ml:	  		output_string !cvcl_log "%%% ###x_add is_sat --> true (from unknown)\n"
cvutil.ml:	    let simpl_f = TP.###x_add simplify_a 9 (CP.BForm(f,None)) in
cvutil.ml:	    let simpl_f = Tpdispatcher.###x_add simplify_a 8 (CP.BForm(f,None)) in
cvutil.ml:	    let simpl_f = Tpdispatcher.###x_add simplify_a 7 (CP.BForm(f,None)) in
cvutil.ml:			let simpl_f = Tpdispatcher.###x_add simplify_a 6 (CP.BForm(f,None)) in
cvutil.ml:    (* let vdcl = Cast.###x_add look_up_view_def_raw 57 prog.Cast.prog_view_decls vn.h_formula_view_name in *)
cvutil.ml:          if ###x_add is_sat && term_first_sat then
cvutil.ml:  let vdecl = Cast.###x_add look_up_view_def_raw 57 prog.Cast.prog_view_decls vname in
cvutil.ml:                          let res,_,_ = CP.imply_disj_orig [f0] full_f (TP.###x_add imply_one 24) imp_no in
cvutil.ml:            let vdef = ###x_add look_up_view_def pos prog.prog_view_decls c in
cvutil.ml:                    let res,_,_ = CP.imply_disj_orig [f0] full_f (TP.###x_add imply_one 25) imp_no in
cvutil.ml:                                let res,_,_ = CP.imply_disj_orig [f0] full_f (TP.###x_add imply_one 24) imp_no in
cvutil.ml:	      (* let vdef = ###x_add look_up_view_def pos prog.prog_view_decls c in *)
cvutil.ml:              let vdef = ###x_add look_up_view_def pos prog.prog_view_decls c in
cvutil.ml:                          let res,_,_ = CP.imply_disj_orig [f0] full_f (TP.###x_add imply_one 25) imp_no in
cvutil.ml:let rec ###x_add xpure_mem_enum i (prog : prog_decl) (* is_conseq:bool *) (f0 : formula) : (mix_formula * CF.mem_formula) = 
cvutil.ml:(* ###x_add xpure approximation with memory enumeration *)
cvutil.ml:  (*use different ###x_add xpure functions*)
cvutil.ml:            let (ph,_) = x_add ###x_add xpure_heap_mem_enum 2 prog h p 1 in
cvutil.ml:            let (pqh,_) = x_add ###x_add xpure_heap_mem_enum 3 prog qh qp 1 in
cvutil.ml:and xpure_heap_enum_baga_a (prog : prog_decl) (h0 : h_formula) (p0: mix_formula) (which_###x_add xpure :int) : Excore.ef_pure_disj =
cvutil.ml:and xpure_heap_enum_baga (prog : prog_decl) (h0 : h_formula) (p0: mix_formula) (which_###x_add xpure :int) : Excore.ef_pure_disj =
cvutil.ml:      (fun _ _ -> xpure_heap_enum_baga_a (prog : prog_decl) (h0 : h_formula) (p0: mix_formula) (which_###x_add xpure :int)) h0 p0
cvutil.ml:      (prog : prog_decl) (h0 : h_formula) (p0: mix_formula) (which_###x_add xpure :int) : (MCP.mix_formula * CF.mem_formula)
cvutil.ml:  if !Globals.baga_###x_add xpure && not(!Globals.en_slc_ps) && (not (Perm.allow_perm ())) then
cvutil.ml:    let disj = x_add xpure_heap_enum_baga (prog : prog_decl) (h0 : h_formula) (p0: mix_formula) (which_###x_add xpure :int) in
cvutil.ml:    xpure_heap_mem_enum_x (prog : prog_decl) (h0 : h_formula) (p0: mix_formula) (which_###x_add xpure :int)
cvutil.ml:    (* if !Globals.baga_###x_add xpure then *)
cvutil.ml:    (*   let disj = x_add xpure_heap_enum_baga (prog : prog_decl) (h0 : h_formula) (p0: mix_formula) (which_###x_add xpure :int) in *)
cvutil.ml:      xpure_heap_mem_enum_x (prog : prog_decl) (h0 : h_formula) (p0: mix_formula) (which_###x_add xpure :int)
cvutil.ml:and xpure_heap_mem_enum(*_debug*) i (prog : prog_decl) (h0 : h_formula) (p0: mix_formula) (which_###x_add xpure :int) : (MCP.mix_formula * CF.mem_formula) =
cvutil.ml:and xpure_heap_mem_enum_x (prog : prog_decl) (h0 : h_formula) (p0: mix_formula) (which_###x_add xpure :int) : (MCP.mix_formula * CF.mem_formula) =
cvutil.ml:  let rec xpure_heap_helper (prog : prog_decl) (h0 : h_formula) (which_###x_add xpure :int) memset: MCP.mix_formula =
cvutil.ml:            let mf,_ = x_add ###x_add xpure_mem_enum 1 prog rsr in
cvutil.ml:            let vdef = ###x_add look_up_view_def pos prog.prog_view_decls c in
cvutil.ml:                      let inv = if !force_verbose_###x_add xpure && which_xpure =1 && not(vdef.view_xpure_flag) then vdef.view_x_formula else vdef.view_user_inv in
cvutil.ml:                       let () = Debug.ninfo_hprint (add_str " which_xpure" string_of_int)  which_###x_add xpure no_pos in
cvutil.ml:                      let vinv = match which_###x_add xpure with
cvutil.ml:                        | _ ->  (* if !force_verbose_###x_add xpure &&  not(vdef.view_xpure_flag) then vdef.view_x_formula else *) xp1
cvutil.ml:                        A better ###x_add xpure could be:
cvutil.ml:            let ph1 = x_add xpure_heap_helper prog h1 which_###x_add xpure memset in
cvutil.ml:            let ph2 = x_add xpure_heap_helper prog h2 which_###x_add xpure memset in
cvutil.ml:  if (is_sat_mem_formula memset) then (x_add xpure_heap_helper prog h0 which_###x_add xpure memset, memset)
cvutil.ml:		          let b,_,_ = CP.imply_disj_orig [f] or_f (TP.###x_add imply_one 100) imp_no in
cvutil.ml:			    let b =  not (TP.###x_add is_sat_sub_no 8 nf (ref 0)) in
cvutil.ml:			  let b,_,_ = CP.imply_disj_orig [f] gt_exp (TP.###x_add imply_one 101) imp_no in
cvutil.ml:and ###x_add xpure_symbolic i (prog : prog_decl) (h0 : formula) : (MCP.mix_formula  * CP.spec_var list * CF.mem_formula) =
cvutil.ml:  if !Globals.baga_###x_add xpure && !Globals.do_under_baga_approx then
cvutil.ml:(* ###x_add xpure approximation without memory enumeration *)
cvutil.ml:  (*use different ###x_add xpure functions*)
cvutil.ml:and xpure_heap_symbolic i (prog : prog_decl) (h0 : h_formula) (p0: mix_formula) (which_###x_add xpure :int) : (MCP.mix_formula * CP.spec_var list * CF.mem_formula) = 
cvutil.ml:      (fun which_###x_add xpure h0 p0 -> xpure_heap_symbolic_x prog h0 p0 which_xpure) which_xpure h0 p0
cvutil.ml:and xpure_heap_symbolic_x (prog : prog_decl) (h0 : h_formula) (p0: mix_formula) (which_###x_add xpure :int) : (MCP.mix_formula * CP.spec_var list * CF.mem_formula) = 
cvutil.ml:  let ph, pa = x_add xpure_heap_symbolic_i prog h0 p0 which_###x_add xpure in
cvutil.ml:          let mf,svl,_ = x_add ###x_add xpure_symbolic 5 prog rsr in
cvutil.ml:          let vdef = ###x_add look_up_view_def pos prog.prog_view_decls c in
cvutil.ml:                    | Some ls -> if !force_verbose_###x_add xpure then helper ()
cvutil.ml:let xpure_heap_x (prog : prog_decl) (h0 : h_formula) (p0 : mix_formula) (which_###x_add xpure :int) (sym_flag:bool) : (mix_formula * CP.spec_var list * CF.mem_formula) =
cvutil.ml:    let a, c = x_add ###x_add xpure_heap_mem_enum 6 prog h0 p0 which_###x_add xpure in
cvutil.ml:let xpure_heap_new (prog : prog_decl) (h0 : h_formula) (p0 : mix_formula) (which_###x_add xpure :int) (sym_flag:bool) : (mix_formula * CP.spec_var list * CF.mem_formula) =
cvutil.ml:  let (mf,svl,diff) as x = x_add xpure_heap_x prog h0 p0 which_###x_add xpure sym_flag in
cvutil.ml:let xpure_heap i (prog : prog_decl) (h0 : h_formula) (p0 : mix_formula) (which_###x_add xpure :int) : (mix_formula * CP.spec_var list * CF.mem_formula)=
cvutil.ml:      (fun _ _ _ -> xpure_heap_new prog h0 p0 which_###x_add xpure sym_flag ) h0 p0 which_xpure
cvutil.ml:let xpure_heap_sym i (prog : prog_decl) (h0 : h_formula) (p0 : mix_formula) (which_###x_add xpure :int) : (mix_formula * CP.spec_var list * CF.mem_formula)=
cvutil.ml:      (fun _ _ _ -> xpure_heap_new prog h0 p0 which_###x_add xpure sym_flag ) h0 p0 which_xpure
cvutil.ml:    x_add ###x_add xpure_symbolic 4 prog f0
cvutil.ml:    let a, c = x_add ###x_add xpure_mem_enum 2 prog f0 in
cvutil.ml:let ###x_add xpure i (prog : prog_decl) (f0 : formula) : (mix_formula * CP.spec_var list * CF.mem_formula) =
cvutil.ml:    x_add ###x_add xpure_symbolic 48 prog f0
cvutil.ml:        let vdef = ###x_add look_up_view_def pos prog.prog_view_decls c in(* views have been ordered such that this dependency is respected *)
cvutil.ml:(* ###x_add xpure of consumed precondition *)
cvutil.ml:                  let vdef = ###x_add look_up_view_def pos prog.prog_view_decls c in
cvutil.ml:      let nmem = filter_useless_memo_pure (TP.###x_add simplify_a 5) simp_b fv b.formula_base_pure in
cvutil.ml:      let nmem = filter_useless_memo_pure (TP.###x_add simplify_a 4) simp_b fv e.formula_exists_pure in
cvutil.ml:          let v_def = ###x_add look_up_view_def v.h_formula_view_pos prog.prog_view_decls v.h_formula_view_name in
cvutil.ml:  let imply_w f1 f2 = let r,_,_ = TP.###x_add imply_one 26 f1 f2 "elim_rc" false None in r in   
cvutil.ml:  let f_p_simp c = if simp_b then MCP.elim_redundant(*_debug*) (imply_w,TP.###x_add simplify_a 3) c else c in
cvutil.ml:let remove_imm_from_heap_formula prog p0 which_###x_add xpure imml fh = (* fh *)
cvutil.ml:  let rec remove_imm_from_heap_formula_helper prog p0 which_###x_add xpure imml fh =
cvutil.ml:    let fun_help =  (remove_imm_from_heap_formula_helper prog p0 which_###x_add xpure imml) in 
cvutil.ml:              (* let xpure, _  = x_add ###x_add xpure_heap_mem_enum prog fh p0 which_###x_add xpure in *)
cvutil.ml:              let xpure, _, _  = x_add xpure_heap_symbolic 9 prog fh p0 which_###x_add xpure in
cvutil.ml:              (* let xpure, _ = x_add ###x_add xpure_heap_mem_enum prog fh p0 which_###x_add xpure in *)
cvutil.ml:              let xpure, _, _  = x_add xpure_heap_symbolic 10 prog fh p0 which_###x_add xpure in
cvutil.ml:  remove_imm_from_heap_formula_helper prog p0 which_###x_add xpure imml fh
cvutil.ml:    (* decide below the value for which_###x_add xpure (1 or 0) ? *)
cvutil.ml:    let disj = if not (CP.isAccs imml) then snd (x_add ###x_add xpure_heap_mem_enum 4 prog h p 1) else {mem_formula_mset = []} in (* get the dijointness information *)
cvutil.ml:    let fh, x, removed_vars = remove_imm_from_heap_formula prog p 1 imml h in (* remove @L and retrieve ###x_add xpure of removed nodes *)    
cvutil.ml:    let vdecl = Cast.###x_add look_up_view_def_raw 56 prog.Cast.prog_view_decls vname in
da.ml:                    let rec_ctx = CP.###x_add filter_var pc.sp_constr larg_svl in
debug.ml:(*       val ###x_add ###x_add comb_norm : int -> t -> t -> t (\* combine two normalised labels *\) *)
derive.ml:  let extn_v = Cast.###x_add look_up_view_def_raw 47  cviews extn_view_name in
derive.ml:  (extn_view_name, ho_bs, ho_inds(* , CP.###x_add filter_var inv_p extn_v.Cast.view_vars *))
derive.ml:          (*quans: ex quans from ###x_add normalize min/max*)
derive.ml:  let extn_view = Cast.###x_add look_up_view_def_raw 48 cviews extn_view_name in
derive.ml:  let orig_view = Cast.###x_add look_up_view_def_raw 49 cviews orig_view_name in
derive.ml:  (* let iview_orig = Iast.###x_add look_up_view_def_raw 53 prog.Iast.prog_view_decls orig_view.Cast.view_name in *)
derive.ml:    let der_vdecl = Iast.###x_add look_up_view_def_raw 54 prog.Iast.prog_view_decls view_derv.Iast.view_name in
derive.ml:  let orig_view = Cast.###x_add look_up_view_def_raw 52 cviews orig_view_name in
derive.ml:  let spec_view = Cast.###x_add look_up_view_def_raw 49 cviews spec_view_name in
derive.ml:  (* let extn_view = Cast.###x_add look_up_view_def_raw cviews extn_view_name in *)
derive.ml:  let orig_view = Cast.###x_add look_up_view_def_raw 50 cviews orig_view_name in
derive.ml:          let extn_view = Cast.###x_add look_up_view_def_raw 51 cviews extn_view_name in
derive.ml:            let iderv_view = Iast.###x_add look_up_view_def_raw 53 prog.Iast.prog_view_decls derv.Iast.view_name in
dp.ml:let ###x_add is_sat f sat_no = 
dp.ml:let ###x_add is_sat f sn = Gen.Profiling.do_2 "dpsat" Smtsolver.is_sat f sn
dp.ml:let ###x_add simplify f = (* Omega.simplify *) !Cpure.simplify f
drawing.ml:      let vdef = Cast.###x_add look_up_view_def no_pos prog.Cast.prog_view_decls c in
drawing.ml:	  let vdef = Cast.###x_add look_up_view_def no_pos prog.Cast.prog_view_decls c in
excore.ml:(*  let simp = Omega.###x_add simplify 2 in  *)
excore.ml:  let simp = (* Omega.###x_add simplify *) !simplify_raw in
excore.ml:(* let is_null_const_exp_for_e###x_add xpure (e : exp) : bool = *)
excore.ml:let rec remove_redundant_helper_for_e###x_add xpure ls rs =
excore.ml:        remove_redundant_helper_for_e###x_add xpure fs rs
excore.ml:        remove_redundant_helper_for_e###x_add xpure fs rs@[f]
excore.ml:(*           | BForm ((Eq(e1, e2, _), _) ,_) -> if (eq_exp_no_aset e1 e2) (\* || (is_null_const_exp_for_e###x_add xpure e1 && is_null_const_exp_for_expure e2) *\) then *)
excore.ml:(*                 remove_redundant_helper_for_e###x_add xpure fs rs *)
excore.ml:(*               else remove_redundant_helper_for_e###x_add xpure fs rs@[f] *)
excore.ml:(*           | BForm ((Lte(IConst (0,_), IConst (0,_), _), _) ,_) -> remove_redundant_helper_for_e###x_add xpure fs rs *)
excore.ml:(*           | _ -> remove_redundant_helper_for_e###x_add xpure fs rs@[f] *)
excore.ml:let remove_redundant_for_e###x_add xpure (f:formula):formula =
excore.ml:  let prun_l = remove_redundant_helper_for_e###x_add xpure l_conj [] in
excore.ml: (*  (\* Omega.###x_add simplify f *\) *)
excore.ml:  let pure = simplify_with_label_omega (* Omega.###x_add simplify *) pure in
excore.ml:  let new_pure = remove_redundant_for_e###x_add xpure (elim_clause pure1 svl) in
excore.ml:  let pf_base = Omega.###x_add simplify pf in
excore.ml:  let pf_fix = Omega.###x_add simplify (mkOr pf_base pf_indu None no_pos) in
excore.ml:  let pf1 = calc_fix_pure svl1 (###x_add filter_var pf svl1) in
excore.ml:  let (baga, pf2) = ef_elim_exists_1 svl2 (baga, (###x_add filter_var pf svl2)) in
expure.ml:let ###x_add simplify lst =
expure.ml:  ###x_add simplify disj_n
fixbag.ml:      DD.info_pprint ">>>>>> ###x_add compute_fixpoint <<<<<<" no_pos;
fixbag.ml:(*let ###x_add compute_fixpoint input_pairs =
fixbag.ml:    x_dinfo_pp ">>>>>> ###x_add compute_fixpoint <<<<<<" no_pos;
fixbag.ml:let rec ###x_add simplify flist = match flist with
fixbag.ml:    if can_merge = [] then hd::(###x_add simplify tl)
fixbag.ml:      hd::(###x_add simplify (snd (List.split others)))
fixbag.ml:let rec ###x_add filter_var f vars = 
fixbag.ml:  | CP.Or (f1,f2,l,p) -> CP.mkOr (###x_add filter_var f1 vars) (filter_var f2 vars) l p
fixbag.ml:  | _ -> CP.###x_add filter_var (CP.drop_rel_formula f) vars
fixbag.ml:  let rcase = ###x_add filter_var rcase all_rel_vars in
fixbag.ml:    let rcase = ###x_add filter_var rcase all_rel_vars in
fixbag.ml:    let bcases = ###x_add simplify bcases in
fixbag.ml:    let rcases = ###x_add simplify rcases in
fixbag.ml:      x_dinfo_pp ">>>>>> ###x_add compute_fixpoint <<<<<<" no_pos;
fixbag.ml:let ###x_add compute_fixpoint input_pairs ante_vars is_rec =
fixbag.ml:let ###x_add compute_fixpoint (i:int) input_pairs pre_vars is_rec =
fixbag.ml:      (fun _ _ -> ###x_add compute_fixpoint input_pairs pre_vars is_rec) input_pairs pre_vars
fixcalc.ml:  DD.ninfo_pprint ">>>>>> ###x_add compute_fixpoint <<<<<<" no_pos;
fixcalc.ml:  else Fixbag.###x_add compute_fixpoint 1 input_pairs_bag ante_vars true
fixcalc.ml:        let pf = Omega.###x_add simplify pf in
fixcalc.ml:                    let pf5 = Omega.###x_add simplify (CP.mkOr pf2 pf4 None no_pos) in
fixcalc.ml:let ###x_add compute_fixpoint (i:int) input_pairs ante_vars specs =
fixcalc.ml:let ###x_add compute_fixpoint_td (i:int) input_pairs ante_vars specs =
fixpoint.ml:  CP.###x_add filter_var inv sel_vars
fixpoint.ml:            let p = TP.###x_add simplify (CP.mkExists post_vars p None no_pos) in
fixpoint.ml:        let xpure_base,_,_ = Cvutil.###x_add xpure 16 prog b.CF.formula_struc_base in
fixpoint.ml:          simplify_pre (CF.###x_add normalize 1 b.CF.formula_struc_base (CF.formula_of_pure_formula pre no_pos) no_pos) lst_assume
fixpoint.ml:    let pre_rec = TP.###x_add simplify fml in
fixpoint.ml:    let final_pre1 = TP.###x_add simplify final_pre0 in
fixpoint.ml:      let pre = TP.###x_add simplify pre in
fixpoint.ml:(*          (###x_add imply_mix_formula 3 f1 f1 f2 imp_no {mem_formula_mset = []}) in*)
fixpoint.ml:          let _,_,l = Infer.###x_add infer_pure_m 3 [] es lhs_heap_xpure1 f1 f1 f1 f2 no_pos in
fixpoint.ml:  let bottom_up_fp = Fixcalc.###x_add compute_fixpoint 3 post_rel_df_new pre_vars proc_spec in
fixpoint.ml:      Fixcalc.###x_add compute_fixpoint_td Fixcalc.fixc_preprocess
frac.ml:(* need to ###x_add normalize *)
frame.ml:(*###x_add xpure base cases for one predicate*)
frame.ml:(*###x_add xpure base cases for list of predicates*)
globals.ml:let force_verbose_###x_add xpure = ref false
globals.ml:let no_float_simpl = ref true (*do not ###x_add simplify fractional constraints to avoid losing precision, such as 1/3 *)
globals.ml:let dis_base_case_###x_add unfold = ref false
globals.ml:let enable_lemma_rhs_###x_add unfold = ref false
globals.ml:let enable_lemma_lhs_###x_add unfold = ref false
globals.ml:let allow_lemma_deep_###x_add unfold = ref true
globals.ml:let lemma_gen_safe = ref false       (* generating (and proving) both fold and ###x_add unfold lemmas for special predicates *)
globals.ml:let lemma_gen_unsafe = ref false     (* generating (without proving) both fold and ###x_add unfold lemmas for special predicates *)
globals.ml:let smart_###x_add xpure = ref true
globals.ml:let super_smart_###x_add xpure = ref false
globals.ml:let precise_perm_###x_add xpure = ref true
globals.ml:     smart_###x_add xpure and xpure0!=xpure1 *)
globals.ml:let oc_###x_add simplify = ref true
globals.ml:let oc_adv_###x_add simplify = ref true
globals.ml:let simplified_case_###x_add normalize = ref true
globals.ml:let n_###x_add xpure = ref 1
globals.ml:let baga_###x_add xpure = ref true (* change to true later *)
globals.ml:  let () = oc_###x_add simplify := true in
globals.ml:  let () = oc_###x_add simplify := false in
gUtil.ml:        Some (SE.run_###x_add simplify f)
hgraph.ml:      (*do not need ###x_add unfold rhs*)
hgraph.ml:        let valid_rhs_###x_add unfold = check_valid_unfold_rhs sedge path in
hgraph.ml:        let () = Debug.ninfo_hprint (add_str " valid_rhs_unfold" string_of_bool) valid_rhs_###x_add unfold no_pos in
hgraph.ml:        if not valid_rhs_###x_add unfold then (valid_rhs_unfold, path) else
iast.ml:and exp_###x_add unfold = { exp_unfold_var : (string * primed);
iast.ml:and ###x_add look_up_view_def_raw i (defs : view_decl list) (name : ident) 
iast.ml:                  let orig_vdecl = ###x_add look_up_view_def_raw 52 iprog.prog_view_decls orig_view_name in
iast.ml:			  let vdef = ###x_add look_up_view_def_raw 1 view_decls c in
iast.ml:	let vd = ###x_add look_up_view_def_raw 15 prog.prog_view_decls vn in
iast.ml:    let vd = ###x_add look_up_view_def_raw 18 prog.prog_view_decls vn in
iincr.ml:  let vdcls = List.map (Cast.###x_add look_up_view_def_raw 65 prog.Cast.prog_view_decls) vns1 in
iincr.ml:  let pure_extn_view = Cast.###x_add look_up_view_def_raw 65 prog.Cast.prog_view_decls ext_pred_name in
immutable.ml:(*           let new_h, ###x_add xpure =  *)
immutable.ml:  (* TODO: ###x_add normalize the unused ann consts  *)
immutable.ml:let norm_abs_node h p ###x_add xpure =
immutable.ml:    let xpured, _, _ = x_add ###x_add xpure h p 0 in (* 0 or 1? *)(* !!!! add the xpure to pure *)
immutable.ml:let merge_alias_nodes_h_formula_helper prog p lst emap quantif ###x_add xpure unfold_fun qvars =
immutable.ml:      (* | [h]  -> let new_h, pure = norm_abs_node h p ###x_add xpure in  *)
immutable.ml:let merge_alias_nodes_h_formula prog f p emap quantif ###x_add xpure unfold_fun qvars = (* f *)
immutable.ml:          let node_lst, eqs, subs, fixpoint, struc = merge_alias_nodes_h_formula_helper prog p node_lst emap quantif ###x_add xpure unfold_fun qvars in
immutable.ml:              (* | DataNode _ | ViewNode _ -> norm_abs_node f p ###x_add xpure *) (* andreeac: uncommnet this line if you wnat to replace @A node with HEmp & xpure*)
immutable.ml:let merge_alias_nodes_h_formula prog f p emap quantif ###x_add xpure unfold_fun qvars = 
immutable.ml:  Debug.no_2 "merge_alias_nodes_h_formula"  pr1 pr2 (pr_quad (add_str "heap" pr1) (add_str "pure" pr2) string_of_bool pr_none) (fun _ _ -> merge_alias_nodes_h_formula prog f p emap quantif ###x_add xpure unfold_fun qvars) f p
immutable.ml:let merge_alias_nodes_formula_helper prog heapf puref quantif ###x_add xpure unfold_fun qvars =
immutable.ml:    let new_f, new_p, fixpoint, struc = merge_alias_nodes_h_formula prog heapf puref emap quantif ###x_add xpure unfold_fun qvars in
immutable.ml:let merge_and_combine prog f heap pure quantif ###x_add xpure unfold_fun qvars mk_new_f rec_fun =
immutable.ml:  let new_f, new_p, unfold_f_lst = merge_alias_nodes_formula_helper prog heap pure quantif ###x_add xpure (unfold_fun fl) qvars in
immutable.ml:let merge_alias_nodes_formula prog f quantif ###x_add xpure unfold_fun =
immutable.ml:            merge_and_combine prog f bf.formula_base_heap bf.formula_base_pure quantif ###x_add xpure unfold_fun [] mk_base helper
immutable.ml:            merge_and_combine prog f ef.formula_exists_heap ef.formula_exists_pure quantif ###x_add xpure unfold_fun qvars mk_exists helper
immutable.ml:let merge_alias_nodes_formula prog f quantif ###x_add xpure unfold_fun =
immutable.ml:  Debug.no_1 "merge_alias_nodes_formula" pr pr (fun _ -> merge_alias_nodes_formula prog f quantif ###x_add xpure unfold_fun) f
immutable.ml:let rec merge_alias_nodes_struc_formula prog f ###x_add xpure conseq unfold_fun =
immutable.ml:                formula_struc_base =  merge_alias_nodes_formula prog f.formula_struc_base quantif ###x_add xpure unfold_fun}
immutable.ml:      | EList l   -> EList  (map_l_snd (fun c-> merge_alias_nodes_struc_formula prog c ###x_add xpure conseq unfold_fun) l)
immutable.ml:      | ECase f   -> ECase {f with formula_case_branches = map_l_snd (fun c-> merge_alias_nodes_struc_formula prog c ###x_add xpure conseq unfold_fun) f.formula_case_branches;}
immutable.ml:	    formula_assume_simpl = merge_alias_nodes_formula prog f.formula_assume_simpl [] ###x_add xpure unfold_fun;
immutable.ml:	    formula_assume_struc = merge_alias_nodes_struc_formula prog f.formula_assume_struc ###x_add xpure conseq unfold_fun;}
immutable.ml:      | EInfer f  -> EInfer {f with formula_inf_continuation = merge_alias_nodes_struc_formula prog f.formula_inf_continuation ###x_add xpure conseq unfold_fun }
immutable.ml:let merge_alias_nodes_struc_formula prog f ###x_add xpure conseq  unfold_fun =
immutable.ml:  Debug.no_1 "merge_alias_nodes_struc_formula" pr pr (fun _ -> merge_alias_nodes_struc_formula prog f ###x_add xpure conseq  unfold_fun) f
infer.ml:let rec ###x_add filter_var f vars = 
infer.ml:          CP.Or (###x_add filter_var f1 vars, filter_var f2 vars, l, p)
infer.ml:                  then CP.###x_add filter_var f vars 
infer.ml:let ###x_add filter_var caller f vars =
infer.ml:  Debug.no_2_num caller "i.filter_var" pr !print_svl pr ###x_add filter_var f vars 
infer.ml:(* TODO : this ###x_add simplify could be improved *)
infer.ml:let ###x_add simplify f vars = TP.simplify_raw (###x_add filter_var 1 (TP.simplify_raw f) vars)
infer.ml:let ###x_add simplify_contra f vars = ###x_add filter_var 2 f vars
infer.ml:let ###x_add simplify f vars =
infer.ml:  Debug.no_2 "i.simplify" pr !print_svl pr ###x_add simplify f vars 
infer.ml:let ###x_add simplify_contra caller f vars =
infer.ml:  Debug.no_2_num caller "i.simplify_contra" pr !print_svl pr ###x_add simplify_contra f vars 
infer.ml:let ###x_add infer_lhs_contra pre_thus lhs_###x_add xpure ivars pos msg =
infer.ml:    (*  let lhs_xpure_orig = MCP.pure_of_mix lhs_###x_add xpure in*)
infer.ml:    (*  let lhs_###x_add xpure = CP.drop_rel_formula lhs_xpure_orig in*)
infer.ml:    (*  let check_sat = TP.is_sat_raw lhs_###x_add xpure in*)
infer.ml:    let lhs_xpure_orig = lhs_###x_add xpure in
infer.ml:    let lhs_###x_add xpure = MCP.mix_drop_rel lhs_xpure_orig in
infer.ml:    let check_sat = TP.is_sat_raw lhs_###x_add xpure in
infer.ml:      let f = ###x_add simplify_contra 1 (MCP.pure_of_mix lhs_xpure) ivars in
infer.ml:            x_dinfo_pp ">>>>>> ###x_add infer_lhs_contra <<<<<<" pos; 
infer.ml:let ###x_add infer_lhs_contra i pre_thus f ivars pos msg =
infer.ml:      (fun _ _ _ -> ###x_add infer_lhs_contra pre_thus f ivars pos msg) f ivars msg
infer.ml:let ###x_add infer_lhs_contra_estate estate lhs_###x_add xpure pos msg =
infer.ml:    let lhs_pure = MCP.pure_of_mix lhs_###x_add xpure in
infer.ml:      let r = ###x_add infer_lhs_contra 1 p_thus lhs_###x_add xpure ivars pos msg in
infer.ml:                        x_dinfo_pp ">>>>>> ###x_add infer_lhs_contra_estate <<<<<<" pos;
infer.ml:              let rel_ass = ###x_add infer_lhs_contra 2 p_thus lhs_###x_add xpure vs_lhs pos "relational assumption" in
infer.ml:let ###x_add infer_lhs_contra_estate i estate lhs_###x_add xpure pos msg =
infer.ml:      (add_str "lhs_xpure" pr1) pr_id pr_res (fun _ _ _ -> ###x_add infer_lhs_contra_estate estate lhs_###x_add xpure pos msg) estate lhs_xpure msg
infer.ml:(*     let check_sat = Omega.###x_add is_sat fml "0" in *)
infer.ml:(*       let f = ###x_add simplify lhs_simp ivars in *)
infer.ml:(* let infer_lhs_rhs_pure_es estate lhs_###x_add xpure rhs_xpure pos = *)
infer.ml:(*     let lhs_###x_add xpure = MCP.pure_of_mix lhs_xpure in *)
infer.ml:(*     let rhs_###x_add xpure = MCP.pure_of_mix rhs_xpure in *)
infer.ml:(*     let lhs_simp = ###x_add simplify lhs_###x_add xpure ivars in *)
infer.ml:(*     let rhs_simp = ###x_add simplify rhs_###x_add xpure ivars in *)
infer.ml:(*                   es_formula = ###x_add normalize 0 estate.es_formula (CF.formula_of_pure_formula pf pos) pos; *)
infer.ml:let detect_lhs_rhs_contra_x (*lhs_xpure*) lhs_xpure_orig rhs_###x_add xpure pos =
infer.ml:  (* let lhs_###x_add xpure = MCP.pure_of_mix lhs_xpure_orig in *)
infer.ml:  (* let rhs_vars = CP.fv rhs_###x_add xpure in *)
infer.ml:  (* let lhs_###x_add xpure = CP.filter_ante lhs_xpure rhs_xpure in *)
infer.ml:  (* let rhs_###x_add xpure = MCP.pure_of_mix rhs_xpure_orig in  *)
infer.ml:  (* let lhs_###x_add xpure = MCP.pure_of_mix lhs_xpure0 in  *)
infer.ml:  let split_rhs = CP.split_conjunctions rhs_###x_add xpure in
infer.ml:  let rhs_###x_add xpure = CP.join_conjunctions rem_rhs in
infer.ml:      (*let () = x_tinfo_hp (add_str "lhs_xpure: " (!CP.print_formula)) lhs_###x_add xpure pos in*)
infer.ml:      let () = x_tinfo_hp (add_str "rhs(orig): " !CP.print_formula) rhs_###x_add xpure pos in
infer.ml:  let lhs_###x_add xpure = CP.filter_ante lhs_xpure_orig rhs_xpure in
infer.ml:      let () = x_tinfo_hp (add_str "lhs (after filter_ante): " !CP.print_formula) lhs_###x_add xpure pos in
infer.ml:  let fml = CP.mkAnd lhs_###x_add xpure rhs_xpure pos in
infer.ml:      let p, rel_ass = ###x_add infer_lhs_contra_estate 1 estate lhs_xpure0 pos "rhs contradiction" in
infer.ml:      let lhs_###x_add xpure = MCP.pure_of_mix lhs_xpure0 in
infer.ml:      let rhs_###x_add xpure = MCP.pure_of_mix rhs_xpure_orig in
infer.ml:      let split_rhs = CP.split_conjunctions rhs_###x_add xpure in
infer.ml:      let rem_rhs = List.filter (fun c -> not(TP.imply_raw lhs_###x_add xpure c)) split_rhs in
infer.ml:      let rhs_###x_add xpure = CP.join_conjunctions rem_rhs in
infer.ml:          let () = DD.ninfo_hprint (add_str "lhs_xpure: " (!CP.print_formula)) lhs_###x_add xpure pos in
infer.ml:          (* let lhs_###x_add xpure = pure_of_heap_pred /\ lhs_xpure in *)
infer.ml:          (* let lhs_###x_add xpure = pure_name_of_heap_pred unk_heaps *)
infer.ml:          let lhs_xpure1 = CP.mkAnd lhs_###x_add xpure pure_hps pos in
infer.ml:      let () = x_tinfo_hp (add_str "rhs(orig): " !CP.print_formula) rhs_###x_add xpure pos in
infer.ml:      let () = DD.ninfo_hprint (add_str "rhs_xpure" !CP.print_formula) rhs_###x_add xpure pos in
infer.ml:      (* let lhs_xpure01 = CP.filter_ante lhs_xpure_orig rhs_###x_add xpure in *)
infer.ml:      let lhs_###x_add xpure = (* if !Globals.en_slc_ps && CP.isConstTrue lhs_xpure01 then *)
infer.ml:        (*   CP.###x_add filter_var lhs_###x_add xpure (CP.remove_dups_svl ((CP.fv rhs_xpure)@iv)) *)
infer.ml:      let () = DD.ninfo_hprint (add_str "lhs 2: " !CP.print_formula) lhs_###x_add xpure pos in
infer.ml:      let fml = CP.mkAnd lhs_###x_add xpure rhs_xpure pos in
infer.ml:      (* let check_sat,fml = detect_lhs_rhs_contra (\*lhs_xpure*\) lhs_xpure_orig rhs_###x_add xpure pos in *)
infer.ml:        (* let () = x_tinfo_hp (add_str "rhs: " !CP.print_formula) rhs_###x_add xpure pos in *)
infer.ml:        (* let lhs_xpure0 = CP.filter_ante lhs_xpure0 rhs_###x_add xpure in *)
infer.ml:        let p, rel_ass = ###x_add infer_lhs_contra_estate 2 estate lhs_xpure0 pos "ante contradict with conseq" in
infer.ml:        (*      let new_p = ###x_add simplify fml iv in                            *)
infer.ml:        (*      let new_p = ###x_add simplify (CP.mkAnd new_p invariants pos) iv in*)
infer.ml:        let vars_rhs = fv (CP.remove_ptr_equations rhs_###x_add xpure false) in (* var on lhs *)
infer.ml:            let new_p = ###x_add simplify new_p iv in 
infer.ml:            let () = x_tinfo_hp (add_str "lhs_###x_add xpure (b4 drop): " !CP.print_formula) lhs_xpure pos  in
infer.ml:            let lhs_###x_add xpure = CP.drop_rel_formula lhs_xpure in
infer.ml:            let () = x_tinfo_hp (add_str "lhs_xpure: " !CP.print_formula) lhs_###x_add xpure pos  in
infer.ml:            let vrs1 = CP.fv lhs_###x_add xpure in
infer.ml:            let vrs2 = CP.fv rhs_###x_add xpure in
infer.ml:            let lhs_xpure_ann = Cpure.add_ann_constraints imm_vrs lhs_###x_add xpure in
infer.ml:            (*     (CP.mkOr (CP.mkNot_s lhs_xpure_ann) rhs_###x_add xpure None pos) None pos) in *)
infer.ml:            let () = x_tinfo_hp (add_str "rhs_xpure: " !CP.print_formula) rhs_###x_add xpure pos  in
infer.ml:          (*   let new_p = ###x_add simplify new_p iv in *)
infer.ml:          (*   (\*let new_p = ###x_add simplify (CP.mkAnd new_p invariants pos) iv in*\) *)
infer.ml:          ###x_add simplify new_p iv
infer.ml:                (CP.mkAnd lhs_###x_add xpure new_p_ass no_pos))) && (CP.isConstFalse new_p) in
infer.ml:                x_dinfo_pp ">>>>>> ###x_add infer_pure_m <<<<<<" pos;
infer.ml:                x_dinfo_hp (add_str "LHS : " !CP.print_formula) lhs_###x_add xpure pos;               
infer.ml:                x_dinfo_hp (add_str "RHS : " !CP.print_formula) rhs_###x_add xpure pos;
infer.ml:                          DD.info_pprint ">>>>>> ###x_add infer_pure_m <<<<<<" pos;
infer.ml:                          DD.ninfo_hprint (add_str "lhs_xpure" (!CP.print_formula)) lhs_###x_add xpure pos;
infer.ml:                          DD.info_hprint (add_str "rhs_xpure" (!CP.print_formula)) rhs_###x_add xpure pos;
infer.ml:                          let vs = CP.fv rhs_###x_add xpure in
infer.ml:                            let rhs = CF.formula_of_pure_formula rhs_###x_add xpure pos in
infer.ml:                      x_dinfo_pp ">>>>>> ###x_add infer_pure_m <<<<<<" pos;
infer.ml:                      (*(*                let lhs_###x_add xpure = CP.drop_rel_formula lhs_xpure in*)*)
infer.ml:                      (*                      (MCP.mix_of_pure (TP.simplify_raw (CP.mkAnd lhs_###x_add xpure n_rhs pos)))*)
infer.ml:                      let (ip1,ip2,rs) = ###x_add infer_pure_m unk_heaps estate  lhs_heap_xpure1 None 
infer.ml:                                        let lhs_xpure_new = CP.drop_rel_formula lhs_###x_add xpure in
infer.ml:                                          (*                          let lhs_xpure_new = CP.drop_rel_formula lhs_###x_add xpure in*)
infer.ml:                            let pf1 = (CP.mkAnd lhs_###x_add xpure pf0 pos) in
infer.ml:                                  let pf2 = TP.###x_add simplify_with_pairwise 2 pf1 in
infer.ml:                                                  let p = CP.###x_add filter_var (MCP.pure_of_mix b.formula_base_pure) ptrs in
infer.ml:                            let () = x_tinfo_hp (add_str "LHS : " !CP.print_formula) lhs_###x_add xpure pos in           
infer.ml:                                            let p21a =  CP.###x_add filter_var p2 h_svl  in
infer.ml:                          (*                  x_dinfo_pp ">>>>>> ###x_add infer_pure_m <<<<<<" pos;*)
infer.ml:                          (*                  let n_rhs = rhs_###x_add xpure in*)
infer.ml:                          (*                  let n_lhs = lhs_###x_add xpure in*)
infer.ml:                          (*                  let n_lhs3 = ###x_add filter_var n_lhs2 vs_lhs in*)
infer.ml:          let lhs_orig_list = CP.split_conjunctions lhs_###x_add xpure in
infer.ml:              x_dinfo_pp ">>>>>> ###x_add infer_pure_m <<<<<<" pos;
infer.ml:            (* let new_p_good = CP.filter_ante new_p rhs_###x_add xpure in *)
infer.ml:              (* let lhs_fil = CP.filter_ante lhs_###x_add xpure rhs_xpure in *)
infer.ml:              (* let lhs_simps = CP.simplify_filter_ante TP.simplify_always lhs_###x_add xpure rhs_xpure in *)
infer.ml:              (* x_dinfo_pp ">>>>>> ###x_add infer_pure_m <<<<<<" pos; *)
infer.ml:              (* x_dinfo_hp (add_str "LHS" !CP.print_formula) lhs_###x_add xpure pos;                *)
infer.ml:              (* x_dinfo_hp (add_str "RHS" !CP.print_formula) rhs_###x_add xpure pos; *)
infer.ml:                (* And ###x_add simplify the pure in the residue *)
infer.ml:                (*           let new_es_formula = ###x_add normalize 0 estate.es_formula (CF.formula_of_pure_formula new_p pos) pos in *)
infer.ml:                (* (\*          let new_es_formula = Cformula.mkBase h (MCP.mix_of_pure (Omega.###x_add simplify (MCP.pure_of_mix p))) t fl b pos in*\) *)
infer.ml:                (*   (###x_add infer_lhs_contra_estate estate lhs_xpure_orig pos "ante contradict with conseq",None) *)
infer.ml:                (*       let check_sat = TP.is_sat_raw lhs_###x_add xpure in *)
infer.ml:                (*         let lhs_simplified = ###x_add simplify lhs_###x_add xpure iv in *)
infer.ml:                (*         (\*let new_p = ###x_add simplify_contra (CP.mkAnd (CP.mkNot_s lhs_simplified) invariants pos) iv in*\) *)
infer.ml:                (*         let new_p = ###x_add simplify_contra (CP.mkNot_s lhs_simplified) iv in *)
infer.ml:and ###x_add infer_pure_m unk_heaps estate  lhs_heap_xpure1 lhs_rels lhs_xpure_orig lhs_xpure0 lhs_wo_heap_orig rhs_xpure_orig iv_orig pos =
infer.ml:      (add_str "lhs ###x_add xpure " pr_p)
infer.ml:      (add_str "rhs ###x_add xpure " pr1)
infer.ml:let ###x_add infer_pure_m unk_heaps estate  lhs_heap_xpure1 lhs_rels lhs_xpure_orig lhs_xpure0 lhs_wo_heap_orig rhs_xpure_orig iv_orig pos =
infer.ml:  let (nes,nc,nlst) = ###x_add infer_pure_m  unk_heaps estate  lhs_heap_xpure1 lhs_rels lhs_xpure_orig lhs_xpure0 lhs_wo_heap_orig rhs_xpure_orig iv_orig pos in
infer.ml:let ###x_add infer_pure_m unk_heaps estate  lhs_heap_xpure1 lhs_mix lhs_mix_0 lhs_wo_heap rhs_mix pos =
infer.ml:    ###x_add infer_pure_m unk_heaps estate  lhs_heap_xpure1 lhs_rels xp lhs_mix_0 lhs_wo_heap rhs_mix infer_vars pos
infer.ml:let ###x_add infer_pure_m i unk_heaps estate  lhs_heap_xpure1 lhs_###x_add xpure lhs_xpure0 lhs_wo_heap rhs_xpure pos =
infer.ml:      (add_str "lhs ###x_add xpure " pr1) 
infer.ml:      (add_str "rhs ###x_add xpure " pr1)
infer.ml:      (fun _ _ _ _ -> ###x_add infer_pure_m unk_heaps estate  lhs_heap_xpure1 lhs_###x_add xpure lhs_xpure0 lhs_wo_heap rhs_xpure pos) 
infer.ml:      estate lhs_###x_add xpure lhs_xpure0 rhs_xpure
infer.ml:  let r1,r2,r3 = ###x_add infer_pure_m 1 unk_heaps estate lhs_heap_xpure1 ante1 ante0 m_lhs (*m_lhs=lhs_wo_heap*) split_conseq pos in
infer.ml:    (* TODO: ###x_add filter_var with relations *)
infer.ml:    (*    let split1 = CP.###x_add filter_var ante0_pure all_inf_vars in*)
infer.ml:          let r1,r2,r3 = ###x_add infer_pure_m 2 unk_heaps estate lhs_heap_xpure1 lhs_xp lhs_xp lhs_wo_heap split_conseq pos in
infer.ml:(* requires ###x_add simplify and should preserve relation and != *)
infer.ml:let rel_filter_assumption ###x_add is_sat lhs rel =
infer.ml:  let (lhs,rel) = CP.assumption_filter_aggressive ###x_add is_sat lhs rel in
infer.ml:let infer_collect_rel ###x_add is_sat estate conseq_flow lhs_h_mix lhs_mix rhs_mix pos =
infer.ml:        let p, rel_ass = ###x_add infer_lhs_contra_estate 3 estate lhs_mix pos "infer_collect_rel: ante contradict with conseq" in
infer.ml:        let ###x_add is_sat = if is_bag_cnt then (fun x -> true) else is_sat in
infer.ml:        let (lhs,rhs) = rel_filter_assumption ###x_add is_sat lhs rhs in
infer.ml:            (1) ###x_add simplify LHS to:
infer.ml:let infer_collect_rel ###x_add is_sat estate conseq_flow lhs_h_mix lhs_mix rhs_mix pos =
infer.ml:            infer_collect_rel ###x_add is_sat estate conseq_flow lhs_h_mix lhs_mix rhs_mix pos) 
infer.ml:  let unk_###x_add xpure = CP.mkTrue pos in
infer.ml:  (*two cases: rhs ###x_add unfold (mis-match is a node) and lhs fold (mis-match is a unk hp)*)
infer.ml:        let p = CP.###x_add filter_var (MCP.pure_of_mix lfb.CF.formula_base_pure) args in
infer.ml:    let old_baga_flag = !baga_###x_add xpure in
infer.ml:    let () = baga_###x_add xpure := true in
infer.ml:    let () = baga_###x_add xpure := old_baga_flag in
infer.ml:      let () = baga_###x_add xpure := true in
infer.ml:      let lhs_p,_,_=(x_add Cvutil.###x_add xpure_symbolic 10 prog es.es_formula) in
infer.ml:      let () = baga_###x_add xpure := old_baga_flag in
infer.ml:            let g_pure = CP.###x_add filter_var p g_svl in
infer.ml:            let g_pure_orig = CP.###x_add filter_var p_orig g_svl in
infer.ml:              let g_pure = CP.###x_add filter_var p g_svl in
infer.ml:              let g_pure_orig = CP.###x_add filter_var p_orig g_svl in
infer.ml:  let defined_hprels = List.map (Sautil.###x_add generate_hp_ass 0 [](* (closed_hprel_args_def@total_unk_svl) *) es_cond_path) defined_hps in
infer.ml:    (*if rhs_rest = Emp && . remove infer svl such that ###x_add infer_pure_m is not invoked*)
infer.ml:let ###x_add infer_collect_hp_rel i prog (es:entail_state) rhs rhs_rest (rhs_h_matched_set:CP.spec_var list) lhs_b rhs_b pos =
infer.ml:let ###x_add infer_collect_hp_rel_empty_rhs i prog (es:entail_state) rhs_p pos =
infer.ml:        let p = CP.###x_add filter_var (MCP.pure_of_mix lfb.CF.formula_base_pure) args in
infer.ml:        let defined_hprels = List.map (Sautil.###x_add generate_hp_ass 1 [] es_cond_path) defined_preds0 in
infer.ml:let ###x_add infer_collect_hp_rel_classsic i prog (es:entail_state) rhs pos =
infer.ml:(*     let rec ###x_add filter_var f vars = match f with *)
infer.ml:(*       | CP.Or (f1,f2,l,p) -> CP.Or (###x_add filter_var f1 vars, filter_var f2 vars, l, p) *)
infer.ml:(*       | _ -> CP.###x_add filter_var f vars *)
infer.ml:(*     let infer_pure = Omega.###x_add simplify (###x_add filter_var infer_pure estate.es_infer_vars) in *)
infer.ml:(*     let pure_part2 = Omega.###x_add simplify (List.fold_left (fun p1 p2 -> CP.mkAnd p1 p2 pos) (CP.mkTrue pos) *)
infer.ml:(*     let infer_pure = if Omega.###x_add is_sat pure_part2 "0" = false then [CP.mkFalse pos] else [infer_pure] in *)
infer.ml:(*let infer_empty_rhs2 estate lhs_###x_add xpure rhs_p pos =*)
infer.ml:(* let infer_empty_rhs2_old estate lhs_###x_add xpure rhs_p pos = *)
infer.ml:(*     (\* let lhs_xpure,_,_,_ = x_add ###x_add xpure prog estate.es_formula in *\) *)
infer.ml:(*     let pure_part_aux = Omega.###x_add is_sat (CP.mkAnd (MCP.pure_of_mix lhs_xpure) (MCP.pure_of_mix rhs_p) pos) "0" in *)
infer.ml:(*       | _ -> CP.###x_add filter_var f vars *)
infer.ml:(*     let ###x_add filter_var f vars =  *)
infer.ml:(*       if CP.isConstTrue (Omega.###x_add simplify f) then CP.mkTrue pos  *)
infer.ml:(*         if CP.isConstTrue (Omega.###x_add simplify res) then CP.mkFalse pos *)
infer.ml:(*         let lhs_pure = CP.mkAnd (mkNot(Omega.###x_add simplify  *)
infer.ml:(*             (###x_add filter_var (MCP.pure_of_mix lhs_xpure) estate.es_infer_vars))) invs pos in *)
infer.ml:(*       else Omega.###x_add simplify (CP.mkAnd (CP.mkAnd (MCP.pure_of_mix lhs_xpure) (MCP.pure_of_mix rhs_p) pos) invs pos) *)
infer.ml:(*     let pure_part = ###x_add filter_var (Omega.###x_add simplify pure_part) estate.es_infer_vars in *)
infer.ml:(*     let pure_part = Omega.###x_add simplify pure_part in *)
infer.ml:(*     let pure_part2 = Omega.###x_add simplify (CP.mkAnd pure_part  *)
infer.ml:(*       || Omega.###x_add is_sat pure_part2 "0" = false then [CP.mkFalse pos] else [pure_part] in *)
infer.ml:(*let infer_for_###x_add unfold prog estate lhs_node pos =
infer.ml:  let vdef = Cast.###x_add look_up_view_def pos prog.Cast.prog_view_decls c in
infer.ml:(*let infer_for_###x_add unfold prog estate lhs_node pos =
infer.ml:  (fun _ _ -> infer_for_###x_add unfold prog estate lhs_node pos) estate lhs_node*)
infer.ml:(*             let vdef = Cast.###x_add look_up_view_def pos prog.Cast.prog_view_decls c in *)
infinity.ml:(* ###x_add normalize 
infinity.ml:(* ###x_add normalize \inf <= const + var ~~> \inf <= var and so on *)
infinity.ml:                        (*arith_###x_add simplify 10*) new_pf) sublist in
infinity.ml:                        arith_###x_add simplify 10 new_pf) (List.combine after_sub negboundlist) in 
infinity.ml:  (*let f =  arith_###x_add simplify 101 f in*) 
infinity.ml:    let new_c = arith_###x_add simplify 11 new_c in
infinity.ml:  in let ante_norm = (*check if need to ###x_add normalize again*)(*if contains_inf_eq ante 
infinity.ml:    let l = List.map (fun pf -> arith_###x_add simplify 199 (mkAnd pf inner_f no_pos)) ins_lst in
infinity.ml:  List.map (fun pf -> arith_###x_add simplify 198 (mkAnd pf f no_pos)) ins_lst 
infinity.ml:  let ls = List.map (fun pf -> arith_###x_add simplify 200 (mkAnd pf f no_pos)) ins_lst 
infinity.ml:    let l = List.map (fun pf -> arith_###x_add simplify 199 (mkAnd pf inner_f no_pos)) ins_lst in
infinity.ml:    let l = List.map (fun pf -> arith_###x_add simplify 200 (mkAnd pf inner_f no_pos)) ins_lst in
infsolver.ml:  (** val ###x_add simplify : InfS.FA.coq_ZF -> InfS.FA.coq_ZF **)
infsolver.ml:  let rec ###x_add simplify = function
infsolver.ml:    (match judge (###x_add simplify f1) with
infsolver.ml:       (match judge (###x_add simplify f2) with
infsolver.ml:        | _ -> ###x_add simplify f2)
infsolver.ml:       (match judge (###x_add simplify f2) with
infsolver.ml:       (match judge (###x_add simplify f2) with
infsolver.ml:        | EQ_TRUE -> ###x_add simplify f1
infsolver.ml:        | OTHER -> InfS.FA.ZF_And ((###x_add simplify f1), (simplify f2))))
infsolver.ml:    (match judge (###x_add simplify f1) with
infsolver.ml:       (match judge (###x_add simplify f2) with
infsolver.ml:       (match judge (###x_add simplify f2) with
infsolver.ml:        | _ -> ###x_add simplify f2)
infsolver.ml:       (match judge (###x_add simplify f2) with
infsolver.ml:        | EQ_FALSE -> ###x_add simplify f1
infsolver.ml:        | OTHER -> InfS.FA.ZF_Or ((###x_add simplify f1), (simplify f2))))
infsolver.ml:    (match judge (###x_add simplify f1) with
infsolver.ml:       (match judge (###x_add simplify f2) with
infsolver.ml:        | _ -> ###x_add simplify f2)
infsolver.ml:       (match judge (###x_add simplify f2) with
infsolver.ml:       (match judge (###x_add simplify f2) with
infsolver.ml:        | EQ_FALSE -> InfS.FA.ZF_Not (###x_add simplify f1)
infsolver.ml:        | OTHER -> InfS.FA.ZF_Imp ((###x_add simplify f1), (simplify f2))))
infsolver.ml:    (match judge (###x_add simplify f) with
infsolver.ml:     | OTHER -> InfS.FA.ZF_Not (###x_add simplify f))
infsolver.ml:    (match judge (###x_add simplify f) with
infsolver.ml:     | OTHER -> InfS.FA.ZF_Forall (v, q, (###x_add simplify f)))
infsolver.ml:    (match judge (###x_add simplify f) with
infsolver.ml:     | OTHER -> InfS.FA.ZF_Exists (v, q, (###x_add simplify f)))
infsolver.ml:  (** val transform_ZE_to_string_###x_add simplify :
infsolver.ml:  let transform_ZE_to_string_###x_add simplify f =
infsolver.ml:    convert_FAZF_to_ZF (SIM.###x_add simplify (SIM.InfS.coq_T (convert_ZF_to_IAZF f)))
iprinter.ml:  | Unfold ({exp_unfold_var = (v, p)}) -> "###x_add unfold " ^ v
isabelle.ml:let ###x_add is_sat (f : CP.formula) (sat_no : string) : bool = begin
isabelle.ml:				output_string log_all ("\n\n####x_add is_sat " ^ sat_no ^ "\n");
isabelle.ml:	  output_string log_all ("[isabelle.ml]: ###x_add is_sat --> "^(string_of_bool (not answ)) ^"\n");
isabelle.ml:let ###x_add simplify (pe : CP.formula) : CP.formula = begin
label.ml:        | (ly,y)::ys1 -> comb_tgt (Lbl.###x_add ###x_add comb_norm 3 l ly) (Exp.comb x y) ys1
label_only.ml:      val ###x_add ###x_add comb_norm : int -> t -> t -> t (* combine two normalised labels *)
label_only.ml:  let ###x_add ###x_add comb_norm xs ys = 
label_only.ml:  let ###x_add ###x_add comb_norm i xs ys =
label_only.ml:    Debug.no_2_num i "comb_norm" string_of string_of string_of ###x_add ###x_add comb_norm xs ys 
label_only.ml:  let ###x_add ###x_add comb_norm xs ys = 
label_only.ml:  let ###x_add ###x_add comb_norm i xs ys =
label_only.ml:    Debug.no_2_num i "comb_norm" string_of string_of string_of ###x_add ###x_add comb_norm xs ys 
label_only.ml:  (* let ###x_add ###x_add comb_norm xs ys =  *)
label_only.ml:  let ###x_add ###x_add comb_norm (opt1,xs) (opt2,ys) =
label_only.ml:    (opt1,Lab_List.###x_add ###x_add comb_norm 4 xs ys)
label_only.ml:  let ###x_add ###x_add comb_norm i xs ys =
label_only.ml:    Debug.no_2_num i "comb_norm" string_of string_of string_of ###x_add ###x_add comb_norm xs ys 
lemma.ml:      Sleekcore.###x_add sleek_entail_check 4 [] [] cprog [(chead,cbody)] lhs (CF.struc_formula_of_formula rhs no_pos)
lemma.ml:    else Sleekcore.###x_add sleek_entail_check 5 [] [] cprog [(cbody,chead)] rhs (CF.struc_formula_of_formula lhs no_pos)
lemma.ml:            let res = Lemproving.###x_add verify_lemma 3 l2r r2l cprog name typ in 
lemma.ml:              let (flag,lc) = Lemproving.sa_###x_add verify_lemma cprog coer in 
lemma.ml:  let rel_fm = CP.###x_add filter_var (CF.get_pure bare) pre_rel_args in
lemma.ml:                              let rel_fm = CP.###x_add filter_var (CF.get_pure bare) pre_rel_args in
lemma.ml:              let vdcl = C.###x_add look_up_view_def_raw 40 cprog.C.prog_view_decls hv.CF.h_formula_view_name in
lemma.ml:          (*     (Sleekcore.###x_add sleek_entail_check 9 [] cprog [] new_induct_f) tmp_sf in                   *)
lemma.ml:      (* let p,_,_ = x_add Cvutil.###x_add xpure_symbolic 20 cprog new_f in *)
lemma.ml:      let p1 = CP.###x_add filter_var  p view_args in
lemproving.ml:              let nctx = CF.transform_context (Solver.###x_add elim_unsat_es 10 cprog (ref 1)) nctx in
lemproving.ml:  (* let ctx = CF.transform_list_context (Solver.###x_add elim_unsat_es 10 cprog (ref 1)) ctx in *)
lemproving.ml:   - ###x_add unfold lhs once
lemproving.ml:  let rhs = Solver.###x_add unfold_struc_nth 9 (cprog,None) rhs (CP.SpecVar (Globals.null_type, self, Unprimed)) true 0 pos in
lemproving.ml:  let is_iden_###x_add unfold lhs_unfold_ptr rhs_unfold_ptr lhs_vns rhs_vns=
lemproving.ml:  let lhs_unfold_ptrs0,rhs_unfold_ptrs0= if !Globals.enable_lemma_lhs_###x_add unfold ||
lemproving.ml:    !Globals.enable_lemma_rhs_###x_add unfold then ([],[]) else (* must re-check this -if- {**} *)
lemproving.ml:      (* rhs_unfold_ptrs below really needed? isn't lhs ###x_add unfold enough? *)
lemproving.ml:          if is_iden_###x_add unfold sv_self sv_self lhs_vns rhs_vns then
lemproving.ml:        else if !Globals.allow_lemma_deep_###x_add unfold then
lemproving.ml:    let lhs_unfold_ptrs = if !Globals.enable_lemma_lhs_###x_add unfold then
lemproving.ml:      if !Globals.allow_lemma_deep_###x_add unfold then
lemproving.ml:          (* let () = print_endline ("-- ###x_add unfold lsh on " ^ (Cprinter.string_of_spec_var sv)) in *)
lemproving.ml:    let rhs_unfold_ptrs = if !Globals.enable_lemma_rhs_###x_add unfold then
lemproving.ml:        if !Globals.allow_lemma_deep_###x_add unfold then
lemproving.ml:        Solver.###x_add unfold_struc_nth 9 (cprog,None) sf sv true 0 pos
lemproving.ml:let ###x_add verify_lemma (l2r: C.coercion_decl list) (r2l: C.coercion_decl list) (cprog: C.prog_decl)  lemma_name lemma_type =
lemproving.ml:let ###x_add verify_lemma (l2r: C.coercion_decl list) (r2l: C.coercion_decl list) (cprog: C.prog_decl)
lemproving.ml:  wrap_proving_kind PK_Verify_Lemma ((###x_add verify_lemma l2r r2l cprog coerc_name)) coerc_type
lemproving.ml:let ###x_add verify_lemma caller (l2r: C.coercion_decl list) (r2l: C.coercion_decl list) (cprog: C.prog_decl)  coerc_name coerc_type =
lemproving.ml:  Debug.no_4_num caller "verify_lemma" pr pr (fun x -> x) pr_t (Cprinter.string_of_list_context) (fun _ _ _ _ -> ###x_add verify_lemma l2r r2l cprog coerc_name coerc_type) l2r r2l coerc_name coerc_type
lemproving.ml:let sa_###x_add verify_lemma cprog (lem:C.coercion_decl) =
lemproving.ml:let sa_###x_add verify_lemma cprog (lem: C.coercion_decl) =
lemproving.ml:      (fun _ -> sa_###x_add verify_lemma cprog lem) lem
lemsyn.ml:  (* let vdef = C.###x_add look_up_view_def_raw 43 prog.C.prog_view_decls vnode.Cformula.h_formula_view_name in *)
lemutil.ml:  (*###x_add unfold lhs - rhs*)
lemutil.ml:    (* let fnc = wrap_proving_kind PK_SA_EQUIV (fun f1 f2 -> Sleekcore.###x_add sleek_entail_check [] cprog0 [(\* (f12,f22) *\)] f1 (Cformula.struc_formula_of_formula f2 no_pos)) in *)
lemutil.ml:    (* let r1,_,_ = Sleekcore.###x_add sleek_entail_check [] cprog0 [(\* (f12,f22) *\)] f13 (Cformula.struc_formula_of_formula f23 no_pos) in *)
lemutil.ml:      (* let r2,_,_ = Sleekcore.###x_add sleek_entail_check [] cprog0 [(\* (f22,f12) *\)] f23 (Cformula.struc_formula_of_formula f13 no_pos) in *)
main.ml:                (*     Solver.###x_add unfold_struc_nth 10 (cprog, None) sf fv false 0 no_pos *)
main.ml:                    (* Cprinter.string_of_struc_formula_for_spec new_sf *) (* (Solver.###x_add unfold_struc_nth 1 (cprog, None) sf (List.hd (List.tl fv)) (\* (Cpure.SpecVar (Globals.Named "node", "x", Unprimed)) *\) false 1 no_pos) *)
main.ml:                   let todo_unk = Cast.###x_add look_up_view_def_raw 33 old_cprog.Cast.prog_view_decls
mathematica.ml:let no_###x_add simplify = ref false
mathematica.ml:  let rec ###x_add simplify f0 vnames =
mathematica.ml:        let nf1 = ###x_add simplify f1 vnames in
mathematica.ml:        let nf1 = ###x_add simplify f1 vnames in
mathematica.ml:        let nf1 = ###x_add simplify f1 vnames in
mathematica.ml:        let nf2 = ###x_add simplify f2 vnames in
mathematica.ml:        let nf1 = ###x_add simplify f1 vnames in
mathematica.ml:        let nf2 = ###x_add simplify f2 vnames in
mathematica.ml:    | CP.Not (f1, lbl, l) -> CP.Not (###x_add simplify f1 vnames, lbl, l)
mathematica.ml:  ###x_add simplify e (Hashtbl.create 100)
mathematica.ml:    call_omega (lazy (Omega.###x_add is_sat f sat_no))
mathematica.ml:    let err_msg = "Timeout when checking ####x_add is_sat " ^ sat_no ^ "!" in
mathematica.ml:let ###x_add is_sat f sat_no =
mathematica.ml:let ###x_add simplify (f: CP.formula) : CP.formula =
mathematica.ml:  if is_linear_formula f then Omega.###x_add simplify f 
mcpure.ml:and memo_arith_###x_add simplify (f : memo_pure) : memo_pure = 
mcpure.ml:  List.map (fun c -> { c with memo_group_slice = List.map (arith_###x_add simplify 5) c.memo_group_slice }) f
mcpure.ml:   this avoids some ###x_add simplify calls.
mcpure.ml:      let c1 = b_form_###x_add simplify c1 in
mcpure.ml:    let c1 = b_form_###x_add simplify c1 in
mcpure.ml:let is_sat_memo_sub_no_complete f with_dupl with_inv t_###x_add is_sat =
mcpure.ml:  let ###x_add is_sat m = 
mcpure.ml:      t_###x_add is_sat merged_m
mcpure.ml:  else (not (List.exists (fun m -> not (###x_add is_sat m)) f))
mcpure.ml:let is_sat_memo_sub_no_ineq_slicing_complete (mem : memo_pure) with_dupl with_inv t_###x_add is_sat : bool =
mcpure.ml:        t_###x_add is_sat (fold_slice_gen mg with_dupl with_inv true true)
mcpure.ml:let is_sat_memo_sub_no_ineq_slicing_complete (mem : memo_pure) with_dupl with_inv t_###x_add is_sat : bool =
mcpure.ml:let rec ###x_add imply_memo ante_memo0 conseq_memo t_imply imp_no =
mcpure.ml:let ###x_add imply_memo ante_memo0 conseq_memo t_imply imp_no =
mcpure.ml:  ###x_add imply_memo ante_memo0 conseq_memo t_imply imp_no
mcpure.ml:let ###x_add imply_memo i ante_memo0 conseq_memo t_imply imp_no=
mcpure.ml: Debug.no_2_num i "###x_add imply_memo 2" (!print_mp_f)
mcpure.ml:      (fun ante_memo0 conseq_memo -> ###x_add imply_memo ante_memo0 conseq_memo t_imply imp_no) ante_memo0 conseq_memo
mcpure.ml:  let (r1,r2,r3)= ###x_add imply_memo ante_memo conseq_memo in  
mcpure.ml:  print_string ("###x_add imply_memo input1: "^(!print_mp_f ante_memo)^"\n");
mcpure.ml:  print_string ("###x_add imply_memo input1: "^(!print_mp_f conseq_memo)^"\n");    
mcpure.ml:  print_string ("###x_add imply_memo output: "^(string_of_bool r1)^"\n");
mcpure.ml:let memo_arith_###x_add simplify f = match f with
mcpure.ml:  | MemoF f -> MemoF (memo_arith_###x_add simplify f)
mcpure.ml:  | OnePF f -> OnePF (arith_###x_add simplify 6 f)
mcpure.ml:let memo_arith_###x_add simplify f = 
mcpure.ml:  Debug.no_1 "memo_arith_simplify" (!print_mix_f) (!print_mix_f) memo_arith_###x_add simplify f 
mcpure.ml:let check_pointer_d###x_add is_sat mf = match mf with
mcpure.ml:		let r,b = check_pointer_d###x_add is_sat f in
mem.ml:(* For Ramifications use --ramify it will turn off ###x_add unfold of duplicated pointers in solver.ml which is required to do ramifications *)
mem.ml:	let flag = List.exists (fun x -> let r,_,_  = TP.###x_add imply_one 6 fl1 x "mem_guard_imply" false None in r) fl2 in
mem.ml:    let f = CP.mkAnd x relevant_slice no_pos in TP.###x_add is_sat_sub_no 100 f sat_subno) fl1 in
mem.ml:			 	let vdef = C.###x_add look_up_view_def_raw 20 vl name in
mem.ml:                                       let r,_,_ = TP.###x_add imply_one 100 p checkeq "field_value_imply" false None in
mem.ml:		       TP.###x_add imply_one 101 pure_p after_sbst_guard "ramify_imply" false None in r) case_and_values2 in
mem.ml:		       TP.###x_add imply_one 12 pure_p after_sbst_guard "ramify_imply" false None in r) case_and_layouts2 in
mem.ml:			       	TP.###x_add imply_one 102 pure_p after_sbst_guard "ramify_imply" false None in r) case_and_values1 in
mem.ml:			       	TP.###x_add imply_one 13 pure_p after_sbst_guard "ramify_imply" false None in r) case_and_layouts1 in
mem.ml:					       	TP.###x_add imply_one 103 pure_p after_sbst_guard "ramify_imply" false None in r) case_and_values in
mem.ml:					       	TP.###x_add imply_one 14 pure_p after_sbst_guard "ramify_imply" false None in r) case_and_layouts in
mem.ml:		       	TP.###x_add imply_one 104 pure_p after_sbst_guard "ramify_imply" false None in r) case_and_values in
mem.ml:		       	TP.###x_add imply_one 15 pure_p after_sbst_guard "ramify_imply" false None in r) case_and_layouts in
mem.ml:	if String.compare (CF.###x_add get_node_name 7 h1) (CF.get_node_name 8 h2) == 0 then
mem.ml:		       let q_vdef = C.###x_add look_up_view_def_raw 21 vl (CF.###x_add get_node_name 9 q) in
mem.ml:		       let p_vdef = C.###x_add look_up_view_def_raw 22 vl name in
mem.ml:		       let q_vdef = C.###x_add look_up_view_def_raw 23 vl (CF.###x_add get_node_name 10 q) in
mem.ml:        let vdef =  C.###x_add look_up_view_def_raw 24 vl (CF.###x_add get_node_name 11 r) in
mem.ml:	let vdef = C.###x_add look_up_view_def_raw 25 vl (CF.###x_add get_node_name 12 h) in
mem.ml:	let vdef_r =  C.###x_add look_up_view_def_raw 26 vl (CF.###x_add get_node_name 13 r) in
mem.ml:        let vdef =  C.###x_add look_up_view_def_raw 27 vl rname in
mem.ml:     let vdef =  C.###x_add look_up_view_def_raw 28 vl name in
mem.ml:        let vdef_r =  C.###x_add look_up_view_def_raw 29 vl name in
mem.ml:        let vdef = I.###x_add look_up_view_def_raw 11 prog.I.prog_view_decls c in
minisat.ml:let minisat_arg_crypt = "--no-###x_add simplify --nosatelite --gaussuntil=3"
minisat.ml:      let res = Procutils.PrvComms.###x_add maybe_raise_timeout fnc () timeout in
minisat.ml:let minisat_###x_add is_sat (f : Cpure.formula) (sat_no : string) timeout : bool =
minisat.ml:let minisat_###x_add is_sat (f : Cpure.formula) (sat_no : string) : bool =
minisat.ml:  minisat_###x_add is_sat f sat_no minisat_timeout_limit
minisat.ml:let minisat_###x_add is_sat (f : Cpure.formula) (sat_no : string) : bool =
minisat.ml:  let result = Debug.no_1 "minisat_is_sat" pr string_of_bool (fun _ -> minisat_###x_add is_sat f sat_no) f in
minisat.ml:  (* let omega_result = Omega.###x_add is_sat f sat_no in
minisat.ml:     let () = print_endline ("-- minisat_###x_add is_sat result: " ^ (if result then "TRUE" else "FALSE")) in
minisat.ml:     let () = print_endline ("-- Omega.###x_add is_sat result: " ^ (if omega_result then "TRUE" else "FALSE")) in *)
minisat.ml:let ###x_add is_sat (f: Cpure.formula) (sat_no: string) : bool =
minisat.ml:  minisat_###x_add is_sat f sat_no 
minisat.ml:  Cpure.do_with_check "" (fun x -> ###x_add is_sat x sat_no) pe
minisat.ml:(* let ###x_add is_sat f sat_no = Debug.loop_2_no "is_sat" (!print_pure) (fun x->x) *)
minisat.ml:(* string_of_bool ###x_add is_sat f sat_no                                          *)
minisat.ml:let ###x_add is_sat (pe : Cpure.formula) (sat_no: string) : bool =
minisat.ml:    ###x_add is_sat pe sat_no;
minisat.ml:      print_endline_quiet ("Apply minisat.###x_add is_sat on formula :" ^ (Cprinter.string_of_pure_formula pe));
minisat.ml:  let res =###x_add is_sat imply_f ""
minisat.ml:let ###x_add simplify (f: Cpure.formula) : Cpure.formula =
minisat.ml:  try (Omega.###x_add simplify f) with _ -> f
minisat.ml:let ###x_add simplify (pe : Cpure.formula) : Cpure.formula =
minisat.ml:  match (Cpure.do_with_check "" ###x_add simplify pe) with
mona.ml:  (* let sat = Timelog.logtime_wrapper "mona-om" (Omega.###x_add is_sat constr) "mona constraints" in  *)  
mona.ml:  let simp_f = CP.arith_###x_add simplify 8 f in
mona.ml:	output_string log_all ("\n\n[mona.ml]: ####x_add is_sat " ^ sat_no ^ "\n");
mona.ml:let ###x_add simplify (pe : CP.formula) : CP.formula = begin
musterr.ml:    let ###x_add is_sat f = TP.###x_add is_sat_sub_no 9 f r in
musterr.ml:    let find_all_failures a c = CP.find_all_failures ###x_add is_sat a c in
musterr.ml:let ###x_add build_and_failures i (failure_code:string) (failure_name:string) ((contra_list, must_list, may_list)
new-mona.ml:  let simp_f = CP.arith_###x_add simplify 8 f in
new-mona.ml:let ###x_add is_sat (f : CP.formula) (sat_no :  string) : bool =
new-mona.ml:	output_string log_all ("\n\n[mona.ml]: ####x_add is_sat " ^ sat_no ^ "\n");
new-mona.ml:let ###x_add simplify (pe : CP.formula) : CP.formula = begin
norm.ml:and norm_formula_for_###x_add unfold cprog vdef = 
omega.ml:let ###x_add omega_of_formula i pr_w pr_s f  =
omega.ml:let ###x_add omega_of_formula_old i f  =
omega.ml:    Some (###x_add omega_of_formula i pr_w pr_s f)
omega.ml:let ###x_add omega_of_formula_old i f  =
omega.ml:       pr (pr_option pr_id) (fun _ -> ###x_add omega_of_formula_old i f) f
omega.ml:  (*print_endline (Gen.new_line_str^"####x_add is_sat " ^ sat_no ^ Gen.new_line_str);*)
omega.ml:          let fstr = ###x_add omega_of_formula 1 pr_weak pr_strong pe in
omega.ml:              output_string log_all (Gen.new_line_str^"####x_add is_sat " ^ sat_no ^ Gen.new_line_str);
omega.ml:let ###x_add is_sat (pe : formula)  (sat_no : string): bool =
omega.ml:let ###x_add is_sat (pe : formula)  (sat_no : string): bool =
omega.ml:  Debug.no_1 "Omega.is_sat" pf (string_of_bool) (fun _ -> ###x_add is_sat pe sat_no) pe
omega.ml:  ###x_add is_sat pe sat_no
omega.ml:let ###x_add is_sat (pe : formula) sat_no : bool =
omega.ml:    ###x_add is_sat pe sat_no
omega.ml:        print_endline_quiet ("Apply Omega.###x_add is_sat on formula :"^(!print_pure pe));
omega.ml:            let fstr = ###x_add omega_of_formula 2 pr_strong pr_weak pe in
omega.ml:      Some (###x_add omega_of_formula 8 pr_weak pr_strong pe1)
omega.ml:                            restart ("Timeout when checking ####x_add simplify ");
omega.ml:                            restart ("End_of_file when checking ####x_add simplify \n");
omega.ml:                  (*let () = print_string ("\nomega_simplify: f after"^(###x_add omega_of_formula simp_f)) in*)
omega.ml:let ###x_add simplify (pe : formula) : formula =
omega.ml:let ###x_add simplify (pe : formula) : formula =
omega.ml:  Debug.no_1 "Omega.simplify" pf pf ###x_add simplify pe
omega.ml:(*   (\*let () = print_string ("\nomega_simplify: f before"^(###x_add omega_of_formula pe)) in*\) *)
omega.ml:(*         let fstr = ###x_add omega_of_formula pr_weak pr_strong pe in *)
omega.ml:(*                 restart ("Timeout when checking ####x_add simplify "); *)
omega.ml:(*                 restart ("End_of_file when checking ####x_add simplify \n"); *)
omega.ml:(*     (\*let () = print_string ("\nomega_simplify: f after"^(###x_add omega_of_formula simp_f)) in*\) *)
omega.ml:(* (\*   do_with_check "Omega simplify" ###x_add simplify pe *\) *)
omega.ml:let ###x_add simplify (pe : formula) : formula = if not !Globals.oc_simplify then
omega.ml:  match (do_with_check "" ###x_add simplify pe)
omega.ml:(* let ###x_add simplify (pe : formula) : formula = *)
omega.ml:    match ((###x_add omega_of_formula_old 21 pe1), (omega_of_formula_old 21 pe2)) with
omega.ml:    match (###x_add omega_of_formula_old 21 pe) with
omega.ml:  Translate_out_array_in_cpure_formula.split_and_combine pairwisecheck Translate_out_array_in_cpure_formula.can_be_###x_add simplify pe
omega.ml:    match ###x_add omega_of_formula_old 22 pe with
omega.ml:    let fstr1 = ###x_add omega_of_formula_old 23 pe1 in
omega.ml:    let fstr2 = ###x_add omega_of_formula_old 24 pe2 in
omega.ml:  ###x_add simplify inp_f
others.ml:  else "..no proving kind.."(*"who called is_sat,imply,###x_add simplify to be displayed later..."*)
parse_shape.ml:let gen_conj x y = ###x_add normalize 1 x y loc;;
piecewise.ml:  List.filter ###x_add is_sat (List.map (fun (f, c) -> mkAnd f c (pos_of_formula f)) nf)
pi.ml:          let () = DD.ninfo_pprint ">>>>>> do_###x_add compute_fixpoint <<<<<<" no_pos in
pi.ml:            let bottom_up_fp0 = Fixcalc.###x_add compute_fixpoint 2 post_rel_df_new pre_vars (List.hd proc_specs) in
pi.ml:            (* let bottom_up_fp0 = List.fold_left (fun acc proc_spec -> acc@(Fixcalc.###x_add compute_fixpoint 2 post_rel_df_new pre_vars proc_spec)) [] proc_specs in *)
predcomp.ml:	  let vdef = C.###x_add look_up_view_def_raw prog.C.prog_view_decls c in
predcomp.ml:      let vdef = C.###x_add look_up_view_def_raw 30 prog.C.prog_view_decls c in
predcomp.ml:      let vdef = C.###x_add look_up_view_def_raw 31 prog.C.prog_view_decls c in
predcomp.ml:	let vdef = C.###x_add look_up_view_def_raw 32 prog.C.prog_view_decls c in
predicate.ml:  let extn_v = CA.###x_add look_up_view_def_raw 44 cviews extn_view_name in
predicate.ml:  (extn_view_name, ho_bs, ho_inds(* , CP.###x_add filter_var inv_p extn_v.C.view_vars *))
predicate.ml:          (*quans: ex quans from ###x_add normalize min/max*)
predicate.ml:  let extn_view = CA.###x_add look_up_view_def_raw 45 cviews extn_view_name in
predicate.ml:          (* let extn_view = CA.###x_add look_up_view_def_raw 46 cprog.CA.prog_view_decls extn_view_name in *)
procutils.ml:  let ###x_add maybe_raise_timeout (fn: 'a -> 'b) (arg: 'a) (limit:float) : 'b =
procutils.ml:    Debug.no_1_num i "maybe_raise_timeout" string_of_float pr_no (fun _ -> ###x_add maybe_raise_timeout fnc arg tsec) tsec 
procutils.ml:        let res = ###x_add maybe_raise_timeout fnc arg tsec in
procutils.ml:        let res = ###x_add maybe_raise_timeout fnc arg !sleek_timeout_limit in
prove.ml:        | Tpdispatcher.Sat f -> encode (Tpdispatcher.###x_add is_sat f)
prove.ml:        | Tpdispatcher.Simplify f -> encode (Tpdispatcher.###x_add simplify f)
redlog.ml:let no_###x_add simplify = ref false
redlog.ml:  let rec ###x_add simplify f0 vnames = match f0 with
redlog.ml:        let nf1 = ###x_add simplify f1 vnames in
redlog.ml:        let nf1 = ###x_add simplify f1 vnames in
redlog.ml:        let nf1 = ###x_add simplify f1 vnames in
redlog.ml:        let nf2 = ###x_add simplify f2 vnames in
redlog.ml:        let nf1 = ###x_add simplify f1 vnames in
redlog.ml:        let nf2 = ###x_add simplify f2 vnames in
redlog.ml:        CP.Not (###x_add simplify f1 vnames, lbl, l)
redlog.ml:  ###x_add simplify e (Hashtbl.create 100)
redlog.ml:    call_omega (lazy (Omega.###x_add is_sat f sat_no))
redlog.ml:    let err_msg = "Timeout when checking ####x_add is_sat " ^ sat_no ^ "!" in
redlog.ml:let ###x_add is_sat f sat_no =
redlog.ml:  let ###x_add is_sat f sat_no =
redlog.ml:      ###x_add is_sat f sat_no
redlog.ml:let ###x_add simplify (f: CP.formula) : CP.formula =
redlog.ml:    Omega.###x_add simplify f
redlog.ml:              Omega.###x_add simplify simpler_f
sa2.ml:  let find_###x_add imply_one cs1 cs2=
sa2.ml:  (*         let r = List.concat (List.map (find_###x_add imply_one cs1) (don@rest@res)) in *)
sa2.ml:                let new_constrs, unfroz_hps = find_###x_add imply_one cs1 cs2 in
sa2.ml:                let new_constrs, unfroz_hps = find_###x_add imply_one cs1 cs2 in
sa2.ml:  (*         let r = List.fold_left ( fun ls cs2 -> ls@(find_###x_add imply_one cs1 cs2)) res constrs in *)
sa2.ml:                let defined_hprels = List.map (Sautil.###x_add generate_hp_ass 2 unk_svl1 cond_path) defined_preds0 in
sa2.ml:    (*###x_add normalize args*)
sa2.ml:    (*###x_add normalize args*)
sa2.ml:            (*###x_add normalize linked ptrs*)
sa2.ml:    if not ###x_add is_sat then report_error no_pos "SA.infer_shapes_init_pre: HEAP CONJS do not SAT"
sa3.ml:  let find_###x_add imply_one cs1 cs2=
sa3.ml:                 let new_constrs, unfroz_hps = find_###x_add imply_one cs1 cs2 in
sa3.ml:                 let new_constrs, unfroz_hps = find_###x_add imply_one cs1 cs2 in
sa3.ml:  (*                   let new_constrs, unfroz_hps = find_###x_add imply_one cs1 cs2 in *)
sa3.ml:                let new_constrs, unfroz_hps = find_###x_add imply_one cs1 cs2 in
sa3.ml:                let defined_hprels = List.map (Sautil.###x_add generate_hp_ass 2 unk_svl1 new_cs.CF.hprel_path) defined_preds0 in
sa3.ml:    (*###x_add normalize args*)
sa3.ml:    (*###x_add normalize args*)
sa3.ml:            (*###x_add normalize linked ptrs*)
sa3.ml:              let sel_p = CP.###x_add filter_var (CF.get_pure cs.CF.hprel_lhs) args1 in
sa3.ml:                      let n_guard2 = CP.###x_add filter_var n_guard [r] in
sa3.ml:    if not ###x_add is_sat then report_error no_pos "SA.infer_shapes_init_pre: HEAP CONJS do not SAT"
sa3.ml:      (* ###x_add unfold view, if it is not rec *)
sacore.ml:  priority of ###x_add xpure name:
sacore.ml:    (* let ps = obtain_###x_add xpure args 0 hp [] in *)
sacore.ml:    (* let ps = obtain_###x_add xpure [(List.hd args)] 0 hp [] in *)
sacore.ml:  let subst_###x_add xpure lhpdefs (xp_hpargs) f0=
sacore.ml:        subst_###x_add xpure new_hpdefs xp_args f
sacore.ml:  let get_###x_add xpure cs=
sacore.ml:      ls@(get_###x_add xpure cs)
sacore.ml:            let b,_,_ = Tpdispatcher.###x_add imply_one 20 lmf rmf "sa:check_hrels_imply" true None in
sacore.ml:    let vdef = (Cast.###x_add look_up_view_def_raw 40 cprog.Cast.prog_view_decls vname) in
sacore.ml:      let need_###x_add unfold = List.fold_left (fun r (vname,vdef,_) ->
sacore.ml:      if need_###x_add unfold = [] then cs.CF.hprel_rhs else
sacore.ml:  let (valid, rs,v_hp_rel) = Sleekcore.###x_add sleek_entail_check 6 [] vars cprog [] ante conseq in
sacore.ml:    let ps1 = List.map (fun p -> CP.###x_add filter_var p [r]) ps in
sacore.ml:      let p = CP.###x_add filter_var (CF.get_pure f) [r] in
sacore.ml:    (*do ###x_add unfold the rhs*)
sacore.ml:    (* let (valid, _, _) = Sleekcore.###x_add sleek_entail_check [] cprog [] rhs2 (CF.struc_formula_of_formula lhs no_pos) in *)
sacore.ml:                  (*###x_add normalize the paras (convert back to the orig)*)
sacore.ml:(*###x_add normalize parameters of each hp_def like in rhs *)
sacore.ml:                      (*###x_add normalize the paras (convert back to the orig)*)
sacore.ml:                (*###x_add normalize args of hp_defs for next rounds (with pure)*)
sacore.ml:  let proving_fnc svl f1 = wrap_proving_kind PK_Pred_Split (Sleekcore.###x_add sleek_entail_check 7 [] svl prog [] f1) in
saerror.ml:    if (Cformula.###x_add get_node_name 14 h_formula == Cformula.get_node_name 15 hprel_def.Cformula.hprel_def_hrel)
saerror.ml:            let (mix_formula, _, _) = Cvutil.###x_add xpure 17 prog pre_cond in
saerror.ml:    not (Tpdispatcher.###x_add is_sat 100 (Cpure.mkNot formula None no_pos) "check eq" "")
saerror.ml:    let filtered_list_conjs = List.filter (fun pf -> Tpdispatcher.###x_add is_sat 100 (Cpure.mkNot pf None no_pos) "check true conjs" "") list_conjs in
saerror.ml:  if not (Tpdispatcher.###x_add is_sat 100 (Cpure.mkNot uni_case None no_pos) "check universe" "")
saerror.ml:(*       let name = Cformula.###x_add get_node_name hprel_def.Cformula.hprel_def_hrel in *)
saerror.ml:(*                                   let name = Cformula.###x_add get_node_name hf in *)
saerror.ml:(*                                   let subst_formula = List.find (fun formula -> name == Cformula.###x_add get_node_name formula.Cformula.hprel_def_hrel) opt in *)
sa.ml:(*           let b,_,_ = TP.###x_add imply_one 21 rmf lmf "sa:check_hrels_imply" true None in *)
sa.ml:  let find_###x_add imply_one cs1 cs2=
sa.ml:          let r = List.concat (List.map (find_###x_add imply_one cs) (don@ss@res)) in
sa.ml:    (*###x_add normalize args*)
sa.ml:  (*###x_add normalize linked ptrs*)
saout.ml:                let view = C.###x_add look_up_view_def_raw 33 cprog.C.prog_view_decls hp_name in
saout.ml:                           let old_baga_flag = !baga_###x_add xpure in
saout.ml:                           let () = baga_###x_add xpure := true in
saout.ml:                           let guard,_,_=(x_add Cvutil.###x_add xpure_symbolic 11 prog f2) in
saout.ml:                           let () = baga_###x_add xpure := old_baga_flag in
saout.ml:                 let todo_unk = Cast.###x_add look_up_view_def_raw 33 cprog.Cast.prog_view_decls
sap.ml:  let iview = Iast.###x_add look_up_view_def_raw 48 iprog.Iast.prog_view_decls view.Cast.view_name in
sautil.ml:            (CP.isConstTrue p || (List.for_all CP.is_###x_add xpure ps))
sautil.ml:let ###x_add filter_var prog svl f=
sautil.ml:    let p_w_quan = CP.mkExists_with_simpl TP.###x_add simplify diff_svl p None no_pos in
sautil.ml:    let p = CP.###x_add filter_var (MCP.pure_of_mix lhsb.CF.formula_base_pure) all_svl in
sautil.ml:    let p_w_quan = CP.mkExists_with_simpl TP.###x_add simplify (*Omega.simplify*) diff_svl p None no_pos in
sautil.ml:let ###x_add generate_hp_ass unk_svl cond_p (hp,args,lfb,rf) =
sautil.ml:let ###x_add generate_hp_ass i unk_svl cond_p (hp,args,lfb,rf) =
sautil.ml:  Debug.no_1_num i "generate_hp_ass" pr_none pr_none (fun _ -> ###x_add generate_hp_ass unk_svl cond_p (hp,args,lfb,rf)) 1
sautil.ml:(*      let b1,_,_ = TP.###x_add imply_one 3 p1 p2 "sa:checkeq_pure" true None in *)
sautil.ml:(*       let b2,_,_ = TP.###x_add imply_one 4 p2 p1 "sa:checkeq_pure" true None in *)
sautil.ml:        CP.equalFormula (CP.###x_add filter_var ps01 (CP.diff_svl args null_svl1))
sautil.ml:        (CP.###x_add filter_var ps02 (CP.diff_svl args null_svl1))
sautil.ml:            let b,_,_ = TP.###x_add imply_one 5 rmf1 lmf "sa:check_hrels_imply" true None in
sautil.ml:  (* let f1 = ###x_add filter_var prog args f in *)
sautil.ml:    let f1 = ###x_add filter_var prog args f in
sautil.ml:      let vdef = C.###x_add look_up_view_def_raw 43 prog.C.prog_view_decls vn0.CF.h_formula_view_name in
sautil.ml:     if need_###x_add unfold then
sautil.ml:  let subst_###x_add xpure lhpdefs xp_hpargs f0=
sautil.ml:        subst_###x_add xpure new_hpdefs xp_args f
sautil.ml:        let view_decl = Cast.###x_add look_up_view_def_raw 42 prog.Cast.prog_view_decls view_name in
scriptarguments.ml:    "Do not use Omega to ###x_add simplify the arithmetic constraints when using other solver");
scriptarguments.ml:    "Do not ###x_add simplify the arithmetic constraints");
scriptarguments.ml:    ("--ramify", Arg.Clear Solver.unfold_duplicated_pointers,"Use Ramification (turns off ###x_add unfold on dup pointers)");
scriptarguments.ml:    "Disable the computation of ###x_add xpure 0");
scriptarguments.ml:    "Smart ###x_add xpure with 0 then 1; otherwise just 1 ; not handled by infer yet");
scriptarguments.ml:    "Do not try to ###x_add simplify non-linear formulas with Redlog");
scriptarguments.ml:    "Set timeout (in seconds) for ###x_add is_sat or imply with Redlog");
scriptarguments.ml:    ("--lem-en-norm", Arg.Set Globals.allow_lemma_norm, "Allow case-###x_add normalize for lemma");
scriptarguments.ml:    ("--lem-dis-norm", Arg.Clear Globals.allow_lemma_norm, "Disallow case-###x_add normalize for lemma");
scriptarguments.ml:    ("--lem-en-deep-unfold", Arg.Set Globals.allow_lemma_deep_unfold, "Allow deep ###x_add unfold for Lemma Proving");
scriptarguments.ml:    ("--lem-dis-deep-unfold", Arg.Clear Globals.allow_lemma_deep_unfold, "Disallow deep ###x_add unfold for Lemma Proving");
scriptarguments.ml:    ("--lem-dis-lhs-unfold", Arg.Clear Globals.enable_lemma_lhs_unfold, "Disable LHS ###x_add unfold for Lemma Proving");
scriptarguments.ml:    ("--lem-en-lhs-unfold", Arg.Set Globals.enable_lemma_lhs_unfold, "Enable LHS ###x_add unfold for Lemma Proving");
scriptarguments.ml:    ("--lem-en-rhs-unfold", Arg.Set Globals.enable_lemma_rhs_unfold, "Enable RHS ###x_add unfold for Lemma Proving");
scriptarguments.ml:    ("--lem-dis-rhs-unfold", Arg.Clear Globals.enable_lemma_rhs_unfold, "Disable RHS ###x_add unfold for Lemma Proving");
scriptarguments.ml:    ("--lem-gen-safe", Arg.Set Globals.lemma_gen_safe, "enable generating (and proving) both fold and ###x_add unfold lemmas for special predicates");
scriptarguments.ml:    ("--lem-gen-unsafe", Arg.Set Globals.lemma_gen_unsafe, "enable generating (without proving) both fold and ###x_add unfold lemmas for special predicates");
scriptarguments.ml:    ("--sa-tree-simp", Arg.Set Globals.sa_tree_simp, "###x_add simplify a tree branches of definition");
setmona.ml:and ###x_add normalize (f0 : formula) : formula = match f0 with
setmona.ml:	  let nf1 = ###x_add normalize f1 in
setmona.ml:	  let nf2 = ###x_add normalize f2 in
setmona.ml:	  let nf1 = ###x_add normalize f1 in
setmona.ml:	  let nf2 = ###x_add normalize f2 in
setmona.ml:	  let nf1 = ###x_add normalize f1 in
setmona.ml:	  let nqf = ###x_add normalize qf in
setmona.ml:	  let nqf = ###x_add normalize qf in
setmona.ml:		failwith ("mona_of_b_formula: Eq: ###x_add normalize failed to transform, still left with non vars ")
setmona.ml:				  failwith ("###x_add normalize failed to transform: stubtraction")
setmona.ml:	else ###x_add filter_var ante1 (fv conseq)
setmona.ml:  let ante = ###x_add normalize ante in
setmona.ml:  let conseq = ###x_add normalize conseq in
setmona.ml:let ###x_add is_sat (f : formula) : bool = 
setmona.ml:			  output_string log_all "[mona.ml]: ###x_add is_sat --> false\n"; 					
setmona.ml:			  output_string log_all "[mona.ml]: ###x_add is_sat --> true\n"; 
share_prover.ml:	 val ###x_add is_sat : eq_syst -> bool
share_prover.ml:		let ###x_add is_sat (eqs : eq_syst): bool = 			
share_prover.ml:		let ###x_add is_sat (eqs:eq_syst):bool = 
share_prover.ml:			let r = ###x_add is_sat eqs in
share_prover.ml:				decompose_sys c_sys with | Unsat_exception -> raise (Unsat_conseq (not (###x_add is_sat a_sys))) in
share_prover.ml:			(*###x_add simplify the antecedent*)
share_prover.ml:			(*###x_add simplify the conseq*)
share_prover_w2.ml:		if Smtsolver.###x_add is_sat f_tot "0" then true
share_prover_w2.ml:		else List.for_all (fun c-> Smtsolver.###x_add is_sat (CP.mkAnd f_eq c no_pos) "1") f_nz_l
share_prover_w2.ml:		Solver.###x_add is_sat eqs
share_prover_w2.ml:		with | Solver.Unsat_exception -> not (Solver.###x_add is_sat aeqs)
share_prover_w.ml:		if Smtsolver.###x_add is_sat f_tot "0" then true
share_prover_w.ml:		else List.for_all (fun c-> Smtsolver.###x_add is_sat (CP.mkAnd f_eq c no_pos) "1") f_nz_l
share_prover_w.ml:		Solver.###x_add is_sat eqs
share_prover_w.ml:		with | Solver.Unsat_exception -> not (Solver.###x_add is_sat aeqs)
sleekcore.ml:  let ante = Solver.###x_add normalize_formula_w_coers 11 cprog es ante (* cprog.C.prog_left_coercions *) lem in
sleekcore.ml:  let init_ctx =  (* CF.transform_context (Solver.###x_add elim_unsat_es 9 cprog (ref 1)) *) ctx in
sleekcore.ml:  (*     Solver.###x_add unsat_base_nth 1 cprog (ref 1) f *)
sleekcore.ml:  let rs, prf = Solver.###x_add heap_entail_struc_list_failesc_context_init 12 prog false true ante_failesc_ctx conseq None None None pos pid in
sleekcore.ml:  let ante = Solver.###x_add normalize_formula_w_coers 11 cprog es ante lem (* cprog.C.prog_left_coercions *) in
sleekcore.ml:      (* let is_unsat = Solver.###x_add unsat_base_nth 22 cprog (sno) ante in *)
sleekcore.ml:        if ###x_add is_sat then false else
sleekcore.ml:        else CF.transform_context (Solver.###x_add elim_unsat_es 9 cprog (ref 1)) ctx in
sleekcore.ml:(* let ###x_add sleek_entail_check itype isvl (cprog: C.prog_decl) proof_traces ante conseq=
sleekcore.ml:and ###x_add sleek_entail_check i itype isvl (cprog: C.prog_decl) proof_traces ante conseq=
sleekcore.ml:    let r, lc, isvl = ###x_add sleek_entail_check 1 [] [] (prog: C.prog_decl) proof_traces conj_ante1 (CF.struc_formula_of_formula norm_conj_conseq2 no_pos) in
sleekcore.ml:              let vdecl = Cast.###x_add look_up_view_def_raw 55 prog.Cast.prog_view_decls vn in
sleekcore.ml:      let b1, _, _ = (###x_add sleek_entail_check 2 [] [] cprog proof_traces f1 (CF.struc_formula_of_formula f2 no_pos)) in
sleekcore.ml:        let b2,_,_ = (###x_add sleek_entail_check 3 [] [] cprog (List.map (fun (f1,f2) -> (f2,f1)) proof_traces)
sleekengine.ml:(* 		  let _ = I.###x_add look_up_view_def_raw 3 iprog.I.prog_view_decls name in *)
sleekengine.ml:  let res = Lemproving.###x_add verify_lemma 2 l2r r2l !cprog (ldef.I.coercion_name) ldef.I.coercion_type in
sleekengine.ml:  let cviews2 = (List.map (fun vdef -> Norm.norm_formula_for_###x_add unfold !cprog vdef) cviews2) in
sleekengine.ml:        let wf,_ = Astsimp.###x_add case_normalize_struc_formula 12 iprog h p (Iformula.formula_to_struc_formula mf) true 
sleekengine.ml:      let wf,_ = Astsimp.###x_add case_normalize_struc_formula 13 iprog h p b true (* allow_primes *) 
sleekengine.ml:let run_###x_add simplify (iante0 : meta_formula) =
sleekengine.ml:  (*let ante = Solver.###x_add normalize_formula_w_coers !cprog (CF.empty_es (CF.mkTrueFlow ()) Lab2_List.unlabelled no_pos) ante !cprog.Cast.prog_left_coercions in*)
sleekengine.ml:  let (res, rs,v_hp_rel) = Sleekcore.###x_add sleek_entail_check 8 itype vars !cprog [] ante conseq in
sleekengine.ml:  (*   let pre_fixs = Fixpoint.pre_rel_fixpoint pre_rel [] [] FixcalCast.###x_add compute_fixpoint_td *)
sleekengine.ml:  let r = Fixcalc.###x_add compute_fixpoint 2 post_rel_constrs post_rels proc_spec in
sleekengine.ml:          (*         (\* let reg1 = Str.regexp "base case ###x_add unfold failed" in *\) *)
sleekengine.ml:  let unsat_command f = not(Solver.###x_add unsat_base_nth 7 !cprog (ref 0) f) in
sleekengine.ml:  let res = Solver.###x_add unsat_base_nth 1 !cprog (ref 0) f in
sleekengine.ml:  let newf = Solver.###x_add prop_formula_w_coers 1 !cprog estate cf (Lem_store.all_lemma # get_left_coercion) in
sleekengine.ml:let process_###x_add simplify (f : meta_formula) =
sleekengine.ml:    let rs = run_###x_add simplify f in
sleek.ml:    | Simplify f -> process_###x_add simplify f
sleek.ml:      | Simplify f -> process_###x_add simplify f
slsat.ml:  let ###x_add is_sat = true in
slsat.ml:  let ###x_add is_sat = true in
slsat.ml:  let ###x_add is_sat = match ante.formula_base_heap with
slsat.ml:  let ###x_add is_sat = false in
smtsolver.ml:      Procutils.PrvComms.###x_add maybe_raise_timeout fnc () timeout
smtsolver.ml:    (* We don't have conseq part in ###x_add is_sat checking *)
smtsolver.ml:let smt_###x_add is_sat pr_weak pr_strong (f : Cpure.formula) (sat_no : string) (prover: smtprover) timeout : bool =
smtsolver.ml:  (* let () = print_endline ("smt_###x_add is_sat : " ^ (!print_pure f) ^ "\n") in *)
smtsolver.ml:  smt_###x_add is_sat pr_weak pr_strong f sat_no Z3 z3_sat_timeout_limit
smtsolver.ml:let ###x_add is_sat f sat_no =
smtsolver.ml:  smt_###x_add is_sat pr_w pr_s f sat_no Z3 z3_sat_timeout_limit
smtsolver.ml:let is_sat_with_check (pe : CP.formula) sat_no : bool option = CP.do_with_check "" (fun x -> ###x_add is_sat x sat_no) pe 
smtsolver.ml:let ###x_add is_sat (pe : CP.formula) sat_no : bool =
smtsolver.ml:    ###x_add is_sat pe sat_no
smtsolver.ml:    print_endline_quiet ("Apply z3.###x_add is_sat on formula :"^(!print_pure pe));
smtsolver.ml:let ###x_add is_sat f sat_no = Debug.no_2(* _loop *) "z3.is_sat" (!print_pure) (fun x->x) string_of_bool is_sat f sat_no
smtsolver.ml:let ###x_add simplify (f: CP.formula) : CP.formula = 
smtsolver.ml:    (Omega.###x_add simplify f)
smtsolver.ml:let ###x_add simplify (pe : CP.formula) : CP.formula =
smtsolver.ml:  match (CP.do_with_check "" ###x_add simplify pe) with
smtsolver.ml:let ###x_add simplify (pe : CP.formula) : CP.formula =
smtsolver.ml:  Debug.no_1 "simplify" pr pr ###x_add simplify pe 
solver.ml:let simple_imply f1 f2 = let r,_,_ = TP.###x_add imply_one 23 f1 f2 "simple_imply" false None in r   
solver.ml:		let vdef = ###x_add look_up_view_def v.h_formula_view_pos prog.prog_view_decls v.h_formula_view_name in
solver.ml:  - if there are more than 1 --> means that we can ###x_add simplify further (by performing the operation)
solver.ml:          let v_def = ###x_add look_up_view_def no_pos prog.prog_view_decls vn2.h_formula_view_name in
solver.ml:let no_diff = ref false (* if true, then ###x_add xpure_symbolic will drop the disequality generated by * *)
solver.ml:(* 				let vdef = ###x_add look_up_view_def pos prog.prog_view_decls c in *)
solver.ml:(*                           let res,_,_ = CP.imply_disj_orig [f0] full_f (TP.###x_add imply_one 24) imp_no in *)
solver.ml:(*             let vdef = ###x_add look_up_view_def pos prog.prog_view_decls c in *)
solver.ml:(*                     let res,_,_ = CP.imply_disj_orig [f0] full_f (TP.###x_add imply_one 25) imp_no in *)
solver.ml:(*                           let res,_,_ = CP.imply_disj_orig [f0] full_f (TP.###x_add imply_one 24) imp_no in *)
solver.ml:(*             let vdef = ###x_add look_up_view_def pos prog.prog_view_decls c in *)
solver.ml:(*                     let res,_,_ = CP.imply_disj_orig [f0] full_f (TP.###x_add imply_one 25) imp_no in *)
solver.ml:(* (\* ###x_add xpure approximation with memory enumeration *\) *)
solver.ml:(*   (\*use different ###x_add xpure functions*\) *)
solver.ml:(* 		          let b,_,_ = CP.imply_disj_orig [f] or_f (TP.###x_add imply_one 100) imp_no in *)
solver.ml:(* 			    let b =  not (TP.###x_add is_sat_sub_no 8 nf (ref 0)) in *)
solver.ml:(* 			  let b,_,_ = CP.imply_disj_orig [f] gt_exp (TP.###x_add imply_one 101) imp_no in *)
solver.ml:(* (\* ###x_add xpure heap in the presence of permissions *\) *)
solver.ml:(* (\* similar to ###x_add xpure_heap_mem_enum *\) *)
solver.ml:(* and xpure_heap_perm (prog : prog_decl) (h0 : h_formula) (p0: mix_formula) (which_###x_add xpure :int) : (MCP.mix_formula * CF.mem_formula) =   *)
solver.ml:(*       (fun _ _ _ -> xpure_heap_perm_x prog h0 p0 which_xpure) h0 p0 which_###x_add xpure  *)
solver.ml:(* and xpure_heap_perm_x (prog : prog_decl) (h0 : h_formula)  (p0: mix_formula) (which_###x_add xpure :int) : (MCP.mix_formula  * CF.mem_formula) = *)
solver.ml:(*   let rec xpure_heap_helper (prog : prog_decl) (h0 : h_formula) (which_###x_add xpure :int) memset: MCP.mix_formula =  *)
solver.ml:(*             let vdef = ###x_add look_up_view_def pos prog.prog_view_decls c in *)
solver.ml:(*                       let vinv = match which_###x_add xpure with *)
solver.ml:(*                         A better ###x_add xpure could be: *)
solver.ml:(*             let ph1 = x_add xpure_heap_helper prog h1 which_###x_add xpure memset in *)
solver.ml:(*             let ph2 = x_add xpure_heap_helper prog h2 which_###x_add xpure memset in *)
solver.ml:(*   let mf = x_add xpure_heap_helper prog h0 which_###x_add xpure memset in *)
solver.ml:(* (\*###x_add xpure heap in the presence of imm and permissions*\) *)
solver.ml:(* and xpure_heap_symbolic_perm_x (prog : prog_decl) (h0 : h_formula)  (p0: mix_formula) (which_###x_add xpure :int) : (MCP.mix_formula * CP.spec_var list * CF.mem_formula) =  *)
solver.ml:(*   let ph, pa = x_add xpure_heap_symbolic_perm_i prog h0 which_###x_add xpure in *)
solver.ml:(* (\*###x_add xpure heap in the presence of imm and permissions*\) *)
solver.ml:(*           let vdef = ###x_add look_up_view_def pos prog.prog_view_decls c in *)
solver.ml:  let r = transform_list_context ((###x_add elim_unsat_es_now prog (ref 1)),(fun c->c)) r in
solver.ml:  let r = transform_list_context ((###x_add elim_unsat_es 7 prog (ref 1)),(fun c->c)) ctx in
solver.ml:  let r = transform_list_partial_context ((###x_add elim_unsat_es_now prog (ref 1)),(fun c->c)) ctx in
solver.ml:  let r = transform_list_failesc_context (idf,idf,(###x_add elim_unsat_es 6 prog (ref 1))) ctx in
solver.ml:  let r = transform_list_failesc_context (idf,idf,(###x_add elim_unsat_es_now 2 prog (ref 1))) r in
solver.ml:  let r = transform_context (###x_add elim_unsat_es_now 3 prog (ref 1)) r in
solver.ml:  let r = transform_context (###x_add elim_unsat_es 5 prog (ref 1)) ctx in
solver.ml:(* ###x_add unfold then unsat *)
solver.ml:and ###x_add unfold_struc_nth (n:int) (prog:prog_or_branches) (f : struc_formula) (v : CP.spec_var) (already_unsat:bool) (uf:int) (pos : loc) : struc_formula =
solver.ml:	  let vdef = Cast.###x_add look_up_view_def pos (fst prog).prog_view_decls lhs_name in
solver.ml:	  let res_form = struc_formula_set_lhs_case false (add_struc_origins origs res_form ) in (* no LHS case analysis after ###x_add unfold *)
solver.ml:	    (###x_add normalize_formula_w_coers 1 (fst prog) tmp_es new_f (Lem_store.all_lemma # get_left_coercion), []) (*(fst prog).prog_left_coercions*) 
solver.ml:      | Exists _ -> (*report_error pos ("malfunction: trying to ###x_add unfold in an existentially quantified formula!!!")*)
solver.ml:	    (###x_add normalize_formula_w_coers 2 (fst prog) tmp_es uf (Lem_store.all_lemma # get_left_coercion), l) (*(fst prog).prog_left_coercions*)
solver.ml:          let r = elim_unsat_for_###x_add unfold (fst prog) resform in
solver.ml:      (add_str "###x_add unfold count:" string_of_int)
solver.ml:  (*  let () = print_string("###x_add unfold heap " ^ (Cprinter.string_of_h_formula f) ^ "\n\n") in*)
solver.ml:      let vdef = Cast.###x_add look_up_view_def pos prog1.prog_view_decls lhs_name in
solver.ml:        (* don't ###x_add unfold primitive predicates *)
solver.ml:                      let vdef = Cast.###x_add look_up_view_def pos prog.prog_view_decls lhs_name in
solver.ml:                      (*let () = print_string ("###x_add unfold pre subst: "^(Cprinter.string_of_formula renamed_view_formula)^"\n") in*)
solver.ml:                      (*let () = print_string ("###x_add unfold post subst: "^(Cprinter.string_of_formula renamed_view_formula)^"\n") in*)
solver.ml:                      (* let () = print_string ("###x_add unfold pre subst: "^(Cprinter.string_of_formula renamed_view_formula)^"\n") in *)
solver.ml:                      (*   let () = print_string ("###x_add unfold post subst: "^(Cprinter.string_of_formula res_form)^"\n") in *)
solver.ml:                      let res_form = set_lhs_case res_form false in (* no LHS case analysis after ###x_add unfold *)
solver.ml:                | Some (base , (pred_id,to_vars)) -> (* base case ###x_add unfold *)
solver.ml:                      if flag then  (* perform base-case ###x_add unfold *)
solver.ml:              try ###x_add look_up_view_def_raw 6 prog.Cast.prog_view_decls c
solver.ml:	  let new_conseq = ###x_add normalize 6 tmp_conseq (formula_of_pure_N to_conseq pos) pos in
solver.ml:	  let new_ante = ###x_add normalize 7 fold_es.es_formula (formula_of_pure_N to_ante pos) pos in
solver.ml:	  let rest_rs, prf = ###x_add heap_entail_one_context 1 prog is_folding new_ctx new_conseq None None None pos in
solver.ml:	  let t1 = ###x_add fold_context_left 1 t1 in
solver.ml:          let sf=TP.###x_add simplify_a 11 f0 in
solver.ml:    let sf = TP.###x_add simplify_a 2 f  in
solver.ml:      MCP.simpl_memo_pure_formula simpl_b_formula simpl_pure_formula p (TP.###x_add simplify_a 1)
solver.ml:  let simpl_fl = fl (*flows have nothing to ###x_add simplify to*)in
solver.ml:	  let pf, _, m_set = x_add ###x_add xpure 1 prog f in
solver.ml:	let sat,npf = MCP.check_pointer_d###x_add is_sat npf in
solver.ml:    | Or _ -> report_error no_pos ("unsat_###x_add xpure : encountered a disjunctive formula \n")
solver.ml:          if !Globals.baga_###x_add xpure (* !Globals.gen_baga_inv *) then tp_syn h p
solver.ml:          if !Globals.baga_###x_add xpure then tp_syn qh qp
solver.ml:and ###x_add unsat_base_nth (n:int) prog (sat_subno:  int ref) f  : bool =
solver.ml:and ###x_add elim_unsat_es i (prog : prog_decl) (sat_subno:  int ref) (es : entail_state) : context =
solver.ml:  else ###x_add elim_unsat_es_now 4 prog sat_subno es
solver.ml:    | Ctx es -> let exec ()= ###x_add elim_unsat_es 1 prog sat_subno es in wrap_trace es.es_path_label exec ()
solver.ml:and ###x_add elim_unsat_es_now i (prog : prog_decl) (sat_subno:  int ref) (es : entail_state) : context =
solver.ml:  let b = ###x_add unsat_base_nth 1 prog sat_subno temp_f in
solver.ml:  | Ctx es -> ###x_add elim_unsat_es_now i prog sat_subno es
solver.ml:and elim_unsat_for_###x_add unfold (prog : prog_decl) (f : formula) : formula =
solver.ml:        (*   let pf, pfb = x_add ###x_add xpure prog f in *)
solver.ml:        (*   List.fold_left (fun a c-> if not a then a else TP.###x_add is_sat_sub_no c sat_subno) true f_lst  *)
solver.ml:        (*   else TP.###x_add is_sat_sub_no (CP.And (npf, pf1b, no_pos)) sat_subno ) true pfb in *)
solver.ml:        let is_ok = ###x_add unsat_base_nth 2 prog sat_subno f in
solver.ml:              let name = CF.###x_add get_node_name 16 h in
solver.ml:              let rs,prf = ###x_add heap_entail_one_context 15 prog false (CF.Ctx new_es) new_f None None None no_pos in
solver.ml:and ###x_add heap_entail_failesc_prefix_init i (prog : prog_decl) (is_folding : bool)  (has_post: bool)(cl : list_failesc_context)
solver.ml:  if (List.length cl)<1 then report_error pos ("###x_add heap_entail_failesc_prefix_init : encountered an empty list_partial_context \n")
solver.ml:            ((###x_add fold_context_left 20 tmp2), prf)
solver.ml:(* and ###x_add heap_entail_one_context_struc p i1 hp cl cs (tid: CP.spec_var option) (delayed_f: MCP.mix_formula option) (join_id: CP.spec_var option) pos pid = *)
solver.ml:  Gen.Profiling.do_3_num n_str str (###x_add heap_entail_one_context_struc n p i1 hp cl) cs tid delayed_f join_id pos pid
solver.ml:and ###x_add heap_entail_one_context_struc i p i1 hp cl cs (tid: CP.spec_var option) (delayed_f: MCP.mix_formula option) (join_id: CP.spec_var option) pos pid =
solver.ml:        let result, prf = ###x_add heap_entail_after_sat_struc 1 prog is_folding has_post ctx conseq tid delayed_f join_id pos pid []  in
solver.ml:    let vdef = C.###x_add look_up_view_def_raw 42 prog.C.prog_view_decls vn0.CF.h_formula_view_name in
solver.ml:and ###x_add heap_entail_after_sat_struc i prog is_folding  has_post
solver.ml:          let rs1, prf1 = ###x_add heap_entail_after_sat_struc 2 prog is_folding
solver.ml:          let rs2, prf2 = ###x_add heap_entail_after_sat_struc 3 prog is_folding
solver.ml:              let fs = if need_###x_add unfold then
solver.ml:              if need_###x_add unfold && List.length fs > 1 then
solver.ml:                 ###x_add heap_entail_after_sat_struc 4 prog is_folding has_post
solver.ml:              (* let () = print_endline "###x_add xpure true!" in *)
solver.ml:  let rs,prf = ###x_add heap_entail_one_context 12 prog false (CF.Ctx new_es) new_f None None None pos in
solver.ml:        let rs = CF.transform_context (###x_add elim_unsat_es_now 5 prog (ref 1)) nctx in
solver.ml:                (*###x_add normalize until a fixpoint is reached*)
solver.ml:  let rec ###x_add helper_inner i (ctx11: context) (f: struc_formula) : list_context * proof =
solver.ml:                                          let (r,prf) = ###x_add helper_inner 9 ctx rhs in
solver.ml:	                            (*   let nc,np = ###x_add helper_inner 1 new_ctx new_struc in  *)
solver.ml:					          ###x_add helper_inner 2 (prune_ctx prog n_ctx) c2) case_brs (* b.formula_case_branches *) 
solver.ml:				            [###x_add helper_inner 3 ctx e] end in
solver.ml:                                  if need_###x_add unfold then
solver.ml:                                    ###x_add helper_inner 14 n_ctx n_struc_f
solver.ml:	                            let nc, np = ###x_add helper_inner 4 new_ctx new_struc in 
solver.ml:	                                    let n_ctx_list, prf = ###x_add heap_entail_one_context 13 prog (if formula_cont!=None then true else is_folding) n_ctx formula_base None None None pos in
solver.ml:                                              let n_ctx_list, prf = ###x_add heap_entail_one_context 14 prog (if formula_cont!=None then true else is_folding) n_ctx formula_base None None None pos in
solver.ml:                                                      let n_ctx_list, prf = ###x_add heap_entail_one_context 15 prog (if formula_cont!=None then true else is_folding) n_ctx formula_base tid delayed_f join_id pos in
solver.ml:                                                      let n_ctx_list, prf = ###x_add heap_entail_one_context 16 prog (if formula_cont!=None then true else is_folding) n_ctx new_formula_base tid (Some df) join_id pos in
solver.ml:                                              (*let ctx1,_= ###x_add heap_entail_one_context prog is_folding ctx11 (mkTrue_nf pos) pos in*)
solver.ml:                                              let rs2 = if !Globals.force_post_sat then CF.transform_context (###x_add elim_unsat_es_now 5 prog (ref 1)) rs1 else rs1 in
solver.ml:                                              (*###x_add normalize until a fixpoint is reached*)
solver.ml:                                              (*         (\*###x_add normalize until a fixpoint is reached*\) *)
solver.ml:                                ###x_add helper_inner 22 ctx11 e.Cformula.formula_inf_continuation
solver.ml:                                          ###x_add helper_inner 10 ctx (snd c)
solver.ml:			              ((###x_add fold_context_left 42 l1),(mkCaseStep ctx (EList conseq) l2))
solver.ml:  ###x_add helper_inner 8 ctx_00 conseq
solver.ml:  | OCtx (ctx1,ctx2) -> ###x_add heap_entail_conjunct prog is_folding ctx0 conseq [] pos
solver.ml:  ###x_add heap_entail_conjunct prog is_folding ctx_new conseq_without_conj [] pos
solver.ml:  let (rs,p) = ###x_add heap_entail_conjunct prog is_folding ctx new_conseq [] pos in
solver.ml:  ###x_add heap_entail_conjunct prog is_folding ctx_new conseq_without_conj [] pos
solver.ml:      then ###x_add heap_entail_conjunct 12 prog is_folding ctx_00 conseq rhs_h_matched_set pos 
solver.ml:      	  ###x_add heap_entail_conjunct 13 prog is_folding ctx_00 new_conseq rhs_h_matched_set pos
solver.ml:      	  ###x_add heap_entail_conjunct 13 prog is_folding ctx_00 new_conseq rhs_h_matched_set pos
solver.ml:      		let entail_p_ctx = ###x_add fold_context_left 1 entail_p_ctx in 
solver.ml:		      let res_ctx = ###x_add fold_context_left 2 res_ctx in
solver.ml:        ###x_add heap_entail_conjunct 14 prog is_folding (CF.set_context_formula ctx0 (func h2)) conseq rhs_h_matched_set pos in
solver.ml:	    (* in this case we directly call ###x_add heap_entail_conjunct *)
solver.ml:            let final_ctx, final_prf = ###x_add heap_entail_conjunct 15 prog is_folding new_ctx conseq rhs_h_matched_set pos in
solver.ml:	    x_dinfo_zp (lazy ("heap_entail_split_lhs: \ncall ###x_add heap_entail_conjunct with lhs = h1\n")) pos;
solver.ml:	    let (with_h1_ctx, with_h1_prf) = ###x_add heap_entail_conjunct 16 prog is_folding h1_ctx conseq rhs_h_matched_set pos in
solver.ml:		            ((###x_add fold_context_left [ctx1;ctx2]),(mkOrRight ctx0 conseq [prf1;prf2]))
solver.ml:	    ((###x_add fold_context_left 3 [with_h1_ctx; final_ctx]),( mkOrRight ctx0 conseq [with_h1_prf; final_prf]))		
solver.ml:		let res_ctx = ###x_add fold_context_left res_ctx in
solver.ml:        let tmp1 = List.map (fun c -> ###x_add heap_entail_one_context 3 prog is_folding c conseq None None None pos) cl in
solver.ml:        ((###x_add fold_context_left 4 tmp2), prf)
solver.ml:      else (###x_add heap_entail_one_context 4 prog is_folding (List.hd cl) conseq None None None pos)
solver.ml:and ###x_add heap_entail_one_context i prog is_folding ctx conseq (tid: CP.spec_var option) (delayed_f: MCP.mix_formula option) (join_id: CP.spec_var option) pos =
solver.ml:    (* WN : this false has been already tested in ###x_add heap_entail_one_context_struc and is thus redundant here *)
solver.ml:              (*         x_add ###x_add heap_entail_conjunct_lhs 1 prog is_folding  (Ctx es1) conseq pos *)
solver.ml:                       let rs,prf = x_add ###x_add heap_entail_conjunct_lhs 1 prog is_folding  (Ctx es1) conseq pos in
solver.ml:    let () = pr_hdebug (add_str "###x_add early_hp_contra_detection : " pr_id) "1" pos in
solver.ml:       let () = pr_hdebug (add_str "###x_add early_hp_contra_detection : " pr_id) "3" pos in
solver.ml:        let (r_inf_contr,real_c), relass = ###x_add solver_detect_lhs_rhs_contra 1 prog estate conseq pos "EARLY CONTRA DETECTION" in
solver.ml:                let () = pr_hdebug (add_str "###x_add early_hp_contra_detection : " pr_id) "..in Some" pos in
solver.ml:                let lhs_xpure,_,_ = x_add ###x_add xpure 2 prog estate.CF.es_formula in
solver.ml:                let lhs_p = MCP.pure_of_mix lhs_###x_add xpure in
solver.ml:                let rhs_xpure,_,_ = x_add ###x_add xpure 3 prog conseq in
solver.ml:                let p_rhs_xpure0 = MCP.pure_of_mix rhs_###x_add xpure in
solver.ml:                let p_rhs_###x_add xpure = Cputil.hloc_enum_to_symb p_rhs_xpure0 in
solver.ml:                (* let () = Debug.info_hprint (add_str "p_rhs_###x_add xpure : " ( (!CP.print_formula))) p_rhs_xpure pos in *)
solver.ml:                let pf,rele_p_rhs_###x_add xpure =
solver.ml:                    (* let rele_rhs_###x_add xpure = CP.###x_add filter_var p_rhs_xpure  orig_inf_vars in *)
solver.ml:                    let () = pr_hdebug (add_str "p_rhs_###x_add xpure : " ( (!CP.print_formula))) p_rhs_xpure pos in
solver.ml:                    (* let () = pr_hdebug (add_str "rele_rhs_###x_add xpure : " ( (!CP.print_formula))) rele_rhs_xpure pos in *)
solver.ml:                    (* if CP.isConstTrue rele_rhs_###x_add xpure then (pf,rele_rhs_xpure) else *)
solver.ml:                    let rele_rhs_###x_add xpure = CP.subst rele_sst p_rhs_xpure in
solver.ml:                  let () = Debug.ninfo_hprint (add_str "rele_p_rhs_xpure"  (!CP.print_formula)) rele_p_rhs_###x_add xpure pos in
solver.ml:                      let rele_p0 = CP.###x_add filter_var p_contr_lhs args in
solver.ml:                  Infer.add_infer_hp_contr_to_list_context hinf_args_map0 [pf] temp_ctx rele_p_rhs_###x_add xpure in
solver.ml:                let () = x_tinfo_hp (add_str "WARNING: ###x_add early_hp_contra_detection : " pr_id) "..in None" pos in
solver.ml:and ###x_add early_hp_contra_detection hec_num prog estate conseq pos = 
solver.ml:  let real_c,contra, es = ###x_add early_hp_contra_detection 1 prog estate conseq pos in
solver.ml:and ###x_add early_hp_contra_detection_add_to_list_context hec_num prog estate conseq pos = 
solver.ml:  let (r_inf_contr,real_c),relass = ###x_add solver_detect_lhs_rhs_contra 2 prog estate conseq pos msg  in
solver.ml:    | Some (new_estate,pf) -> (* if successful, should skip ###x_add infer_collect_hp_rel below *)
solver.ml:	    let ctx1 = (###x_add elim_unsat_es_now 6 prog (ref 1) new_estate) in
solver.ml:	    let r1, prf = ###x_add heap_entail_one_context 9 prog is_folding ctx1 conseq None None None pos in
solver.ml:            let rhs_xpure,_,_ = x_add ###x_add xpure 4 prog conseq in
solver.ml:            let p_rhs_###x_add xpure = MCP.pure_of_mix rhs_xpure in
solver.ml: 	    let r1 = Infer.add_infer_hp_contr_to_list_context hinf_args_map [pf] r1 p_rhs_###x_add xpure in
solver.ml:and ###x_add early_pure_contra_detection hec_num prog estate conseq pos msg is_folding =
solver.ml:and ###x_add heap_entail_conjunct_lhs hec_num prog is_folding  (ctx:context) conseq pos : (list_context * proof) =
solver.ml:            Context.M_###x_add unfold (mr,1)
solver.ml:	      let rs1, prf1 = x_add ###x_add heap_entail_conjunct_lhs 2 prog is_folding  ctx_L f1 pos in
solver.ml:	      let rs2, prf2 = x_add ###x_add heap_entail_conjunct_lhs 3 prog is_folding  ctx_R f2 pos in
solver.ml:	      ((###x_add fold_context_left 5 [rs1;rs2]),( mkOrRight ctx conseq [prf1; prf2]))
solver.ml:              let rs1, prf1 = x_add ###x_add heap_entail_conjunct_lhs 4 prog is_folding  ctx_L f1 pos in
solver.ml:	        let rs2, prf2 = x_add ###x_add heap_entail_conjunct_lhs 5 prog is_folding  ctx_R f2 pos in
solver.ml:                ###x_add heap_entail_conjunct 1 prog is_folding  ctx conseq [] pos
solver.ml:                      ###x_add early_hp_contra_detection_add_to_list_context hec_num prog estate conseq pos 
solver.ml:                let extract_pure f= let (mf,_,_) = x_add ###x_add xpure 5 prog f in Cputil.hloc_enum_to_symb (MCP.pure_of_mix mf)  in
solver.ml:                let lc = Musterr.###x_add build_and_failures 5 "early contra detect: "
solver.ml:	  if (CP.eq_spec_var h sv) && (String.compare (CF.###x_add get_node_name 17 (get_node sv lhs_heap)) (CF.get_node_name 18 (get_node h rhs_heap))) == 0 then
solver.ml:      ###x_add heap_entail_conjunct 2 prog is_folding ctx_00 conseq [] pos
solver.ml:	###x_add heap_n_pure_entail 1 prog is_folding  ctx_00 conseq h2 p func true pos
solver.ml:	      ###x_add heap_n_pure_entail 2 prog is_folding  ctx_00 conseq h1 p func false pos
solver.ml:	          ###x_add heap_n_pure_entail 3 prog is_folding  ctx_00  conseq (choose_not_empty_heap h1 h2 h3) p func (consume_heap new_conseq) (*drop_read_phase*) pos
solver.ml:		                ###x_add heap_entail_conjunct 3 prog is_folding  c new_conseq []  pos) cl 
solver.ml:	                let res_ctx = ###x_add fold_context_left 17 res_ctx in 
solver.ml:  print_string "tracing heap_n_pure_entail_1\n"; (###x_add heap_n_pure_entail prog is_folding  ctx0 conseq h p func drop_read_phase pos)
solver.ml:  print_string "tracing heap_n_pure_entail_2\n"; (###x_add heap_n_pure_entail prog is_folding  ctx0 conseq h p func drop_read_phase pos)
solver.ml:          let entail_p_ctx = ###x_add fold_context_left 6 entail_p_ctx in 
solver.ml:          let (ctx,prf) = ###x_add heap_entail_conjunct 4 prog is_folding  c new_conseq []  pos in
solver.ml:	          let after_wr_ctx = ###x_add fold_context_left 7 after_wr_ctx in 
solver.ml:		              let after_nested_phase_ctx = ###x_add fold_context_left 8 after_nested_phase_ctx in
solver.ml:		              let after_nested_phase_ctx = ###x_add fold_context_left 9 after_nested_phase_ctx in
solver.ml:	    (* in this case we directly call ###x_add heap_entail_conjunct *)
solver.ml:        let final_ctx, final_prf = ###x_add heap_entail_conjunct 5 prog is_folding  new_ctx conseq []  pos in
solver.ml:	          (* direct call to ###x_add heap_entail_conjunct *)
solver.ml:	          ###x_add heap_entail_conjunct 6 prog is_folding  new_ctx conseq [] pos
solver.ml:	      x_dinfo_zp (lazy ("heap_entail_split_lhs_phases: \ncall ###x_add heap_entail_conjunct with lhs = reading phase\n")) pos;
solver.ml:	      let (with_rd_ctx, with_rd_prf) = ###x_add heap_entail_conjunct 7 prog is_folding  rd_ctx conseq [] pos in
solver.ml:	      x_dinfo_zp (lazy ("heap_entail_split_lhs_phases: \ncall ###x_add heap_entail_conjunct with lhs = writing phase\n")) pos;
solver.ml:	      let (with_wr_ctx, with_wr_prf) = ###x_add heap_entail_conjunct 8 prog is_folding  wr_ctx conseq []  pos in
solver.ml:	      ((###x_add fold_context_left 10 [with_rd_ctx; final_ctx]),( mkOrRight ctx0 conseq [with_rd_prf; final_prf]))		
solver.ml:		              (x_dinfo_zp (lazy ("heap_entail_split_lhs_phases: \ncall ###x_add heap_entail_conjunct for the continuation\n")) pos;
solver.ml:		              ###x_add heap_entail_conjunct 9 prog is_folding  cont_ctx conseq [] pos)
solver.ml:	          ((###x_add fold_context_left 12 [ctx1; ctx2]),( mkOrRight ctx0 conseq [prf1; prf2]))		
solver.ml:              let rs0, prf0 = ###x_add heap_entail_conjunct_helper 1 prog true new_ctx base_f2 [] pos in (*is_folding = true to collect the pure constraints of the RHS to es_pure*)
solver.ml:and ###x_add heap_entail_conjunct hec_num (prog : prog_decl) (is_folding : bool)  (ctx0 : context) (conseq : formula)
solver.ml:    let ls, prf = ###x_add heap_entail_conjunct_helper 3 prog is_folding  ctx0 conseq rhs_matched_set pos in
solver.ml:and ###x_add heap_entail_conjunct_helper i (prog : prog_decl) (is_folding : bool)  (ctx0 : context) (conseq : formula)
solver.ml:              let rs, prf1 = ###x_add heap_entail_conjunct_helper 2 prog is_folding  new_ctx conseq rhs_h_matched_set pos in
solver.ml:                        let res,prf = ###x_add heap_entail_conjunct 10 prog is_folding ctx0 new_conseq rhs_h_matched_set pos in
solver.ml:                                (*###x_add simplify htrue in LHS*)
solver.ml:                                  let r, new_es = Infer.###x_add infer_collect_hp_rel_classsic 0 prog estate h2 pos in
solver.ml:                                    let ctx, proof =  ###x_add heap_entail_conjunct_helper 4 prog is_folding (Ctx new_es) conseq rhs_h_matched_set pos in
solver.ml:                                      let (res,new_estate, rels) = Infer.###x_add infer_collect_hp_rel_empty_rhs 1 prog estate p2 pos in
solver.ml:                                let ctx, proof = ###x_add heap_entail_empty_rhs_heap 1 prog conseq is_folding  estate b1 p2 rhs_h_matched_set pos in
solver.ml:  (* let () = print_string ("An Hoa :: ###x_add heap_entail_build_mix_formula_check :: INPUTS\n" ^ *)
solver.ml:and ###x_add heap_entail_build_mix_formula_check i (evars : CP.spec_var list) (ante : MCP.mix_formula) (conseq : MCP.mix_formula) pos : (MCP.mix_formula * MCP.mix_formula) =
solver.ml:  let new_ante, new_conseq = ###x_add heap_entail_build_mix_formula_check 1 (estate.es_evars@estate.es_gen_expl_vars@estate.es_gen_impl_vars@estate.es_ivars) tmp1
solver.ml:  let (res,_,_) = ###x_add imply_mix_formula_no_memo 1 new_ante new_conseq !imp_no !imp_subno (Some timeout) memset in
solver.ml:(*     let ###x_add is_sat f = TP.###x_add is_sat_sub_no 9 f r in *)
solver.ml:(*     let find_all_failures a c = CP.find_all_failures ###x_add is_sat a c in *)
solver.ml:(* and ###x_add build_and_failures i (failure_code:string) (failure_name:string) ((contra_list, must_list, may_list) *)
solver.ml:  (is_identical exp1 exp2) || let res,_,_ = TP.###x_add imply_one 27 eqctr (CP.mkEqExp exp1 exp2 no_pos) "" true None in res
solver.ml:  let lctx, _ = ###x_add heap_entail_empty_rhs_heap 2 prog conseq is_folding estate lhs (MCP.mix_of_pure rank) [] pos 
solver.ml:and ###x_add heap_entail_empty_rhs_heap i p conseq i_f es lhs rhs rhs_matched_set pos =
solver.ml:  (* if smart_###x_add xpure then try 0, then 1
solver.ml:  let cur_force_verbose_###x_add xpure = !force_verbose_xpure in
solver.ml:  (*for pure inference, we need return verbose ###x_add xpure to expose the disjunction:
solver.ml:    let () = force_verbose_###x_add xpure := true in ()
solver.ml:  let () = force_verbose_###x_add xpure := cur_force_verbose_xpure in
solver.ml:  let () = Globals.super_smart_###x_add xpure := !Globals.smart_xpure && diff_flag in
solver.ml:  let () = x_binfo_hp (add_str "super_smart_xpure" string_of_bool) !Globals.super_smart_###x_add xpure no_pos in
solver.ml:  let stk_inf_pure = new Gen.stack in (* of ###x_add xpure *)
solver.ml:  let stk_rel_ass = new Gen.stack in (* of ###x_add xpure *)
solver.ml:      (* TODO-EXPURE : need to build new e###x_add xpure stuff *)
solver.ml:      let (split_ante1, new_conseq1) as xx = ###x_add heap_entail_build_mix_formula_check 2 exist_vars tmp3 rhs_p pos in
solver.ml:      let (split_ante1_sym, _) as xx = ###x_add heap_entail_build_mix_formula_check 2 exist_vars tmp3_sym rhs_p pos in
solver.ml:      let (split_ante0_sym, _) as xx = ###x_add heap_entail_build_mix_formula_check 2 exist_vars tmp0_sym rhs_p pos in
solver.ml:        if (!Globals.super_smart_xpure) then ###x_add heap_entail_build_mix_formula_check 3 exist_vars tmp2 rhs_p pos
solver.ml:      (* let () = print_string ("An Hoa :: ###x_add heap_entail_empty_rhs_heap :: After heap_entail_build_mix_formula_check\n" ^ *)
solver.ml:      (* TODO: if ###x_add xpure 1 is needed, then perform the same simplifications as for xpure 0 *)
solver.ml:	    then memo_normalize_to_CNF_new (MCP.memo_arith_###x_add simplify new_conseq0) pos
solver.ml:                  let ((flag2,_,_),_) as r = ###x_add imply_mix_formula 1 split_ante0 split_ante1 split_conseq imp_no memset in
solver.ml:                  (###x_add imply_mix_formula 1 split_ante0 split_ante1 split_conseq imp_no memset) 
solver.ml:                  let n_es = ###x_add elim_unsat_es 11 prog (ref 1) estate in
solver.ml:                        (###x_add imply_mix_formula 0 ante ante split_conseq imp_no memset)
solver.ml:                                    fst (###x_add imply_mix_formula 2 split_ante0 split_ante1 split_conseq imp_no memset)
solver.ml:      let () = Debug.ninfo_pprint "if stk_estate > 1, can cause unsat_###x_add xpure exception" no_pos in
solver.ml:      let ctx1 = (###x_add elim_unsat_es_now 8 prog (ref 1) new_estate) in
solver.ml:		  Currently, we do not add the whole rhs_p into the residue.We only instatiate ivars and expl_vars in ###x_add heap_entail_conjunct_helper *)
solver.ml:      let ###x_add is_sat = CF.is_sat_fail cex in
solver.ml:                  | CF.Failure_May _ -> if ###x_add is_sat then
solver.ml:        let must_list1, may_list1 = if ###x_add is_sat then (must_list@may_list, []) else
solver.ml:        (Musterr.###x_add build_and_failures 1 "213" Globals.logical_error (contra_list, must_list1, may_list1) fc_template cex new_estate.es_trace, prf)
solver.ml:(* let () = print_string ("\nSolver.ml: ###x_add imply_mix_formula " ^ (string_of_int !imp_no)) in *)
solver.ml:  | MCP.MemoF a, _, MCP.MemoF c -> MCP.###x_add imply_memo a c TP.imply imp_no
solver.ml:and ###x_add imply_mix_formula i ante_m0 ante_m1 conseq_m imp_no memset =
solver.ml:  (* let () = print_string ("\nAn Hoa :: ###x_add imply_mix_formula ::\n" ^ *)
solver.ml:              let r1,r2,r3 = MCP.###x_add imply_memo 1 a c (TP.###x_add imply_one 27) imp_no in
solver.ml:                    | Some (MCP.MemoF a1) -> (MCP.###x_add imply_memo 2 a1 c (TP.###x_add imply_one 28) imp_no,None)
solver.ml:	          let ###x_add is_sat f = CP.is_sat_eq_ineq f (*TP.###x_add is_sat_sub_no 6 f r*) in
solver.ml:	          let a0l = List.filter ###x_add is_sat a0l in a0l
solver.ml:            let () = CP.store_tp_###x_add is_sat := (fun f -> TP.is_sat 77 f "store_tp_is_sat" true) in
solver.ml:	    (CP.imply_conj_orig (ante_m1==None) a0l a1l new_rhs (TP.###x_add imply_one 29) imp_no, extra_step)
solver.ml:and ###x_add imply_mix_formula_no_memo i new_ante new_conseq imp_no imp_subno timeout memset =   
solver.ml:      | None -> drop_last_item (###x_add imply_mix_formula 98 new_ante new_ante new_conseq xx memset)
solver.ml:      | Some t -> drop_last_item ( ###x_add imply_mix_formula 99 new_ante new_ante new_conseq xx memset ) 
solver.ml:  let res,_,_ = TP.###x_add imply_one 31  new_ante new_conseq ((string_of_int imp_no)) false None in
solver.ml:    (x_dinfo_zp (lazy ("do_base_case_###x_add unfold attempt for : " ^
solver.ml:    let lhs_name,lhs_arg,lhs_var = ###x_add get_node_name 19 lhs_node, get_node_args lhs_node , get_node_var lhs_node in
solver.ml:    let lhs_vd = (###x_add look_up_view_def_raw 7 prog.prog_view_decls lhs_name) in
solver.ml:        x_dinfo_zp (lazy ("do_base_case_###x_add unfold attempt : unsuccessful for : " ^
solver.ml:		        x_dinfo_zp (lazy ("do_base_case_###x_add unfold attempt : successful : " ^
solver.ml:                x_dinfo_zp (lazy ("do_base_case_###x_add unfold attempt : unsuccessful for : " ^
solver.ml:	  let do_fold_result,prf = ###x_add heap_entail_one_context 5 prog is_folding cx (CF.Base rhs_b) None None None pos in 
solver.ml:  let res = elim_unsat_for_###x_add unfold prog unfolded_f in
solver.ml:  let c1,v1,p1 = ###x_add get_node_name 20 lhs_node, get_node_args lhs_node , get_node_var lhs_node in
solver.ml:  let vd = (###x_add look_up_view_def_raw 8 prog.prog_view_decls c1) in
solver.ml:             let res_rs, prf1 = ###x_add heap_entail_one_context 6 prog is_folding ctx conseq None None None pos in
solver.ml:              let res_ctx, res_prf = ###x_add heap_entail_conjunct 11 prog is_folding new_ctx new_conseq rhs_matched_set pos in
solver.ml:          let vdef = Cast.###x_add look_up_view_def_raw 9 prog.prog_view_decls l_node_name in
solver.ml:              let l_vdef = Cast.###x_add look_up_view_def_raw 9 prog.prog_view_decls l_node_name in
solver.ml:                let f_ctx = ###x_add elim_unsat_es_now 13 prog (ref 1) f_es in
solver.ml:                    (fun v -> ###x_add heap_entail_conjunct 20 prog false f_ctx f_rhs [] pos) true 
solver.ml:                (*   let new_ctx = ###x_add elim_unsat_es_now 13 prog (ref 1) new_estate in                                                                          *)
solver.ml:                (*     | HO_NONE -> Wrapper.wrap_classic (Some true) (fun v -> ###x_add heap_entail_conjunct 20 prog false new_ctx rhs [] pos) true (* exact *)      *)
solver.ml:                (*     | HO_SPLIT -> Wrapper.wrap_classic (Some false) (fun v -> ###x_add heap_entail_conjunct 21 prog false new_ctx rhs [] pos) false (* inexact *) *)
solver.ml:              else ###x_add heap_entail_conjunct 11 prog is_folding new_ctx new_conseq (rhs_matched_set @ [r_var]) pos in
solver.ml:    let vdef = ###x_add look_up_view_def_raw 10 prog.Cast.prog_view_decls c2 in
solver.ml:  let res = (###x_add fold_context_left 13 [res_es1;res_es2]) in
solver.ml:    try ###x_add look_up_view_def_raw 6 prog.Cast.prog_view_decls vname
solver.ml:                (* ###x_add unfold rhs *)
solver.ml:                (* ###x_add unfold rhs *)
solver.ml:          let rest_rs, prf = ###x_add heap_entail_one_context 1 prog is_folding ctx0 n_conseq None None None pos in
solver.ml:  advance_###x_add unfold prog ctx (get_disj_struc conseq) 
solver.ml:and advance_###x_add unfold prog (ctx:context) (conseq:formula list) : (Context.action_wt) list =
solver.ml:	    Error.error_text = "advance_###x_add unfold : OCtx unexpected" }
solver.ml:    | Context.M_###x_add unfold ({Context.match_res_lhs_node=lhs_node},unfold_num) ->
solver.ml:    | _ -> report_error no_pos ("process_###x_add unfold - expecting just unfold operation")
solver.ml:    let lhs_xpure,_,_ = x_add ###x_add xpure 6 prog estate.es_formula in
solver.ml:    let rhs_xpure,_,_ = x_add ###x_add xpure 7 prog (formula_of_heap rhs no_pos) in
solver.ml:    (*    let lhs_###x_add xpure = MCP.pure_of_mix lhs_xpure in*)
solver.ml:    (*    let rhs_###x_add xpure = MCP.pure_of_mix rhs_xpure in*)
solver.ml:    (*    let fml = CP.mkAnd lhs_###x_add xpure rhs_xpure pos in*)
solver.ml:    let fml = MCP.merge_mems lhs_###x_add xpure rhs_xpure true in
solver.ml:	          let r1, prf = ###x_add heap_entail_one_context 7 prog is_folding ctx1 conseq None None None pos in
solver.ml:  (* let lhs_xpure,_,_,_ = x_add ###x_add xpure prog estate.es_formula in*)
solver.ml:  (* let r = Infer.###x_add infer_lhs_contra_estate estate lhs_###x_add xpure pos in*)
solver.ml:  (*      let ctx1 = (###x_add elim_unsat_es_now prog (ref 1) new_estate) in*)
solver.ml:  (* let r1, prf = ###x_add heap_entail_one_context prog is_folding ctx1 conseq None pos in *)
solver.ml:        if (not is_rel) && not(TP.###x_add is_sat_sub_no 7 rhs_p r) then
solver.ml:            let olc = Musterr.###x_add build_and_failures 3 "15.3 no match for rhs data node: "
solver.ml:and process_###x_add unfold prog estate conseq a is_folding pos has_post pid =
solver.ml:  let lhs_xpure,_,_ = x_add ###x_add xpure 8 prog temp_estate.es_formula in
solver.ml:  (* let lhs_xpure,_,_ = x_add ###x_add xpure prog estate.es_formula in *)
solver.ml:  (* let () = x_tinfo_hp (add_str "lhs_xpure" Cprinter.string_of_mix_formula ) lhs_###x_add xpure pos in *)
solver.ml:  (* call ###x_add infer_lhs_contra *)
solver.ml:    let p_lhs_###x_add xpure = MCP.pure_of_mix lhs_xpure in
solver.ml:    let rhs_xpure,_,_ = x_add ###x_add xpure 9 prog conseq in
solver.ml:    let () = Debug.ninfo_hprint (add_str "[solver_detect_lhs_rhs_contra_all]::  p_rhs_###x_add xpure 0: " Cprinter.string_of_mix_formula) rhs_xpure no_pos in
solver.ml:    let p_rhs_###x_add xpure = MCP.pure_of_mix rhs_xpure in
solver.ml:      (* Cpure.overapp_ptrs p_lhs_###x_add xpure *)
solver.ml:      p_lhs_###x_add xpure in  
solver.ml:    let contr, _ = Infer.detect_lhs_rhs_contra p_lhs_###x_add xpure p_rhs_xpure pos in
solver.ml:        (*sa/norm/zip-1e.slk: lhs_rhs_contra: ###x_add xpure lhs should consider the rhs (pairwaisecheck + neg produces imprecise result) *)
solver.ml:        let lhs_###x_add xpure = if (estate.CF.es_infer_vars_rel!=[] || estate.CF.es_infer_vars_hp_rel !=[]) (* && *)
solver.ml:        let () = Debug.ninfo_hprint (add_str "lhs_xpure" Cprinter.string_of_mix_formula) lhs_###x_add xpure no_pos in
solver.ml:        let r_inf_contr,relass = Infer.###x_add infer_lhs_contra_estate 4 estate lhs_###x_add xpure pos msg  in
solver.ml:          let contr_lst, rel = solver_infer_lhs_contra_list prog estate lhs_###x_add xpure pos msg in
solver.ml:and ###x_add solver_detect_lhs_rhs_contra_all i prog estate conseq pos msg =
solver.ml:  let (contr_lst,real_c), rel = ###x_add solver_detect_lhs_rhs_contra_all 1 prog estate conseq pos msg in
solver.ml:and ###x_add solver_detect_lhs_rhs_contra i prog estate conseq pos msg =
solver.ml:and solver_###x_add infer_lhs_contra estate lhs_###x_add xpure h_inf_args pos msg = 
solver.ml:  let r_inf_contr,relass = Infer.###x_add infer_lhs_contra_estate 4 new_estate lhs_###x_add xpure pos msg  in 
solver.ml:and solver_infer_lhs_contra_first_sat_x prog estate lhs_###x_add xpure pos msg =
solver.ml:            let rcontr,rel =  solver_###x_add infer_lhs_contra estate lhs_###x_add xpure h_inf_args pos msg in
solver.ml:and solver_infer_lhs_contra_first_sat prog estate lhs_###x_add xpure pos msg =
solver.ml:      (pr_pair (pr_option pr_es) (pr_list pr_3)) (fun _ _ -> solver_infer_lhs_contra_first_sat_x prog estate lhs_###x_add xpure pos msg ) estate lhs_xpure
solver.ml:and solver_infer_lhs_contra_list_x prog estate lhs_###x_add xpure pos msg =
solver.ml:  let rcontr,rel =  solver_###x_add infer_lhs_contra estate lhs_###x_add xpure h_inf_args pos msg in
solver.ml:                let np = (TP.###x_add simplify (CP.arith_simplify_new p)) in
solver.ml:and solver_infer_lhs_contra_list prog estate lhs_###x_add xpure pos msg =
solver.ml:      (pr_pair (pr_list pr_es) (pr_list pr_3)) (fun _ _ -> solver_infer_lhs_contra_list_x prog estate lhs_###x_add xpure pos msg ) estate lhs_xpure
solver.ml:		          let xpure_lhs, _, memset = x_add ###x_add xpure 11 prog (Base lhs_b) in
solver.ml:                  let split_ante,split_conseq = ###x_add heap_entail_build_mix_formula_check 4 exists_vars lhs_frac rhs_frac pos in
solver.ml:                        let res,_,_ = ###x_add imply_mix_formula_no_memo 2 split_ante split_conseq !imp_no !imp_subno None memset in
solver.ml:                if (right_ls) = [] then Context.M_###x_add unfold (new_m_res, unfold_num) else
solver.ml:              else Context.M_###x_add unfold (new_m_res, unfold_num)
solver.ml:                {estate with es_formula = CF.###x_add normalize 1 estate.es_formula (CF.formula_of_pure_formula init_pure pos) pos} 
solver.ml:      | Context.M_###x_add unfold ({Context.match_res_lhs_node=lhs_node},unfold_num) -> 
solver.ml:            (*let estate =  Infer.infer_for_###x_add unfold prog estate lhs_node pos in*)
solver.ml:              let res_rs, prf1 = ###x_add heap_entail_one_context 8 prog is_folding (prune_helper ctx1) (*ctx1*) conseq None None None pos in
solver.ml:      | Context.M_base_case_###x_add unfold {
solver.ml:                (* let new_es_formula = CF.###x_add normalize 1 estate.es_formula (CF.formula_of_pure_formula init_pure pos) pos in *)
solver.ml:                {estate with es_formula = CF.###x_add normalize 1 estate.es_formula (CF.formula_of_pure_formula init_pure pos) pos}
solver.ml:              | None -> (CF.mkFailCtx_in(Basic_Reason(mkFailContext "base_case_###x_add unfold failed" estate conseq (get_node_label rhs_node) pos
solver.ml:                    , CF.mk_failure_must "base case ###x_add unfold failed" Globals.sl_error, estate.es_trace)) (Ctx (convert_to_must_es estate)) (mk_cex true),NoAlias)
solver.ml:                let new_ante = CF.###x_add normalize 1 estate.es_formula (CF.formula_of_pure_formula init_pure pos) pos in
solver.ml:              {estate with es_formula = CF.###x_add normalize 1 estate.es_formula (CF.formula_of_pure_formula init_pure pos) pos} 
solver.ml:              find_coercions (###x_add get_node_name lhs_node) (get_node_name rhs_node) prog lhs_node rhs_node in*)
solver.ml:              let lhs_p,_,_ = ###x_add xpure 111 prog (Cformula.mkBase lhs_h lhs_p lhs_vp lhs_t lhs_fl lhs_a no_pos) in
solver.ml:	      let n_ctx = ###x_add elim_unsat_es_now 13 prog (ref 2) estate in
solver.ml:            (* let () =  Debug.info_pprint ">>>>>> Infer.###x_add infer_collect_hp_rel 1: infer_heap <<<<<<" pos in *)
solver.ml:	    (* let lhs_xpure,_,_ = x_add ###x_add xpure prog estate.es_formula in *)
solver.ml:            (* (\* call ###x_add infer_lhs_contra *\) *)
solver.ml:	    (*   let rhs_xpure,_,_ = x_add ###x_add xpure prog conseq in               *)
solver.ml:	    (*   let p_lhs_###x_add xpure = MCP.pure_of_mix lhs_xpure in *)
solver.ml:	    (*   let p_rhs_###x_add xpure = MCP.pure_of_mix rhs_xpure in *)
solver.ml:	    (*   let contr, _ = Inferer.detect_lhs_rhs_contra  p_lhs_###x_add xpure p_rhs_xpure no_pos in  *)
solver.ml:	    (*       Infer.###x_add infer_lhs_contra_estate 4 estate lhs_###x_add xpure pos msg  *)
solver.ml:              (*   let r_inf_contr,relass = ###x_add solver_detect_lhs_rhs_contra 2 prog estate conseq pos msg  in *)
solver.ml:              (*   | Some (new_estate,pf) -> (\* if successful, should skip ###x_add infer_collect_hp_rel below *\) *)
solver.ml:	      (*   	let ctx1 = (###x_add elim_unsat_es_now 6 prog (ref 1) new_estate) in *)
solver.ml:	      (*   	let r1, prf = ###x_add heap_entail_one_context 9 prog is_folding ctx1 conseq None None None pos in *)
solver.ml:              (* let ###x_add early_pure_contra_detection hec_num estate =  *)
solver.ml:              let (contra, _, lc, prf ) = ###x_add early_pure_contra_detection 13 prog estate conseq pos msg is_folding in
solver.ml:                  let (res,new_estate, n_lhs, n_es_heap_opt, oerror_es) = Infer.###x_add infer_collect_hp_rel 1 prog estate rhs rhs_rest rhs_h_matched_set lhs_b rhs_b pos in
solver.ml:                    CF.mk_failure_may ("Cannot infer: ###x_add infer_collect_hp_rel 3a") sl_error, estate.es_trace)) (Ctx (convert_to_may_es estate)) (mk_cex false), NoAlias)
solver.ml:                        ###x_add heap_entail_conjunct 28 prog is_folding new_ctx n_rhs_b (rhs_h_matched_set) pos
solver.ml:              let lhs_xpure,_,_ = x_add ###x_add xpure 12 prog estate.es_formula in
solver.ml:              (* let rhs_xpure,_,_,_ = x_add ###x_add xpure prog conseq in *)
solver.ml:              (* let r = Infer.###x_add infer_pure_m 3 estate lhs_###x_add xpure rhs_xpure pos in *)
solver.ml:              let lhs_alias = MCP.ptr_equations_with_null lhs_###x_add xpure in
solver.ml:                    let rhs_xpure,_,_ = x_add ###x_add xpure 13 prog conseq in
solver.ml:                    let p_lhs_###x_add xpure = MCP.pure_of_mix lhs_xpure in
solver.ml:                    let p_rhs_###x_add xpure = MCP.pure_of_mix rhs_xpure in
solver.ml:                    let contr, _ = Infer.detect_lhs_rhs_contra p_lhs_###x_add xpure p_rhs_xpure no_pos in
solver.ml:                  else Infer.###x_add infer_lhs_contra_estate 5 estate lhs_###x_add xpure pos msg 
solver.ml:                        let ctx1 = (###x_add elim_unsat_es_now 9 prog (ref 1) new_estate) in
solver.ml:                          let r1, prf = ###x_add heap_entail_one_context 9 prog is_folding ctx1 conseq None None None pos in
solver.ml:                        let ctx1 = (###x_add elim_unsat_es_now 10 prog (ref 1) new_estate) in
solver.ml:                        let r1, prf = ###x_add heap_entail_one_context 9 prog is_folding ctx1 conseq None None None pos in
solver.ml:                                      let lhs_xpure, _, _ = x_add ###x_add xpure_symbolic 20 prog estate.es_formula in
solver.ml:                                    ###x_add heap_entail_conjunct 18 prog is_folding new_ctx new_rhs_base (rhs_h_matched_set @ [v]) pos
solver.ml:                            ###x_add heap_entail_conjunct 19 prog is_folding new_ctx new_rhs_base (rhs_h_matched_set @ [v]) pos
solver.ml:                              let (res,new_estate,n_lhs, n_es_heap_opt, oerror_es) = Infer.###x_add infer_collect_hp_rel 2 prog estate rhs rhs_rest rhs_h_matched_set lhs_b rhs_b pos in
solver.ml:                                CF.mk_failure_may ("Cannot infer: ###x_add infer_collect_hp_rel 3b") sl_error, estate.es_trace))
solver.ml:                                    ###x_add heap_entail_conjunct 28 prog is_folding new_ctx n_rhs_b (rhs_h_matched_set) pos
solver.ml:                          let ctx1 = (###x_add elim_unsat_es_now 11 prog (ref 1) h1) in
solver.ml:                          let r1, prf = ###x_add heap_entail_one_context 9 prog is_folding ctx1 conseq None None None pos in
solver.ml:		(*let xpure_lhs = x_add ###x_add xpure prog f in*)
solver.ml:		let new_conseq = ###x_add normalize 9 conseq formula pos in
solver.ml:		  let xpure_lhs, _, memset = x_add ###x_add xpure 14 prog f in
solver.ml:		  (* is it necessary to ###x_add xpure (node * f) instead ? *)
solver.ml:		    (*if ((fun (c1,_,_)-> c1) (TP.###x_add imply_one 99 xpure_lhs lhs_guard_new (string_of_int !imp_no) false)) then*)
solver.ml:		            let f0 = ###x_add normalize 10 f (formula_of_heap node pos) pos in
solver.ml:		            let f1 = ###x_add normalize 11 f0 (formula_of_mix_formula (MCP.mix_of_pure neg_guard) pos) pos in
solver.ml:			    (* ###x_add unfold the case with the negation of the guard. *)
solver.ml:		            let f2 = ###x_add normalize 12 f0 (formula_of_mix_formula (MCP.mix_of_pure lhs_guard_new) pos) pos in
solver.ml:  let c1 = ###x_add get_node_name 21 anode in
solver.ml:  let c2 = ###x_add get_node_name 22 ln2 in
solver.ml:      let r1 = List.map (fun (c,p) -> (###x_add fold_context_left 14 c,p)) lst in
solver.ml:      let res = ###x_add fold_context_left 15 r2 in
solver.ml:      (* ###x_add unfold by removing LHS head anode, and replaced with rhs_b into new_lhs to continue *)
solver.ml:	            let rest_rs, prf = ###x_add heap_entail_one_context 10 prog is_folding new_ctx conseq None None None pos in
solver.ml:	            let t1 = ###x_add fold_context_left 16 t1 in
solver.ml:(* ###x_add normalize a formula using normalization lemma                   *)
solver.ml:          (* so far, could not find any entailment -> can not ###x_add normalize *)
solver.ml:                          (*restart and ###x_add normalize the new estate*)
solver.ml:and ###x_add normalize_formula_w_coers i prog estate (f:formula) (coers:coercion_decl list): formula =
solver.ml:  let n_form f = ###x_add normalize_formula_w_coers 4 prog estate f coers in
solver.ml:        let h_name = ###x_add get_node_name 23 h in
solver.ml:              let x_name = ###x_add get_node_name 24 x in
solver.ml:(* ###x_add normalize a formula using propagation lemma *)
solver.ml:and ###x_add prop_formula_w_coers i prog estate (f: formula) (coers: coercion_decl list): formula =
solver.ml:(*                         let vd = ###x_add look_up_view_def_raw 13 prog.prog_view_decls vn.F.h_formula_view_name in *)
solver.ml:        let view_for_###x_add unfold = Norm.norm_formula_for_unfold prog vd in
solver.ml:        let vd = view_for_###x_add unfold in
solver.ml:		                                                                                                   Ex. x = 1 + 0 --> ###x_add simplify to x = 1
solver.ml:  CF.Ctx {es with CF.es_formula = ###x_add normalize_formula_w_coers 5 prog tmp_es es.CF.es_formula 
solver.ml:  CF.Ctx {es with CF.es_formula = ###x_add prop_formula_w_coers 5 prog tmp_es es.CF.es_formula 
solver.ml:      ###x_add heap_entail_one_context 11 prog is_folding  ctx conseq tid delayed_f join_id pos
solver.ml:let ###x_add heap_entail_struc_list_failesc_context_init (prog : prog_decl) (is_folding : bool)  (has_post: bool)
solver.ml:  let res,prf = ###x_add heap_entail_failesc_prefix_init 1 prog is_folding  has_post cl conseq tid delayed_f join_id pos pid (rename_labels_struc,Cprinter.string_of_struc_formula,(heap_entail_one_context_struc_nth 2)) in
solver.ml:  (CF.list_failesc_context_###x_add simplify res,prf)
solver.ml:let ###x_add heap_entail_struc_list_failesc_context_init i (prog : prog_decl) (is_folding : bool)  (has_post: bool)
solver.ml:  let slk_entail cl conseq = ###x_add heap_entail_struc_list_failesc_context_init prog is_folding has_post cl conseq tid delayed_f join_id pos pid
solver.ml:	(fun _ _ -> ###x_add heap_entail_struc_list_failesc_context_init prog is_folding has_post cl conseq tid delayed_f join_id pos pid) cl conseq
solver.ml:    let (lfc,prf) = ###x_add heap_entail_failesc_prefix_init 2 prog is_folding  false norm_cl conseq tid delayed_f join_id pos pid (rename_labels_formula ,Cprinter.string_of_formula,heap_entail_one_context_new) in
solver.ml:(* TODO : what is this verify_pre_###x_add is_sat verification for? *)
solver.ml:let rec verify_pre_###x_add is_sat prog fml = match fml with
solver.ml:        let fml,_,_ = x_add ###x_add xpure 15 prog fml 
solver.ml:    in verify_pre_###x_add is_sat prog fml
solver.ml:let verify_pre_###x_add is_sat prog fml = 
solver.ml:      (fun _ -> verify_pre_###x_add is_sat prog fml) fml
solver.ml:let () = Ti2.###x_add unsat_base_nth := unsat_base_nth
solver.ml:(*    let mix_h,_,_,_ = x_add ###x_add xpure prog (formula_of_heap h no_pos) in*)
solver.ml:(*       let p = TP.###x_add simplify (CP.mkExists post_vars p None no_pos) in *)
solver.ml:(*           let xpure_base,_,_ = x_add ###x_add xpure prog b.formula_struc_base in *)
solver.ml:(*         simplify_pre (CF.###x_add normalize 1 b.formula_struc_base (CF.formula_of_pure_formula pre no_pos) no_pos) lst_assume *)
solver.ml:(*     let pre_rec = TP.###x_add simplify fml in *)
solver.ml:(*     let final_pre = TP.###x_add simplify final_pre in *)
solver.ml:(*       let pre = TP.###x_add simplify pre in *)
solver.ml:(* (\*          (###x_add imply_mix_formula 3 f1 f1 f2 imp_no {mem_formula_mset = []}) in*\) *)
solver.ml:(*           let _,_,l = Infer.###x_add infer_pure_m 3 [] es f1 f1 f1 f2 no_pos in *)
solver.ml:			let hn,t = ###x_add get_node_name (List.hd l), List.tl l in
solver.ml:			List.exists (fun c -> (String.compare hn (###x_add get_node_name c))<>0) t) h_alias_grp in
spass.ml:      let res = Procutils.PrvComms.###x_add maybe_raise_timeout fnc () timeout in
spass.ml:        let res = Procutils.PrvComms.###x_add maybe_raise_timeout fnc input timeout in
spass.ml:    (* We don't have conseq part in ###x_add is_sat checking *)
spass.ml:  let omega_ante = Omega.###x_add omega_of_formula ante in
spass.ml:  let omega_conseq = Omega.###x_add omega_of_formula conseq in
spass.ml:  let omega_temp_str = Omega.###x_add omega_of_formula omega_temp_f in
spass.ml:      (* let fomega_ante = Omega.###x_add omega_of_formula ante in
spass.ml:      let fomega_conseq = Omega.###x_add omega_of_formula conseq in
spass.ml:let spass_###x_add is_sat (f : Cpure.formula) (sat_no : string) timeout : bool =
spass.ml:      (* let fomega = Omega.###x_add omega_of_formula f in
spass.ml:let spass_###x_add is_sat (f : Cpure.formula) (sat_no : string) : bool =
spass.ml:  spass_###x_add is_sat f sat_no spass_timeout_limit
spass.ml:let spass_###x_add is_sat (f : Cpure.formula) (sat_no : string) : bool =
spass.ml:  let result = Debug.no_1 "spass_is_sat" pr string_of_bool (fun _ -> spass_###x_add is_sat f sat_no) f in
spass.ml:  (* let omega_result = Omega.###x_add is_sat f sat_no in
spass.ml:  let () = print_endline ("-- spass_###x_add is_sat result: " ^ (if result then "TRUE" else "FALSE")) in
spass.ml:  let () = print_endline ("-- Omega.###x_add is_sat result: " ^ (if omega_result then "TRUE" else "FALSE")) in *)
spass.ml:let ###x_add is_sat (f: Cpure.formula) (sat_no: string) : bool =
spass.ml:  let result = spass_###x_add is_sat f sat_no in
spass.ml:  (* let () = print_endline ("-- ###x_add is_sat result: " ^ (if result then "true" else "false")) in *)
spass.ml:  Cpure.do_with_check "" (fun x -> ###x_add is_sat x sat_no) pe
spass.ml:(* let ###x_add is_sat f sat_no = Debug.loop_2_no "is_sat" (!print_pure) (fun x->x) *)
spass.ml:(* string_of_bool ###x_add is_sat f sat_no                                          *)
spass.ml:let ###x_add is_sat (pe : Cpure.formula) (sat_no: string) : bool =
spass.ml:    ###x_add is_sat pe sat_no;
spass.ml:    print_endline_quiet ("Apply Spass.###x_add is_sat on formula :" ^ (Cprinter.string_of_pure_formula pe));
spass.ml:let ###x_add simplify (f: Cpure.formula) : Cpure.formula =
spass.ml:  try (Omega.###x_add simplify f) with _ -> f
spass.ml:let ###x_add simplify (pe : Cpure.formula) : Cpure.formula =
spass.ml:  match (Cpure.do_with_check "" ###x_add simplify pe) with
syn_checkeq.ml:     let b1,_,_ = TP.###x_add imply_one 3 p1 p2 "sa:checkeq_pure" true None in
syn_checkeq.ml:      let b2,_,_ = TP.###x_add imply_one 4 p2 p1 "sa:checkeq_pure" true None in
terminf.ml:  let rec_cond = mkExists_with_simpl idf (* TP.###x_add simplify *) 
terminf.ml:    let (r, _, _) = TP.###x_add imply_one 0 ante cons "0" true None in r 
term.ml:(* To syntactically ###x_add simplify LexVar formula *) 
term.ml:          (* TODO: rhs_p & rhs_p_br & ###x_add heap_entail_build_mix_formula_check 5 pos & rank_formula(I,O) *)
term.ml:              let res, _, _ = Tpdispatcher.###x_add imply_one 30 lhs rank_formula "" false None 
term.ml:            x_dinfo_zp (lazy ("LHS (###x_add xpure 0): " ^ (Cprinter.string_of_mix_formula xpure_lhs_h0))) pos;
term.ml:            x_dinfo_zp (lazy ("LHS (###x_add xpure 1): " ^ (Cprinter.string_of_mix_formula xpure_lhs_h1))) pos;
term.ml:                    let res, _, _ = Tpdispatcher.###x_add imply_one 31 lhs bnd_formula "" false None 
ti2.ml:let om_###x_add simplify f = (* Omega.simplify *) (* Tpdispatcher.simplify_raw *)
ti2.ml:  if CP.is_linear_formula f then Omega.###x_add simplify f
ti2.ml:  else Redlog.###x_add simplify f
ti2.ml:let ###x_add simplify f args = 
ti2.ml:    CP.mkExists_with_simpl om_###x_add simplify (* Tpdispatcher.simplify_raw *)
ti2.ml:let ###x_add simplify num f args =
ti2.ml:    (fun _ _ -> ###x_add simplify f args) f args
ti2.ml:let ###x_add is_sat f = 
ti2.ml:  let f = om_###x_add simplify f in
ti2.ml:  List.filter ###x_add is_sat fs
ti2.ml:let ###x_add unsat_base_nth = ref (fun _ _ _ _ -> true) (* Solver.unsat_base_nth *)
ti2.ml:let f_###x_add is_sat prog f =
ti2.ml:  not (!###x_add unsat_base_nth 1 prog (ref 0) f)
ti2.ml:        if not (###x_add is_sat (mkAnd c d)) then d::(helper c ds)
ti2.ml:    if ###x_add is_sat rem_cond then CP.split_disjunctions (om_###x_add simplify rem_cond)
ti2.ml:  (* let rem_cond_lst = List.filter ###x_add is_sat (CP.split_disjunctions (om_###x_add simplify rem_cond)) in *)
ti2.ml:  (List.map om_###x_add simplify disj_cond_lst) @ rem_cond_lst
ti2.ml:  let rem_cond_lst = List.filter (fun c -> ###x_add is_sat (mkAnd ctx c)) 
ti2.ml:    (CP.split_disjunctions (om_###x_add simplify rem_cond))
ti2.ml:  in (List.map om_###x_add simplify disj_cond_lst) @ rem_cond_lst
ti2.ml:        if ###x_add is_sat mc then fac @ [(mc, ff)]
ti2.ml:    (###x_add is_sat (mkAnd c turel.call_ctx)) &&
ti2.ml:        let turel = List.find (fun tur -> ###x_add is_sat (mkAnd c tur.call_ctx)) turels in
ti2.ml:        let nctx = CF.###x_add normalize 16 ctx b pos in
ti2.ml:          if f_###x_add is_sat prog nctx then (c, merge_tnt_case_spec_into_assume prog ctx s af)
ti2.ml:        if ###x_add is_sat mc then fac @ [(mc, ff)]
ti2.ml:      List.map (fun (c, f) -> (om_###x_add simplify c, f)) ec.CF.formula_case_branches }
ti2.ml:    let should_###x_add simplify = (List.length scc_edges <= 1) in
ti2.ml:        let icond = om_###x_add simplify icond in
ti2.ml:        if ###x_add is_sat (mkAnd ante icond)
ti2.ml:          Some (###x_add simplify 1 (mkAnd abd_ante abd_conseq) args)
ti2.ml:          (* let neg_icond = ###x_add simplify 1 (mkAnd abd_ante (mkNot abd_conseq)) args in                    *)
ti2.ml:    (*       if ###x_add is_sat (mkAnd abd_ctx icond) then                                               *)
ti2.ml:          if (###x_add is_sat (mkAnd eh_ctx c)) then
ti2.ml:      if not (###x_add is_sat eh_ctx) then []
ti2.ml:            if (###x_add is_sat (mkAnd eh_ctx c)) then
ti2.ml:    let cond = ###x_add simplify 2 trel.call_ctx params in
ti2.ml:  | _ -> Some (mkNot (###x_add simplify 3 ante params))
ti2.ml:  if not (###x_add is_sat eh_ctx) then 
ti2.ml:    ###x_add simplify 10 btr.ret_ctx btr.termr_rhs_params) base_trrels in
ti2.ml:  let rec_ctx = ###x_add simplify 11 rec_trrel.ret_ctx rec_trrel.termr_rhs_params in
ti2.ml:  List.exists (fun bctx -> ###x_add is_sat (mkAnd rec_ctx bctx)) base_ctx
ti2.ml:        (###x_add is_sat (mkAnd c cond)) && not (imply cond c)) full_disj_ic_list in
ti2.ml:      let term_conds = List.map (fun f -> ###x_add simplify 6 f params) term_conds in
ti2.ml:      (* let term_conds = List.filter (fun c -> ###x_add is_sat (mkAnd eh_ctx c)) term_conds in *)
ti.ml:  let rec_cond = ###x_add simplify 4 rtr.ret_ctx rtr.termr_rhs_params in
ti.ml:      if ###x_add is_sat oc then (* Recursive case and base case are overlapping *)
ti.ml:        if ###x_add is_sat nbc then (mkAnd (mkNot bc) rc, (Base nbc)::(MayTerm oc)::ca)
ti.ml:      if ###x_add is_sat oc then (mkAnd (mkNot mc) rc, cond::ca)
ti.ml:      if ###x_add is_sat oc then 
ti.ml:        if ###x_add is_sat nrc then (mkAnd (mkNot other_rc) rc, (Rec oc)::(Rec nrc)::ca)
ti.ml:  if ###x_add is_sat rec_cond then (Rec rec_cond)::conds
ti.ml:  let base_cond = ###x_add simplify 5 btr.ret_ctx btr.termr_rhs_params in
ti.ml:  if List.exists (fun r -> ###x_add is_sat (mkAnd base_cond r.call_ctx)) turels 
ti.ml:    ###x_add simplify 7 btr.ret_ctx btr.termr_rhs_params) base_trrels in
ti.ml:    let ctx = ###x_add simplify 9 tu.call_ctx params in
ti.ml:  let not_term_cond = om_###x_add simplify not_term_cond in
ti.ml:  let base_cond = if ###x_add is_sat base_cond then [Base base_cond] else [] in
ti.ml:  (*   let may_cond = if ###x_add is_sat may_cond then [MayTerm may_cond] else [] in  *)
ti.ml:    let rec_cond = ###x_add simplify 4 rtr.ret_ctx rtr.termr_rhs_params in
ti.ml:    if ###x_add is_sat rec_cond then acc @ [rec_cond] else acc) [] rec_trrels 
ti.ml:      let loop_cond = ###x_add simplify 10 tu.call_ctx params in
ti.ml:      if ###x_add is_sat loop_cond then acc @ [loop_cond] else acc
ti.ml:      let rec_conds = om_###x_add simplify (CP.join_disjunctions rec_conds) in
ti.ml:  (* let may_cond = om_###x_add simplify (mkNot (join_disjs (List.map get_cond conds))) in *)
ti.ml:  (* if (###x_add is_sat may_cond) && not !Globals.tnt_infer_lex then                      *)
ti.ml:  let rem_cond = om_###x_add simplify (mkNot (join_disjs (List.map get_cond conds))) in
ti.ml:    let cond = ###x_add simplify 11 tu.call_ctx params in
ti.ml:  let unk_cond = om_###x_add simplify (mkAnd pre_cond rem_cond) in
ti.ml:  let may_cond = om_###x_add simplify (mkAnd rem_cond (mkNot unk_cond)) in 
ti.ml:  (if ###x_add is_sat unk_cond then [Rec unk_cond] else []) @
ti.ml:  (if ###x_add is_sat may_cond then [Rec may_cond] else [])
ti.ml:        let fs_rconds = List.filter (fun (_, c) -> ###x_add is_sat (mkAnd eh_ctx c)) rcond_w_ids in
ti.ml:        let fs_rconds = List.filter (fun (_, c) -> ###x_add is_sat (mkAnd eh_ctx (get_cond c))) subst_cond_w_ids in
tlutils.ml:let ###x_add is_sat f = 
tlutils.ml:  (* Tpdispatcher.###x_add is_sat_sub_no 0 f (ref 0)  *)
tlutils.ml:    let ###x_add is_sat = is_sat (join_conjunctions v_zero_asserts) in 
tlutils.ml:  ###x_add is_sat (join_conjunctions subst_asserts)
tlutils.ml:(* We should not ###x_add simplify when inferring ranking *)
tlutils.ml:let subst_model_to_exp should_###x_add simplify sst e =
tlutils.ml:    if should_###x_add simplify then
tlutils.ml:   * (x1, x2) and (x2, x1) have been removed by ###x_add simplify *)
tpdispatcher.ml:    (* method private ###x_add add_to_context assertion: unit = *)
tpdispatcher.ml:(* this is to ###x_add normalize result from simplify/hull/gist *)
tpdispatcher.ml:    then let f =  (*CP.arith_###x_add simplify 13*) (Infinity.convert_var_to_inf f) in
tpdispatcher.ml:  let rec ###x_add simplify f0 vnames = match f0 with
tpdispatcher.ml:        let nf1 = ###x_add simplify f1 vnames in
tpdispatcher.ml:        let nf1 = ###x_add simplify f1 vnames in
tpdispatcher.ml:        let nf1 = ###x_add simplify f1 vnames in
tpdispatcher.ml:        let nf2 = ###x_add simplify f2 vnames in
tpdispatcher.ml:	| CP.AndList b -> CP.AndList (map_l_snd (fun c -> ###x_add simplify c vnames) b)
tpdispatcher.ml:        let nf1 = ###x_add simplify f1 vnames in
tpdispatcher.ml:        let nf2 = ###x_add simplify f2 vnames in
tpdispatcher.ml:        CP.Not (###x_add simplify f1 vnames, lbl, l)
tpdispatcher.ml:  let ###x_add simplify f0 vnames = 
tpdispatcher.ml:    Debug.no_1 "simplify-syn" pr (* pr_hashtbl *) pr (fun _ -> ###x_add simplify f0 vnames) f0 (* vnames *)
tpdispatcher.ml:  let ###x_add simplify f0 =  simplify f0  (Hashtbl.create 100) in
tpdispatcher.ml:  let ###x_add simplify f0 = wrap_pre_post norm_pure_input norm_pure_result simplify f0 in
tpdispatcher.ml:  ###x_add simplify e (* (Hashtbl.create 100) *)
tpdispatcher.ml:  let omega_###x_add is_sat f = Omega.is_sat_ops pr_weak pr_strong f sat_no in
tpdispatcher.ml:  let redlog_###x_add is_sat f = wrap_redlog (Redlog.is_sat_ops pr_weak pr_strong f) sat_no in
tpdispatcher.ml:  let ocredlog_###x_add is_sat f = wrap_ocredlog (Redlog.is_sat_ops pr_weak pr_strong f) sat_no in
tpdispatcher.ml:  let mathematica_###x_add is_sat f = Mathematica.is_sat_ops pr_weak pr_strong f sat_no in
tpdispatcher.ml:  let mona_###x_add is_sat f = Mona.is_sat_ops pr_weak pr_strong f sat_no in
tpdispatcher.ml:  let coq_###x_add is_sat f = Coq.is_sat_ops pr_weak pr_strong f sat_no in
tpdispatcher.ml:  let z3_###x_add is_sat f = Smtsolver.is_sat_ops pr_weak_z3 pr_strong_z3 f sat_no in
tpdispatcher.ml:  let z3n_###x_add is_sat f = Z3.is_sat_ops_cex pr_weak_z3 pr_strong_z3 f sat_no in
tpdispatcher.ml:        let r = Dp.###x_add is_sat f sat_no in
tpdispatcher.ml:          (* let r2 = Smtsolver.###x_add is_sat f sat_no in *)
tpdispatcher.ml:          let r2 = z3_###x_add is_sat f in
tpdispatcher.ml:        if (CP.is_float_formula wf) then (redlog_###x_add is_sat wf)
tpdispatcher.ml:        else (omega_###x_add is_sat f);
tpdispatcher.ml:    | CvcLite -> Cvclite.###x_add is_sat f sat_no
tpdispatcher.ml:          | _ -> Cvc3.###x_add is_sat f sat_no
tpdispatcher.ml:    | Z3 -> z3_###x_add is_sat f
tpdispatcher.ml:    | Z3N -> z3n_###x_add is_sat f
tpdispatcher.ml:    | Isabelle -> Isabelle.###x_add is_sat wf sat_no
tpdispatcher.ml:        if (is_list_constraint wf) then (coq_###x_add is_sat wf)
tpdispatcher.ml:        else (Smtsolver(*Omega*).###x_add is_sat f sat_no);
tpdispatcher.ml:    | Mona | MonaH -> mona_###x_add is_sat wf
tpdispatcher.ml:                  (omega_###x_add is_sat f)
tpdispatcher.ml:        if (is_bag_constraint wf) then (mona_###x_add is_sat wf)
tpdispatcher.ml:                      (omega_###x_add is_sat f)
tpdispatcher.ml:        if (is_bag_constraint wf) then (mona_###x_add is_sat wf)
tpdispatcher.ml:        else (omega_###x_add is_sat f)
tpdispatcher.ml:        if (is_bag_constraint wf) then (mona_###x_add is_sat wf)
tpdispatcher.ml:        else if (is_list_constraint wf) then (coq_###x_add is_sat wf)
tpdispatcher.ml:        else if (is_array_constraint f) then (z3_###x_add is_sat f)
tpdispatcher.ml:        else (omega_###x_add is_sat f)
tpdispatcher.ml:        if (is_array_constraint f) then (z3_###x_add is_sat f)
tpdispatcher.ml:        else (omega_###x_add is_sat f)
tpdispatcher.ml:        if (is_bag_constraint wf) then (Isabelle.###x_add is_sat wf sat_no)
tpdispatcher.ml:        else (omega_###x_add is_sat f)
tpdispatcher.ml:    | SetMONA -> Setmona.###x_add is_sat wf
tpdispatcher.ml:    | Redlog -> redlog_###x_add is_sat wf
tpdispatcher.ml:    | OCRed -> ocredlog_###x_add is_sat wf
tpdispatcher.ml:    | Mathematica -> mathematica_###x_add is_sat wf
tpdispatcher.ml:          let b1 = mona_###x_add is_sat f_no_float in
tpdispatcher.ml:          let b2 = redlog_###x_add is_sat f_no_bag in
tpdispatcher.ml:            mona_###x_add is_sat wf
tpdispatcher.ml:            redlog_###x_add is_sat wf
tpdispatcher.ml:            let b1 = mona_###x_add is_sat f_no_float_rel in
tpdispatcher.ml:            let b2 = redlog_###x_add is_sat f_no_bag_rel in
tpdispatcher.ml:            let b3 = z3_###x_add is_sat f_no_float_bag in
tpdispatcher.ml:            let b =  z3_###x_add is_sat f_no_float_no_bag in
tpdispatcher.ml:            let b1 = mona_###x_add is_sat f_no_float_bag_only in
tpdispatcher.ml:            (* let b1 = mona_###x_add is_sat f_no_float in *)
tpdispatcher.ml:            let b2 = redlog_###x_add is_sat f_no_bag in
tpdispatcher.ml:            z3_###x_add is_sat f
tpdispatcher.ml:            (mona_###x_add is_sat bag_f && z3_is_sat no_bag_f)
tpdispatcher.ml:            redlog_###x_add is_sat f
tpdispatcher.ml:            z3_###x_add is_sat f
tpdispatcher.ml:        if (is_bag_constraint wf) then mona_###x_add is_sat wf
tpdispatcher.ml:        else z3_###x_add is_sat wf
tpdispatcher.ml:    | SPASS -> Spass.###x_add is_sat f sat_no
tpdispatcher.ml:    | MINISAT -> Minisat.###x_add is_sat f sat_no
tpdispatcher.ml:    Omega.###x_add is_sat f sat_no 
tpdispatcher.ml:let sat_cache ###x_add is_sat (f:CP.formula) : bool  = 
tpdispatcher.ml:        let r = ###x_add is_sat f in
tpdispatcher.ml:let sat_cache ###x_add is_sat (f:CP.formula) : bool = 
tpdispatcher.ml:let tp_###x_add is_sat (f:CP.formula) (old_sat_no :string) = 
tpdispatcher.ml:  (* let _ = print_endline ("tp_###x_add is_sat After drop: "^(Cprinter.string_of_pure_formula f)) in *)
tpdispatcher.ml:let tp_###x_add is_sat f sat_no =
tpdispatcher.ml:      (fun f -> tp_###x_add is_sat f sat_no) f
tpdispatcher.ml:(* let tp_###x_add is_sat (f: CP.formula) (sat_no: string) do_cache = *)
tpdispatcher.ml:(*   Debug.no_1 "tp_is_sat" pr string_of_bool (fun _ -> tp_###x_add is_sat f sat_no do_cache) f *)
tpdispatcher.ml:let om_###x_add simplify f =
tpdispatcher.ml:      Omega.###x_add simplify f
tpdispatcher.ml:  (* let r = Omega.###x_add simplify f in *)
tpdispatcher.ml:let om_###x_add simplify f=
tpdispatcher.ml:  Translate_out_array_in_cpure_formula.split_and_combine om_###x_add simplify Translate_out_array_in_cpure_formula.can_be_simplify f
tpdispatcher.ml:let om_###x_add simplify f =
tpdispatcher.ml:  Debug.no_1 "simplify_omega" pr pr om_###x_add simplify f
tpdispatcher.ml:    let simp_f = om_###x_add simplify f in
tpdispatcher.ml:(*   else Omega.###x_add simplify f    *)
tpdispatcher.ml:let ###x_add simplify (f : CP.formula) : CP.formula =
tpdispatcher.ml:      let omega_###x_add simplify f = simplify_omega f
tpdispatcher.ml:        (* Omega.###x_add simplify f  *)in
tpdispatcher.ml:      let z3_###x_add simplify f =
tpdispatcher.ml:        let f = wrap_pre_post norm_pure_input norm_pure_result Smtsolver.###x_add simplify f in
tpdispatcher.ml:        CP.arith_###x_add simplify 13 f
tpdispatcher.ml:      let z3n_###x_add simplify f =
tpdispatcher.ml:        let f = wrap_pre_post norm_pure_input norm_pure_result Z3.###x_add simplify f in
tpdispatcher.ml:        CP.arith_###x_add simplify 13 f
tpdispatcher.ml:(*      let redlog_###x_add simplify f =  wrap_pre_post norm_pure_input norm_pure_result Redlog.simplify f in
tpdispatcher.ml:      let mona_###x_add simplify f =  wrap_pre_post norm_pure_input norm_pure_result Mona.simplify f in *)
tpdispatcher.ml:                  | DP -> Dp.###x_add simplify f
tpdispatcher.ml:                  | Isabelle -> Isabelle.###x_add simplify f
tpdispatcher.ml:                          (Coq.###x_add simplify f)
tpdispatcher.ml:                        else ((*Omega*)Smtsolver.###x_add simplify f)
tpdispatcher.ml:                          (Mona.###x_add simplify f)
tpdispatcher.ml:                          let f=(omega_###x_add simplify f1) in
tpdispatcher.ml:                          CP.arith_###x_add simplify 12 f
tpdispatcher.ml:                        if (is_bag_constraint f) then (Mona.###x_add simplify f)
tpdispatcher.ml:                          let f=(omega_###x_add simplify f) in
tpdispatcher.ml:                          CP.arith_###x_add simplify 12 f
tpdispatcher.ml:                        if (is_bag_constraint f) then (Isabelle.###x_add simplify f)
tpdispatcher.ml:                        else (omega_###x_add simplify f)
tpdispatcher.ml:                  | SetMONA -> Mona.###x_add simplify f
tpdispatcher.ml:                        if is_bag_constraint f then Mona.###x_add simplify f
tpdispatcher.ml:                        else omega_###x_add simplify f
tpdispatcher.ml:                  | Z3 -> z3_###x_add simplify f
tpdispatcher.ml:                        (* Smtsolver.###x_add simplify f *)
tpdispatcher.ml:                  | Z3N -> z3n_###x_add simplify f
tpdispatcher.ml:                        (* Smtsolver.###x_add simplify f *)
tpdispatcher.ml:                  | Redlog -> Redlog.###x_add simplify f
tpdispatcher.ml:                  | OCRed -> Redlog.###x_add simplify f
tpdispatcher.ml:                        if is_bag_constraint f then Mona.###x_add simplify f
tpdispatcher.ml:                        else Redlog.###x_add simplify f
tpdispatcher.ml:                          Mona.###x_add simplify f
tpdispatcher.ml:                          Redlog.###x_add simplify f
tpdispatcher.ml:                        if is_bag_constraint f then Mona.###x_add simplify f
tpdispatcher.ml:                        else Smtsolver.###x_add simplify f
tpdispatcher.ml:                        if (is_bag_constraint f) then (Mona.###x_add simplify f)
tpdispatcher.ml:                        else if (is_list_constraint f) then (Coq.###x_add simplify f)
tpdispatcher.ml:                        else if (is_array_constraint f) then (Smtsolver.###x_add simplify f)
tpdispatcher.ml:                        else (omega_###x_add simplify f)
tpdispatcher.ml:                        if (is_array_constraint f) then (Smtsolver.###x_add simplify f)
tpdispatcher.ml:                        else (omega_###x_add simplify f)
tpdispatcher.ml:                  | SPASS -> Spass.###x_add simplify f
tpdispatcher.ml:                  | _ -> omega_###x_add simplify f 
tpdispatcher.ml:              (* TODO : add logtime for ###x_add simplify *)
tpdispatcher.ml:let ###x_add simplify (f:CP.formula):CP.formula =
tpdispatcher.ml:   (* | AndList b -> mkAndList (map_l_snd ###x_add simplify b) *)
tpdispatcher.ml:   | _ -> Translate_out_array_in_cpure_formula.translate_back_array_in_one_formula (tp_pairwisecheck (###x_add simplify f)) in
tpdispatcher.ml:  Debug.no_1 "TP.simplify" pr pr ###x_add simplify f
tpdispatcher.ml:        let others = ###x_add simplify (conj_of_list others no_pos) in
tpdispatcher.ml:  else ###x_add simplify f
tpdispatcher.ml:        let others = ###x_add simplify (CP.mkExists exist_vars (conj_of_list others no_pos) None no_pos) in
tpdispatcher.ml:    ###x_add simplify (CP.mkExists exist_vars f None no_pos)
tpdispatcher.ml:(* always ###x_add simplify directly with the help of prover *)
tpdispatcher.ml:  ###x_add simplify f 
tpdispatcher.ml:let ###x_add simplify (f:CP.formula): CP.formula = 
tpdispatcher.ml:  CP.elim_exists_with_simpl ###x_add simplify f 
tpdispatcher.ml:(* let ###x_add simplify (f:CP.formula): CP.formula =  *)
tpdispatcher.ml:(*   Debug.no_1 "TP.simplify" pr pr ###x_add simplify f *)
tpdispatcher.ml:let ###x_add simplify (f : CP.formula) : CP.formula =
tpdispatcher.ml:  Debug.no_1 "simplify_2" pf pf ###x_add simplify f
tpdispatcher.ml:let ###x_add simplify_a (s:int) (f:CP.formula): CP.formula = 
tpdispatcher.ml:  Debug.no_1_num s ("TP.simplify_a") pf pf ###x_add simplify f
tpdispatcher.ml:let ###x_add simplify_with_pairwise (f : CP.formula) : CP.formula =
tpdispatcher.ml:let ###x_add simplify_with_pairwise (s:int) (f:CP.formula): CP.formula =
tpdispatcher.ml:  Debug.no_1_num s ("TP.simplify_with_pairwise") pf pf ###x_add simplify_with_pairwise f
tpdispatcher.ml:    then let a,c = (Infinity.convert_inf_to_var (Cpure.arith_###x_add simplify 333 ante)),
tpdispatcher.ml:      (Infinity.convert_inf_to_var (Cpure.arith_###x_add simplify 332 conseq)) in a,c
tpdispatcher.ml:   (* not(Omega.###x_add is_sat f imp_no)*)
tpdispatcher.ml:let ###x_add is_sat (f : CP.formula) (old_sat_no : string): bool =
tpdispatcher.ml:    let res= sat_label_filter (fun c-> tp_###x_add is_sat c old_sat_no) f in
tpdispatcher.ml:let ###x_add is_sat (f : CP.formula) (sat_no : string): bool =
tpdispatcher.ml:  Debug.no_1 "[tp]is_sat"  Cprinter.string_of_pure_formula string_of_bool (fun _ -> ###x_add is_sat f sat_no) f
tpdispatcher.ml:      let conseq = if CP.should_###x_add simplify conseq0 then ###x_add simplify_a 12 conseq0 else conseq0 in
tpdispatcher.ml:        let ante = if CP.should_###x_add simplify ante0 then ###x_add simplify_a 13 ante0 else ante0 in
tpdispatcher.ml:(* 	let conseq = if CP.should_###x_add simplify conseq0 then ###x_add simplify_a 12 conseq0 else conseq0 in (\* conseq is Exists formula *\) *)
tpdispatcher.ml:(* 	  let ante = if CP.should_###x_add simplify ante0 then ###x_add simplify_a 13 ante0 else ante0 in *)
tpdispatcher.ml:(* 		  let conseq = if CP.should_###x_add simplify conseq then ###x_add simplify_a 14 conseq else conseq in *)
tpdispatcher.ml:(* 			let ante = if CP.should_###x_add simplify ante then ###x_add simplify_a 15 ante else ante in *)
tpdispatcher.ml:(* 		  let ante = CP.elim_exists_with_simpl ###x_add simplify ante in *)
tpdispatcher.ml:(* 		  let cons = CP.elim_exists_with_simpl ###x_add simplify conseq in *)
tpdispatcher.ml:let rec ###x_add imply_one i ante0 conseq0 imp_no do_cache process =
tpdispatcher.ml:	let (r,_,_)= ###x_add imply_one 0 ante conseq "0" false None in
tpdispatcher.ml:let ###x_add is_sat f sat_no do_cache =
tpdispatcher.ml:    Gen.Profiling.do_1 "is_sat" (###x_add is_sat f) sat_no
tpdispatcher.ml:let ###x_add is_sat i f sat_no do_cache =
tpdispatcher.ml:  Debug.no_1_num i "is_sat" Cprinter.string_of_pure_formula string_of_bool (fun _ -> ###x_add is_sat f sat_no do_cache) f
tpdispatcher.ml:let ###x_add is_sat_sub_no_c (f : CP.formula) sat_subno do_cache : bool = 
tpdispatcher.ml:  let sat = ###x_add is_sat 1 f ((string_of_int !sat_no) ^ "." ^ (string_of_int !sat_subno)) do_cache in
tpdispatcher.ml:let ###x_add is_sat_sub_no_c i (f : CP.formula) sat_subno do_cache : bool =
tpdispatcher.ml:  Debug.no_1_num i "is_sat_sub_no_c" Cprinter.string_of_pure_formula string_of_bool (fun f -> ###x_add is_sat_sub_no_c f sat_subno do_cache) f
tpdispatcher.ml:  List.fold_left (fun a f -> if not a then a else ###x_add is_sat_sub_no_c 1 f sat_subno false) true n_f_l 
tpdispatcher.ml:  let n_f = (*CP.elim_exists_with_fresh_vars*) CP.elim_exists_with_simpl ###x_add simplify f in
tpdispatcher.ml:	  else ###x_add is_sat_sub_no_c 2 (CP.join_conjunctions (f::(pick_rel_constraints f n_f_l))) sat_subno false) true n_f_l
tpdispatcher.ml:let ###x_add is_sat_sub_no (f : CP.formula) sat_subno : bool =
tpdispatcher.ml:  else ###x_add is_sat_sub_no_c 3 f sat_subno false
tpdispatcher.ml:let ###x_add is_sat_sub_no i (f : CP.formula) sat_subno : bool =
tpdispatcher.ml:  Debug.no_2_num i "###x_add is_sat_sub_no " (Cprinter.string_of_pure_formula) (fun x-> string_of_int !x)
tpdispatcher.ml:    (string_of_bool ) ###x_add is_sat_sub_no f sat_subno;;
tpdispatcher.ml:		(###x_add is_sat_sub_no 1 (CP.join_conjunctions f_lst) sat_subno)
tpdispatcher.ml:		not (List.exists (fun f -> not (###x_add is_sat_sub_no 2 f sat_subno)) f_lst)
tpdispatcher.ml:	  not (List.exists (fun f -> not (###x_add is_sat_sub_no 3 f sat_subno)) f_l)
tpdispatcher.ml:  		###x_add is_sat_sub_no 4 f sat_subno
tpdispatcher.ml:      ###x_add is_sat_sub_no 5 f sat_subno
tpdispatcher.ml:(* 			match ###x_add is_sat with                                                                                                                   *)
tpdispatcher.ml:(* 				let r = ###x_add is_sat_sub_no f sat_subno in                                                                                              *)
tpdispatcher.ml:(* 		  let res = ###x_add is_sat_sub_no f sat_subno in                                                                                              *)
tpdispatcher.ml:(* 			  match ###x_add is_sat with                                                                                                                 *)
tpdispatcher.ml:(* 				  let r = ###x_add is_sat_sub_no f sat_subno in (r, (Some r, x)::rest)                                                                     *)
tpdispatcher.ml:    (* MCP.is_sat_memo_sub_no_ineq_slicing_complete f with_dupl with_inv (fun f -> ###x_add is_sat_sub_no f sat_subno) *)
tpdispatcher.ml:    (* MCP.is_sat_memo_sub_no_complete f with_dupl with_inv (fun f -> ###x_add is_sat_sub_no f sat_subno) *)
tpdispatcher.ml:    MCP.is_sat_memo_sub_no_complete f with_dupl with_inv (fun f -> ###x_add is_sat_sub_no 5 f sat_subno)
tpdispatcher.ml:(* 		let r = ###x_add is_sat_sub_no f_mg sat_subno in                                                                                 *)
tpdispatcher.ml:(* 			let r = ###x_add is_sat_sub_no f sat_subno in (* Can reduce the # of SAT checking here *)                                      *)
tpdispatcher.ml:(* 			let r = ###x_add is_sat_sub_no n_f sat_subno in                                                                                *)
tpdispatcher.ml:  | MCP.OnePF f -> (if !do_sat_slice then is_sat_sub_no_with_slicing_orig else ###x_add is_sat_sub_no 61) f sat_subno
tpdispatcher.ml:  let sat = ###x_add is_sat_sub_no_c 4 f sat_subno do_cache in
tpdispatcher.ml:  ###x_add imply_one 2 ante0 conseq0 imp_no do_cache
tpdispatcher.ml:  CP.###x_add simplify := simplify;
translate_out_array_in_cpure_formula.ml:          (can_be_###x_add simplify not_f) || (not (contain_array not_f))
translate_out_array_in_cpure_formula.ml:  Debug.no_1 "can_be_simplify" !print_pure string_of_bool (fun f->can_be_###x_add simplify f) f
translate_out_array_in_cpure_formula.ml:(* let array_###x_add simplify *)
translate_out_array_in_cpure_formula.ml:(*   split_and_process f can_be_###x_add simplify processor *)
translate_out_array_in_cpure_formula.ml:(*   if can_be_###x_add simplify f *)
translate_out_array_in_cpure_formula.ml:(*   if can_be_###x_add simplify f *)
translate_out_array_in_cpure_formula.ml:  split_and_process f can_be_###x_add simplify mk_array_free_formula
translate_out_array_in_cpure_formula.ml:  let (keep_ante,sv2f_ante) = split_formula ante can_be_###x_add simplify in
translate_out_array_in_cpure_formula.ml:  let (keep_conseq,sv2f_conseq) = split_formula conseq can_be_###x_add simplify in
translate_out_array_in_cpure_formula.ml:(*   split_and_process (process_quantifier f) can_be_###x_add simplify new_translate_out_array_in_one_formula_full *)
translate_out_array_in_cpure_formula.ml:  split_and_combine new_translate_out_array_in_one_formula_full can_be_###x_add simplify (process_quantifier (translate_array_relation f))
typechecker.ml:(*             let ctx1 = CF.transform_context (###x_add elim_unsat_es prog (ref 1)) ctx in *)
typechecker.ml:(*       CF.Ctx {es with CF.es_formula = ###x_add normalize_formula_w_coers prog tmp_es es.CF.es_formula prog.prog_left_coercions} *)
typechecker.ml:      let rs, _ = ###x_add heap_entail_one_context 12 prog false ctx bnd_formula None None None post_pos in
typechecker.ml:              | [p] -> (pre_ctr # inc; Fixpoint.simplify_pre (CF.###x_add normalize 1 b.CF.formula_struc_base p pos_spec) [])
typechecker.ml:                        let old_view = ###x_add look_up_view_def b.CF.formula_inf_pos prog.prog_view_decls old_view_name in
typechecker.ml:                        let new_view = ###x_add look_up_view_def b.CF.formula_inf_pos prog.prog_view_decls new_view_name in
typechecker.ml:	      let ctx1 = if !Globals.disable_pre_sat then ctx else CF.transform_context (###x_add elim_unsat_es 2 prog (ref 1)) ctx in
typechecker.ml:                       * Need to filter the constraints and ###x_add normalize 
typechecker.ml:                                let fml = CF.###x_add normalize 1 fml (CF.formula_of_pure_formula (CP.arith_simplify_new (CP.conj_of_list lp no_pos)) no_pos) no_pos in
typechecker.ml:                                if Solver.verify_pre_###x_add is_sat prog fml then [fml] else []
typechecker.ml:                                    CF.###x_add normalize 1 tmp post_cond no_pos
typechecker.ml:    let rs, prf = ###x_add heap_entail_struc_list_failesc_context_init 1 prog false true sctx pre2 (Some tid) None None pos pid in
typechecker.ml:  let rs, prf = ###x_add heap_entail_struc_list_failesc_context_init 2 prog false true ctx empty_struc None None (Some tid) pos pid in
typechecker.ml:      let vdef = ###x_add look_up_view_def_raw 34 prog.prog_view_decls lock_sort in
typechecker.ml:      let rs, prf = ###x_add heap_entail_struc_list_failesc_context_init 3 prog false true ctx prepost None None None pos pid in
typechecker.ml:            ###x_add elim_unsat_es 12 prog (ref 1) new_es
typechecker.ml:(* WN_2_Loc : to be implemented by returing ###x_add xpure of asserted f formula*)
typechecker.ml:                              let rs,prf = ###x_add heap_entail_struc_list_failesc_context_init 4 prog false false ts c1 None None None pos None in
typechecker.ml:                                (* WN_2_Loc: put ###x_add xpure of asserted by fn below  *)
typechecker.ml:				CF.transform_list_failesc_context (idf,idf,(###x_add elim_unsat_es 4 prog (ref 1))) assumed_ctx in
typechecker.ml:	            (* let () = print_endline ("bind: unfolded context: after ###x_add unfold \n" ^ (Cprinter.string_of_list_failesc_context unfolded)) in *)
typechecker.ml:                      let rs_prim, prf = ###x_add heap_entail_struc_list_failesc_context_init 5 prog false  true unfolded struc_vheap None None None pos (Some pid) in
typechecker.ml:                    let rs, prf = ###x_add heap_entail_struc_list_failesc_context_init 6 prog false true sctx pre2 None None None pos pid in
typechecker.ml:              CF.es_formula = Solver.###x_add prop_formula_w_coers 20 prog es es.CF.es_formula lem }
typechecker.ml:        else CF.transform_context (###x_add elim_unsat_es 10 prog (ref 1)) pre_ctx 
typechecker.ml:    CF.es_formula = Solver.###x_add prop_formula_w_coers 21 prog es es.CF.es_formula (Lem_store.all_lemma # get_left_coercion) }
typechecker.ml:                            (*     let () = x_dinfo_pp ">>>>>> do_###x_add compute_fixpoint <<<<<<" no_pos in *)
typechecker.ml:                            (*         let bottom_up_fp0 = Fixcalc.###x_add compute_fixpoint 2 post_rel_df_new pre_vars proc_spec in *)
typechecker.ml:                            (*             Fixcalc.###x_add compute_fixpoint_td Fixcalc.fixc_preprocess *)
typechecker.ml:      let todo_unk = Lemproving.###x_add verify_lemma 1 l2r r2l prog coerc_name coerc_type in ()
typeinfer.ml:    let vdef = I.###x_add look_up_view_def_raw 6 prog.I.prog_view_decls h0.IF.h_formula_heap2_name in
typeinfer.ml:let ###x_add ###x_add node2_to_node i prog (h0 : IF.h_formula_heap2) : IF.h_formula_heap =
typeinfer.ml:                    let todo_unk = I.###x_add look_up_view_def_raw 6 prog.I.prog_view_decls c
typeinfer.ml:      let h = ###x_add ###x_add node2_to_node 2 prog h2 in
typeinfer.ml:          let vdef = I.###x_add look_up_view_def_raw 10 prog.I.prog_view_decls v_name in
z3.ml:      Procutils.PrvComms.###x_add maybe_raise_timeout fnc () timeout
z3.ml:    (* We don't have conseq part in ###x_add is_sat checking *)
z3.ml:let smt_###x_add is_sat pr_weak pr_strong (f : Cpure.formula) (sat_no : string) (prover: smtprover) bget_cex timeout : bool =
z3.ml:  (* let () = print_endline ("smt_###x_add is_sat : " ^ (!print_pure f) ^ "\n") in *)
z3.ml:let is_sat_ops pr_weak pr_strong f sat_no = smt_###x_add is_sat pr_weak pr_strong f sat_no Z3N false z3_sat_timeout_limit
z3.ml:let is_sat_ops_cex pr_weak pr_strong f sat_no = smt_###x_add is_sat pr_weak pr_strong f sat_no Z3N true z3_sat_timeout_limit
z3.ml:let ###x_add is_sat f sat_no =
z3.ml:  smt_###x_add is_sat pr_w pr_s f sat_no Z3N false z3_sat_timeout_limit
z3.ml:let is_sat_with_check (pe : CP.formula) sat_no : bool option = CP.do_with_check "" (fun x -> ###x_add is_sat x sat_no) pe 
z3.ml:let ###x_add is_sat (pe : CP.formula) sat_no : bool =
z3.ml:    ###x_add is_sat pe sat_no
z3.ml:    print_endline_quiet ("Apply z3.###x_add is_sat on formula :"^(!print_pure pe));
z3.ml:let ###x_add is_sat f sat_no = Debug.no_2(* _loop *) "is_sat" (!print_pure) (fun x->x) string_of_bool is_sat f sat_no
z3.ml:let ###x_add simplify (f: CP.formula) : CP.formula = 
z3.ml:    (Omega.###x_add simplify f)
z3.ml:let ###x_add simplify (pe : CP.formula) : CP.formula =
z3.ml:  match (CP.do_with_check "" ###x_add simplify pe) with
z3.ml:let ###x_add simplify (pe : CP.formula) : CP.formula =
z3.ml:  Debug.no_1 "simplify" pr pr ###x_add simplify pe 
