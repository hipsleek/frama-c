Wed Jul 16 11:06:37 MET DST 2003
REDUCE Development Version, 20-Jun-2003 ...

1: 
2: 2: 2: 2: 2: 2: 2: 2: 2: 
*** airy_ai already defined as operator 

*** airy_bi already defined as operator 

*** odesolve-specfn* already defined as operator 

*** odesolve-solns* already defined as operator 

3: 3: %*******************************************************************%
%                                                                   %
%                      C O N L A W . T S T                          %
%                      -------------------                          %
%  conlaw.tst  contains test examples for the programs conlaw0.red  %
%  conlaw1.red, conlaw2.red, conlaw3.red, conlaw4.red. To run       %
%  this test read in the files crack.red, conlaw0.red, conlaw1.red, %
%  conlaw2.red, conlaw3.red, conlaw4.red or load their compiled     %
%  version before.                                                  %
%                                                                   %
%  Author: Thomas Wolf                                              %
%  Date:   15. June 1999, 6. May 2003                               %
%                                                                   %
%  Details about the syntax of conlaw1-4 are given in conlaw.tex.   %
%  To run this file read in or load crack, conlaw0 before.          %
%                                                                   %
%  The statement lisp(print_:=nil); suppresses output of the        %
%  computation. To see details of it do lisp(print_:=50).           %
%                                                                   %
%*******************************************************************%

load crack ;

 % ,conlaw0,conlaw1,conlaw2,conlaw3,conlaw4$

lisp(depl!*:=nil)$

     % clearing of all dependencies
setcrackflags()$

       % standart flags
lisp(print_:=nil)$

     % no output of the calculation

%% off batch_mode$

comment -------------------------------------------------------------
The following example calculates all conservation laws of the KdV-
equation with a characteristic function of order not higher than two;


nodepnd {u}$

           % deletes all dependencies of u
depend u,x,t$

          % declares u to be a function of x,t
conlaw4({{df(u,t) = u*df(u,x)+df(u,x,3)}, {u}, {t,x}},
        {0, 2, t, {}, {}}                             )$


--------------------------------------------------------------------------

This is CONLAW4 - a program for calculating conservation laws of DEs

The DE under investigation is :

u =u   + u *u
 t  3x    x

for the function(s): u(t,x)

======================================================
Currently conservation laws with characteristic
function(s) of order 0 are determined
======================================================

Conservation law:

( u ) * ( u  - u   - u *u )
           t    3x    x

 = 

     1   2
df( ---*u , t )
     2

+

                1    2    1   3
df(  - u  *u + ---*u   - ---*u , x )
        2x      2   x     3

======================================================

Conservation law:

( t*u + x ) * ( u  - u   - u *u )
                 t    3x    x

 = 

     1     2
df( ---*t*u  + u*x, t )
     2

+

                          1    2           1     3    1   2
df(  - u  *t*u - u  *x + ---*u  *t + u  - ---*t*u  - ---*u *x, x )
        2x        2x      2   x       x    3          2

======================================================

Conservation law:

( 1 ) * ( u  - u   - u *u )
           t    3x    x

 = 

df( u, t )

+

              1   2
df(  - u   - ---*u , x )
        2x    2

======================================================
Currently conservation laws with characteristic
function(s) of order 1 are determined
======================================================

There is no conservation law of this order.

======================================================
Currently conservation laws with characteristic
function(s) of order 2 are determined
======================================================

Conservation law:

              2
(  - 2*u   - u  ) * ( u  - u   - u *u )
        2x             t    3x    x

 = 

      2    1   3
df( u   - ---*u , t )
     x     3

+

                    2        2    1   4
df(  - 2*u *u  + u    + u  *u  + ---*u , x )
          t  x    2x     2x       4

======================================================

                     2
{{{ - 2*df(u,x,2) - u },

             2    3
    3*df(u,x)  - u
  {-----------------,
           3

                                      2                2    4
     - 8*df(u,t)*df(u,x) + 4*df(u,x,2)  + 4*df(u,x,2)*u  + u
   -----------------------------------------------------------}},
                                4

                            2
           - 2*df(u,x,2) - u
 {{1},{u,---------------------}},
                   2

 {{t*u + x},

    u*(t*u + 2*x)
  {---------------,
          2

                                                  2                      3
   ( - 6*df(u,x,2)*t*u - 6*df(u,x,2)*x + 3*df(u,x) *t + 6*df(u,x) - 2*t*u

          2
     - 3*u *x)/6}},

 {{u},

     2                               2      3
    u     - 6*df(u,x,2)*u + 3*df(u,x)  - 2*u
  {----,--------------------------------------}}}
    2                     6


comment -------------------------------------------------------------
The next example demonstrates that one can specify an ansatz
for the characteristic function of one or more equations of the
PDE-system. In this example all conservation laws of the wave
equation which is written as a first order system are calculated
such that the characteristic functions of the first of both
equations is proportional to df(u,x,2). (This will include zero
as it is a multiple of df(u,x,2) too.)

In the following input the equations are solved for the t-derivatives,
so the t-derivatives will be substituted in the conservation-law-
conditions, so the ansatz for q_1 should have no t-derivatives of u
included. Therefore the function r in q_1 below is specified as
depending on t,x,u,v,df(u,x),df(v,x). 
In the call of conlaw2 the list of variables is {t,x} and x is
the second of the variables (could equally well be in reverse order).
Therefore df(u,x) takes the form u!`2 when the dependencies of r
are specified (see conlaw.tex);


nodepnd {u,v,r}$


depend u,x,t$


depend v,x,t$


depend r,t,x,u,v,u!`2,v!`2$


q_1:=r*df(u,x,2)$


conlaw2({{df(u,t)=df(v,x),
          df(v,t)=df(u,x) }, {u,v}, {t,x}},
        {2, 2, t, {r}, {}})$


--------------------------------------------------------------------------

This is CONLAW2 - a program for calculating conservation laws of DEs

The DEs under investigation are :

u =v
 t  x

v =u
 t  x

for the function(s): u(x,t), v(x,t)

======================================================
A special ansatz of order 2 for the characteristic
function(s) is investigated.


Conservation law:

( u   ) * ( u  - v  )
   2x        t    x

+

( v   ) * (  - u  + v  )
   2x           x    t

 = 

        1    2    1    2
df(  - ---*u   - ---*v  , t )
        2   x     2   x

+

df( u *u  - u *v  + v *v , x )
     t  x    x  x    t  x

======================================================

{{{df(u,x,2),df(v,x,2)},

               2          2
     - (df(u,x)  + df(v,x) )
  {--------------------------,
               2

   df(u,t)*df(u,x) - df(u,x)*df(v,x) + df(v,t)*df(v,x)}}}

clear q_1$


nodepnd {q_1}$



comment -------------------------------------------------------------
For the Burgers equation the following example finds all conservation
laws of zero'th order in the characteristic function up to the solution
of the linear heat equation. This is an example for what happens when 
not all conditions could be solved, but it is also an example which 
shows that not only characteristic functions of polynomial or rational
form can be found;


nodepnd {u}$


depend u,x,t$


conlaw1({{df(u,t)=df(u,x,2)+df(u,x)**2/2}, {u}, {t,x}}, 
        {0, 0, t, {}, {}}                              )$


--------------------------------------------------------------------------

This is CONLAW1 - a program for calculating conservation laws of DEs

The DE under inve, vlist1 und 2
  vlist1:=cadr a$               %   Var. nach d. erfolglos sep. wurde
  vlist2:=caddr a$              %   Var. nach denen nicht sep. wurde
  eql:=cdr eql$
  if vlist2 then <<             %   verbleibende Var. nach denen zu sep. ist
   x:=car vlist2$
   vlist2:=cdr vlist2$
   if my_freeof(cdar a,x) then if vlist2 then eql:=cons(list(car a,vlist1,vlist2),eql)
                                % to be investigated wrt. the remaining vlist2
                                         else eql1:=cons(a,eql1)
                                % finished with this expression
                          else
   if member(x,argset smemberl(ftem,list cdar a))
   then eql:=cons(list(car a,cons(x,vlist1),vlist2),eql)
                                % not separable now but perhaps later
   else <<
    l:=sumsep(cdar a,x,nonrat)$ %   Liste der Gl. die sich durch Sep.
                                %   nach x ergeben
    if l then if vlist1 or
                 vlist2 then eql:=append(varapp(l,caar a,nil,append(vlist1,vlist2)),
                                         eql)
                                %   nach erfolgr. Sep. wird nach bisher
                                %   erfolglosen Var. sep.
                        else eql1:=append(varapp(l,caar a,nil,nil),eql1)
         else if vlist2 then eql:=cons(list(car a,cons(x,vlist1),vlist2),eql)
                        else eql1:=cons(a,eql1)
   >>
  >>         else eql1:=cons(a,eql1)    %   erfolgloses Sep.,x wird als
 >>$                                    %   erfolglose Var. registriert
 return eql1$
end$

symbolic procedure varapp(l,a,v1,v2)$
%   an jede Gl. aus l werden v1 und v2 angehaengt
if null l then nil
else
cons(list(cons(cons(caar l,a),cdar l),v1,v2),varapp(cdr l,a,v1,v2))$

symbolic procedure sep(p,ftem,varl,nonrat)$
%  Die Gl. p (in LISP-Notation) wird nach den Var. aus varl separiert
%  varl Liste der Variabl.
begin scalar eql,eqlist,a,q$
  if pairp p and (car p='QUOTIENT) then
  <<q:=cdr err_catch_fac(caddr p)$
    if length q>1 then q:=cons('TIMES,q)
                  else q:=car q$
    p:=cadr p
  >>$
  if pairp p and (car p='PLUS) then
  a:=cons(nil,if not q then cdr p
                       else for each b in cdr p
                            collect list('QUOTIENT,b,q))
                               else
  if not q then a:=list(nil,p)
           else a:=list(nil,List('QUOTIENT,p,q))$
                                       %   Gl. als Liste von Summanden
  eql:=list(list(a,nil,varl))$
                                       %   Listen der Var. anhaengen
  eql:=eqsep(eql,ftem,nonrat)$

  while eql do
  <<a:=caar eql$                  %   Listen der Var. streichen
    if cddr a then a:=cons(car a,cons('PLUS,cdr a))
              else a:=cons(car a,cadr a)$       %   PLUS eintragen
    if car a then
    if cdar a then a:=cons(cons('TIMES, car a),cdr a)
              else a:=cons(caar a,cdr a)
             else a:=cons(1,cdr a)$
    eqlist:=cons(a,eqlist)$
    eql:=cdr eql
  >>$

  return eqlist
end$

symbolic procedure separ2(p,ftem,varl)$
%  Die Gl. p (in LISP-Notation) wird nach den Var. aus varl separiert
%  varl Liste der Variabl.
begin scalar eqlist$
  if p and not zerop p then
  if not (pairp p and (car p='QUOTIENT) and
         intersection(argset smemberl(ftem,cadr p),varl)) then
  <<eqlist:=sep(p,ftem,varl,nil)$
    % because called from specialsol in crint, a more restrictive
    % conditions is ok, as long as it separates, so nil as 4th
    % argument to sep(), i.e. nonrational ftem may occur in the
    % explicit supposed to be linear indep. factors
    if eqlist then eqlist:=union(cdr eqlist,list car eqlist)$
  >>;   % else eqlist is nil

  return eqlist
end$

symbolic procedure separ(p,ftem,varl,nonrat)$
%  Die Gl. p (in LISP-Notation) wird nach den Var. aus varl separiert
%  varl Liste der Variabl.
begin scalar eql,eqlist,a,b,l,s$
  if p and not zerop p then
  if not (pairp p and (car p='QUOTIENT) and
        intersection(argset smemberl(ftem,cadr p),varl)) then
  <<if (pairp p) and (car p = 'TIMES) then p:=reval p$
    eqlist:=sep(p,ftem,varl,nonrat)$
    if eqlist then eql:=union(cdr eqlist,list car eqlist)$
    eqlist:=nil$
    while eql do
    <<a:=car eql$
      l:=eql:=cdr eql$
      for each b in l do
      <<s:=reval list('QUOTIENT,cdr b,cdr a)$
        if not smemberl(append(varl,ftem),s) then
        <<eql:=delete(b,eql)$
          a:=cons(reval list('PLUS,car a,list('TIMES,s,car b)),cdr a)>>
      >>$
      eqlist:=cons(a,eqlist)
    >>
  >>                                                     else
  eqlist:=list cons(1,p)        % FTEM functions in the DENR of p
                     else eqlist:=list cons(0,0)$
  return eqlist
end$

endmodule$

end$
                   9
eta_v=u  *v + 2*u  *v  + 3*u *v   - 6*u *v *t - 3*u *v *u - ---*u *v *v
       3x        2x  x      x  2x      x  x        x  x      2   x  x

                        2    3      2      9        2    3      3
 + 6*u *t*u*v + 6*u *t*v  + ---*u *u *v + ---*u *u*v  + ---*u *v  + 2*u *v*x
      x            x         2   x         2   x         2   x         x

 - v   + 4*v  *t + 2*v  *u + 2*v  *v + 5*v  *v  - 6*v  *t*u - 6*v  *t*v
    4x      3x        3x        3x        2x  x      2x          2x

    3       2    9             3       2                 2      9    2
 - ---*v  *u  - ---*v  *u*v - ---*v  *v  - 2*v  *x - 6*v  *t - ---*v  *u
    2   2x       2   2x        2   2x         2x        x       2   x

       2             2                         2    1      3    9      2
 - 3*v  *v + 3*v *t*u  + 12*v *t*u*v + 3*v *t*v  + ---*v *u  + ---*v *u *v
      x         x            x            x         2   x       2   x

    9        2               1      3                       2
 + ---*v *u*v  + 2*v *u*x + ---*v *v  + 2*v *v*x + 3*u*v + v
    2   x           x        2   x         x

-------- 2. Symmetry:

xi_t=0

xi_x=0

                                                               3       2
eta_u=u   + 2*u  *u + 2*u  *v + 4*u   + 5*u  *u  + 3*u  *v  + ---*u  *u
       4x      3x        3x        3x      2x  x      2x  x    2   2x

    9                       3       2                 2      9    2         2
 + ---*u  *u*v + 6*u  *u + ---*u  *v  + 6*u  *v + 3*u  *u + ---*u  *v + 6*u
    2   2x          2x      2   2x         2x        x       2   x         x

               9                                   1      3    9      2
 + 2*u *v   + ---*u *v *u + 3*u *v *v + 6*u *v  + ---*u *u  + ---*u *u *v
      x  2x    2   x  x        x  x        x  x    2   x       2   x

         2    9        2                1      3         2            3      3
 + 3*u *u  + ---*u *u*v  + 12*u *u*v + ---*u *v  + 3*u *v  + v  *u + ---*v *u
      x       2   x            x        2   x         x       3x      2   x

    9      2           2    3        2
 + ---*v *u *v + 6*v *u  + ---*v *u*v  + 6*v *u*v
    2   x           x       2   x           x

                                                 9
eta_v=u  *v + 2*u  *v  + 3*u *v   - 3*u *v *u - ---*u *v *v - 6*u *v
       3x        2x  x      x  2x      x  x      2   x  x        x  x

    3      2      9        2               3      3         2
 + ---*u *u *v + ---*u *u*v  + 6*u *u*v + ---*u *v  + 6*u *v  - v   + 2*v  *u
    2   x         2   x           x        2   x         x       4x      3x

                                 3       2    9                       3       2
 + 2*v  *v + 4*v   + 5*v  *v  - ---*v  *u  - ---*v  *u*v - 6*v  *u - ---*v  *v
      3x        3x      2x  x    2   2x       2   2x          2x      2   2x

              9    2         2         2    1      3    9      2           2
 - 6*v  *v - ---*v  *u - 3*v  *v - 6*v   + ---*v *u  + ---*v *u *v + 3*v *u
      2x      2   x         x         x     2   x       2   x           x

    9        2                1      3         2
 + ---*v *u*v  + 12*v *u*v + ---*v *v  + 3*v *v
    2   x            x        2   x         x

-------- 3. Symmetry:

xi_t=0

xi_x=0

                                                                 3       2
eta_u=u   + 2*u  *u + 2*u  *v + 5*u  *u  + 3*u  *v  + 2*u  *t + ---*u  *u
       4x      3x        3x        2x  x      2x  x      2x     Wed Jul 16 11:06:37 MET DST 2003
REDUCE Development Version, 20-Jun-2003 ...

1: 
2: 2: 2: 2: 2: 2: 2: 2: 2: 
*** airy_ai already defined as operator 

*** airy_bi already defined as operator 

*** odesolve-specfn* already defined as operator 

*** odesolve-solns* already defined as operator 

3: 3: %*******************************************************************%
%                                                                   %
%                      C O N L A W . T S T                          %
%                      -------------------                          %
%  conlaw.tst  contains test examples for the programs conlaw0.red  %
%  conlaw1.red, conlaw2.red, conlaw3.red, conlaw4.red. To run       %
%  this test read in the files crack.red, conlaw0.red, conlaw1.red, %
%  conlaw2.red, conlaw3.red, conlaw4.red or load their compiled     %
%  version before.                                                  %
%                                                                   %
%  Author: Thomas Wolf                                              %
%  Date:   15. June 1999, 6. May 2003                               %
%                                                                   %
%  Details about the syntax of conlaw1-4 are given in conlaw.tex.   %
%  To run this file read in or load crack, conlaw0 before.          %
%                                                                   %
%  The statement lisp(print_:=nil); suppresses output of the        %
%  computation. To see details of it do lisp(print_:=50).           %
%                                                                   %
%*******************************************************************%

load crack ;

 % ,conlaw0,conlaw1,conlaw2,conlaw3,conlaw4$

lisp(depl!*:=nil)$

     % clearing of all dependencies
setcrackflags()$

       % standart flags
lisp(print_:=nil)$

     % no output of the calculation

%% off batch_mode$

comment -------------------------------------------------------------
The following example calculates all conservation laws of the KdV-
equation with a characteristic function of order not higher than two;


nodepnd {u}$

           % deletes all dependencies of u
depend u,x,t$

          % declares u to be a function of x,t
conlaw4({{df(u,t) = u*df(u,x)+df(u,x,3)}, {u}, {t,x}},
        {0, 2, t, {}, {}}                             )$


--------------------------------------------------------------------------

This is CONLAW4 - a program for calculating conservation laws of DEs

The DE under investigation is :

u =u   + u *u
 t  3x    x

for the function(s): u(t,x)

======================================================
Currently conservation laws with characteristic
function(s) of order 0 are determined
======================================================

Conservation law:

( u ) * ( u  - u   - u *u )
           t    3x    x

 = 

     1   2
df( ---*u , t )
     2

+

                1    2    1   3
df(  - u  *u + ---*u   - ---*u , x )
        2x      2   x     3

======================================================

Conservation law:

( t*u + x ) * ( u  - u   - u *u )
                 t    3x    x

 = 

     1     2
df( ---*t*u  + u*x, t )
     2

+

                          1    2           1     3    1   2
df(  - u  *t*u - u  *x + ---*u  *t + u  - ---*t*u  - ---*u *x, x )
        2x        2x      2   x       x    3          2

======================================================

Conservation law:

( 1 ) * ( u  - u   - u *u )
           t    3x    x

 = 

df( u, t )

+

              1   2
df(  - u   - ---*u , x )
        2x    2

======================================================
Currently conservation laws with characteristic
function(s) of order 1 are determined
======================================================

There is no conservation law of this order.

======================================================
Currently conservation laws with characteristic
function(s) of order 2 are determined
======================================================

Conservation law:

              2
(  - 2*u   - u  ) * ( u  - u   - u *u )
        2x             t    3x    x

 = 

      2    1   3
df( u   - ---*u , t )
     x     3

+

                    2        2    1   4
df(  - 2*u *u  + u    + u  *u  + ---*u , x )
          t  x    2x     2x       4

======================================================

                     2
{{{ - 2*df(u,x,2) - u },

             2    3
    3*df(u,x)  - u
  {-----------------,
           3

                                      2                2    4
     - 8*df(u,t)*df(u,x) + 4*df(u,x,2)  + 4*df(u,x,2)*u  + u
   -----------------------------------------------------------}},
                                4

                            2
           - 2*df(u,x,2) - u
 {{1},{u,---------------------}},
                   2

 {{t*u + x},

    u*(t*u + 2*x)
  {---------------,
          2

                                                  2                      3
   ( - 6*df(u,x,2)*t*u - 6*df(u,x,2)*x + 3*df(u,x) *t + 6*df(u,x) - 2*t*u

          2
     - 3*u *x)/6}},

 {{u},

     2                               2      3
    u     - 6*df(u,x,2)*u + 3*df(u,x)  - 2*u
  {----,--------------------------------------}}}
    2                     6


comment -------------------------------------------------------------
The next example demonstrates that one can specify an ansatz
for the characteristic function of one or more equations of the
PDE-system. In this example all conservation laws of the wave
equation which is written as a first order system are calculated
such that the characteristic functions of the first of both
equations is proportional to df(u,x,2). (This will include zero
as it is a multiple of df(u,x,2) too.)

In the following input the equations are solved for the t-derivatives,
so the t-derivatives will be substituted in the conservation-law-
conditions, so the ansatz for q_1 should have no t-derivatives of u
included. Therefore the function r in q_1 below is specified as
depending on t,x,u,v,df(u,x),df(v,x). 
In the call of conlaw2 the list of variables is {t,x} and x is
the second of the variables (could equally well be in reverse order).
Therefore df(u,x) takes the form u!`2 when the dependencies of r
are specified (see conlaw.tex);


nodepnd {u,v,r}$


depend u,x,t$


depend v,x,t$


depend r,t,x,u,v,u!`2,v!`2$


q_1:=r*df(u,x,2)$


conlaw2({{df(u,t)=df(v,x),
          df(v,t)=df(u,x) }, {u,v}, {t,x}},
        {2, 2, t, {r}, {}})$


--------------------------------------------------------------------------

This is CONLAW2 - a program for calculating conservation laws of DEs

The DEs under investigation are :

u =v
 t  x

v =u
 t  x

for the function(s): u(x,t), v(x,t)

======================================================
A special ansatz of order 2 for the characteristic
function(s) is investigated.


Conservation law:

( u   ) * ( u  - v  )
   2x        t    x

+

( v   ) * (  - u  + v  )
   2x           x    t

 = 

        1    2    1    2
df(  - ---*u   - ---*v  , t )
        2   x     2   x

+

df( u *u  - u *v  + v *v , x )
     t  x    x  x    t  x

======================================================

{{{df(u,x,2),df(v,x,2)},

               2          2
     - (df(u,x)  + df(v,x) )
  {--------------------------,
               2

   df(u,t)*df(u,x) - df(u,x)*df(v,x) + df(v,t)*df(v,x)}}}

clear q_1$


nodepnd {q_1}$



comment -------------------------------------------------------------
For the Burgers equation the following example finds all conservation
laws of zero'th order in the characteristic function up to the solution
of the linear heat equation. This is an example for what happens when 
not all conditions could be solved, but it is also an example which 
shows that not only characteristic functions of polynomial or rational
form can be found;


nodepnd {u}$


depend u,x,t$


conlaw1({{df(u,t)=df(u,x,2)+df(u,x)**2/2}, {u}, {t,x}}, 
        {0, 0, t, {}, {}}                              )$


--------------------------------------------------------------------------

This is CONLAW1 - a program for calculating conservation laws of DEs

The DE under inve, vlist1 und 2
  vlist1:=cadr a$               %   Var. nach d. erfolglos sep. wurde
  vlist2:=caddr a$              %   Var. nach denen nicht sep. wurde
  eql:=cdr eql$
  if vlist2 then <<             %   verbleibende Var. nach denen zu sep. ist
   x:=car vlist2$
   vlist2:=cdr vlist2$
   if my_freeof(cdar a,x) then if vlist2 then eql:=cons(list(car a,vlist1,vlist2),eql)
                                % to be investigated wrt. the remaining vlist2
                                         else eql1:=cons(a,eql1)
                                % finished with this expression
                          else
   if member(x,argset smemberl(ftem,list cdar a))
   then eql:=cons(list(car a,cons(x,vlist1),vlist2),eql)
                                % not separable now but perhaps later
   else <<
    l:=sumsep(cdar a,x,nonrat)$ %   Liste der Gl. die sich durch Sep.
                                %   nach x ergeben
    if l then if vlist1 or
                 vlist2 then eql:=append(varapp(l,caar a,nil,append(vlist1,vlist2)),
                                         eql)
                                %   nach erfolgr. Sep. wird nach bisher
                                %   erfolglosen Var. sep.
                        else eql1:=append(varapp(l,caar a,nil,nil),eql1)
         else if vlist2 then eql:=cons(list(car a,cons(x,vlist1),vlist2),eql)
                        else eql1:=cons(a,eql1)
   >>
  >>         else eql1:=cons(a,eql1)    %   erfolgloses Sep.,x wird als
 >>$                                    %   erfolglose Var. registriert
 return eql1$
end$

symbolic procedure varapp(l,a,v1,v2)$
%   an jede Gl. aus l werden v1 und v2 angehaengt
if null l then nil
else
cons(list(cons(cons(caar l,a),cdar l),v1,v2),varapp(cdr l,a,v1,v2))$

symbolic procedure sep(p,ftem,varl,nonrat)$
%  Die Gl. p (in LISP-Notation) wird nach den Var. aus varl separiert
%  varl Liste der Variabl.
begin scalar eql,eqlist,a,q$
  if pairp p and (car p='QUOTIENT) then
  <<q:=cdr err_catch_fac(caddr p)$
    if length q>1 then q:=cons('TIMES,q)
                  else q:=car q$
    p:=cadr p
  >>$
  if pairp p and (car p='PLUS) then
  a:=cons(nil,if not q then cdr p
                       else for each b in cdr p
                            collect list('QUOTIENT,b,q))
                               else
  if not q then a:=list(nil,p)
           else a:=list(nil,List('QUOTIENT,p,q))$
                                       %   Gl. als Liste von Summanden
  eql:=list(list(a,nil,varl))$
                                       %   Listen der Var. anhaengen
  eql:=eqsep(eql,ftem,nonrat)$

  while eql do
  <<a:=caar eql$                  %   Listen der Var. streichen
    if cddr a then a:=cons(car a,cons('PLUS,cdr a))
              else a:=cons(car a,cadr a)$       %   PLUS eintragen
    if car a then
    if cdar a then a:=cons(cons('TIMES, car a),cdr a)
              else a:=cons(caar a,cdr a)
             else a:=cons(1,cdr a)$
    eqlist:=cons(a,eqlist)$
    eql:=cdr eql
  >>$

  return eqlist
end$

symbolic procedure separ2(p,ftem,varl)$
%  Die Gl. p (in LISP-Notation) wird nach den Var. aus varl separiert
%  varl Liste der Variabl.
begin scalar eqlist$
  if p and not zerop p then
  if not (pairp p and (car p='QUOTIENT) and
         intersection(argset smemberl(ftem,cadr p),varl)) then
  <<eqlist:=sep(p,ftem,varl,nil)$
    % because called from specialsol in crint, a more restrictive
    % conditions is ok, as long as it separates, so nil as 4th
    % argument to sep(), i.e. nonrational ftem may occur in the
    % explicit supposed to be linear indep. factors
    if eqlist then eqlist:=union(cdr eqlist,list car eqlist)$
  >>;   % else eqlist is nil

  return eqlist
end$

symbolic procedure separ(p,ftem,varl,nonrat)$
%  Die Gl. p (in LISP-Notation) wird nach den Var. aus varl separiert
%  varl Liste der Variabl.
begin scalar eql,eqlist,a,b,l,s$
  if p and not zerop p then
  if not (pairp p and (car p='QUOTIENT) and
        intersection(argset smemberl(ftem,cadr p),varl)) then
  <<if (pairp p) and (car p = 'TIMES) then p:=reval p$
    eqlist:=sep(p,ftem,varl,nonrat)$
    if eqlist then eql:=union(cdr eqlist,list car eqlist)$
    eqlist:=nil$
    while eql do
    <<a:=car eql$
      l:=eql:=cdr eql$
      for each b in l do
      <<s:=reval list('QUOTIENT,cdr b,cdr a)$
        if not smemberl(append(varl,ftem),s) then
        <<eql:=delete(b,eql)$
          a:=cons(reval list('PLUS,car a,list('TIMES,s,car b)),cdr a)>>
      >>$
      eqlist:=cons(a,eqlist)
    >>
  >>                                                     else
  eqlist:=list cons(1,p)        % FTEM functions in the DENR of p
                     else eqlist:=list cons(0,0)$
  return eqlist
end$

endmodule$

end$
                   9
eta_v=u  *v + 2*u  *v  + 3*u *v   - 6*u *v *t - 3*u *v *u - ---*u *v *v
       3x        2x  x      x  2x      x  x        x  x      2   x  x

                        2    3      2      9        2    3      3
 + 6*u *t*u*v + 6*u *t*v  + ---*u *u *v + ---*u *u*v  + ---*u *v  + 2*u *v*x
      x            x         2   x         2   x         2   x         x

 - v   + 4*v  *t + 2*v  *u + 2*v  *v + 5*v  *v  - 6*v  *t*u - 6*v  *t*v
    4x      3x        3x        3x        2x  x      2x          2x

    3       2    9             3       2                 2      9    2
 - ---*v  *u  - ---*v  *u*v - ---*v  *v  - 2*v  *x - 6*v  *t - ---*v  *u
    2   2x       2   2x        2   2x         2x        x       2   x

       2             2                         2    1      3    9      2
 - 3*v  *v + 3*v *t*u  + 12*v *t*u*v + 3*v *t*v  + ---*v *u  + ---*v *u *v
      x         x            x            x         2   x       2   x

    9        2               1      3                       2
 + ---*v *u*v  + 2*v *u*x + ---*v *v  + 2*v *v*x + 3*u*v + v
    2   x           x        2   x         x

-------- 2. Symmetry:

xi_t=0

xi_x=0

                                                               3       2
eta_u=u   + 2*u  *u + 2*u  *v + 4*u   + 5*u  *u  + 3*u  *v  + ---*u  *u
       4x      3x        3x        3x      2x  x      2x  x    2   2x

    9                       3       2                 2      9    2         2
 + ---*u  *u*v + 6*u  *u + ---*u  *v  + 6*u  *v + 3*u  *u + ---*u  *v + 6*u
    2   2x          2x      2   2x         2x        x       2   x         x

               9                                   1      3    9      2
 + 2*u *v   + ---*u *v *u + 3*u *v *v + 6*u *v  + ---*u *u  + ---*u *u *v
      x  2x    2   x  x        x  x        x  x    2   x       2   x

         2    9        2                1      3         2            3      3
 + 3*u *u  + ---*u *u*v  + 12*u *u*v + ---*u *v  + 3*u *v  + v  *u + ---*v *u
      x       2   x            x        2   x         x       3x      2   x

    9      2           2    3        2
 + ---*v *u *v + 6*v *u  + ---*v *u*v  + 6*v *u*v
    2   x           x       2   x           x

                                                 9
eta_v=u  *v + 2*u  *v  + 3*u *v   - 3*u *v *u - ---*u *v *v - 6*u *v
       3x        2x  x      x  2x      x  x      2   x  x        x  x

    3      2      9        2               3      3         2
 + ---*u *u *v + ---*u *u*v  + 6*u *u*v + ---*u *v  + 6*u *v  - v   + 2*v  *u
    2   x         2   x           x        2   x         x       4x      3x

                                 3       2    9                       3       2
 + 2*v  *v + 4*v   + 5*v  *v  - ---*v  *u  - ---*v  *u*v - 6*v  *u - ---*v  *v
      3x        3x      2x  x    2   2x       2   2x          2x      2   2x

              9    2         2         2    1      3    9      2           2
 - 6*v  *v - ---*v  *u - 3*v  *v - 6*v   + ---*v *u  + ---*v *u *v + 3*v *u
      2x      2   x         x         x     2   x       2   x           x

    9        2                1      3         2
 + ---*v *u*v  + 12*v *u*v + ---*v *v  + 3*v *v
    2   x            x        2   x         x

-------- 3. Symmetry:

xi_t=0

xi_x=0

                                                                 3       2
eta_u=u   + 2*u  *u + 2*u  *v + 5*u  *u  + 3*u  *v  + 2*u  *t + ---*u  *u
       4x      3x        3x        2x  x      2x  x      2x     Wed Jul 16 11:06:37 MET DST 2003
REDUCE Development Version, 20-Jun-2003 ...

1: 
2: 2: 2: 2: 2: 2: 2: 2: 2: 
*** airy_ai already defined as operator 

*** airy_bi already defined as operator 

*** odesolve-specfn* already defined as operator 

*** odesolve-solns* already defined as operator 

3: 3: %*******************************************************************%
%                                                                   %
%                      C O N L A W . T S T                          %
%                      -------------------                          %
%  conlaw.tst  contains test examples for the programs conlaw0.red  %
%  conlaw1.red, conlaw2.red, conlaw3.red, conlaw4.red. To run       %
%  this test read in the files crack.red, conlaw0.red, conlaw1.red, %
%  conlaw2.red, conlaw3.red, conlaw4.red or load their compiled     %
%  version before.                                                  %
%                                                                   %
%  Author: Thomas Wolf                                              %
%  Date:   15. June 1999, 6. May 2003                               %
%                                                                   %
%  Details about the syntax of conlaw1-4 are given in conlaw.tex.   %
%  To run this file read in or load crack, conlaw0 before.          %
%                                                                   %
%  The statement lisp(print_:=nil); suppresses output of the        %
%  computation. To see details of it do lisp(print_:=50).           %
%                                                                   %
%*******************************************************************%

load crack ;

 % ,conlaw0,conlaw1,conlaw2,conlaw3,conlaw4$

lisp(depl!*:=nil)$

     % clearing of all dependencies
setcrackflags()$

       % standart flags
lisp(print_:=nil)$

     % no output of the calculation

%% off batch_mode$

comment -------------------------------------------------------------
The following example calculates all conservation laws of the KdV-
equation with a characteristic function of order not higher than two;


nodepnd {u}$

           % deletes all dependencies of u
depend u,x,t$

          % declares u to be a function of x,t
conlaw4({{df(u,t) = u*df(u,x)+df(u,x,3)}, {u}, {t,x}},
        {0, 2, t, {}, {}}                             )$


--------------------------------------------------------------------------

This is CONLAW4 - a program for calculating conservation laws of DEs

The DE under investigation is :

u =u   + u *u
 t  3x    x

for the function(s): u(t,x)

======================================================
Currently conservation laws with characteristic
function(s) of order 0 are determined
======================================================

Conservation law:

( u ) * ( u  - u   - u *u )
           t    3x    x

 = 

     1   2
df( ---*u , t )
     2

+

                1    2    1   3
df(  - u  *u + ---*u   - ---*u , x )
        2x      2   x     3

======================================================

Conservation law:

( t*u + x ) * ( u  - u   - u *u )
                 t    3x    x

 = 

     1     2
df( ---*t*u  + u*x, t )
     2

+

                          1    2           1     3    1   2
df(  - u  *t*u - u  *x + ---*u  *t + u  - ---*t*u  - ---*u *x, x )
        2x        2x      2   x       x    3          2

======================================================

Conservation law:

( 1 ) * ( u  - u   - u *u )
           t    3x    x

 = 

df( u, t )

+

              1   2
df(  - u   - ---*u , x )
        2x    2

======================================================
Currently conservation laws with characteristic
function(s) of order 1 are determined
======================================================

There is no conservation law of this order.

======================================================
Currently conservation laws with characteristic
function(s) of order 2 are determined
======================================================

Conservation law:

              2
(  - 2*u   - u  ) * ( u  - u   - u *u )
        2x             t    3x    x

 = 

      2    1   3
df( u   - ---*u , t )
     x     3

+

                    2        2    1   4
df(  - 2*u *u  + u    + u  *u  + ---*u , x )
          t  x    2x     2x       4

======================================================

                     2
{{{ - 2*df(u,x,2) - u },

             2    3
    3*df(u,x)  - u
  {-----------------,
           3

                                      2                2    4
     - 8*df(u,t)*df(u,x) + 4*df(u,x,2)  + 4*df(u,x,2)*u  + u
   -----------------------------------------------------------}},
                                4

                            2
           - 2*df(u,x,2) - u
 {{1},{u,---------------------}},
                   2

 {{t*u + x},

    u*(t*u + 2*x)
  {---------------,
          2

                                                  2                      3
   ( - 6*df(u,x,2)*t*u - 6*df(u,x,2)*x + 3*df(u,x) *t + 6*df(u,x) - 2*t*u

          2
     - 3*u *x)/6}},

 {{u},

     2                               2      3
    u     - 6*df(u,x,2)*u + 3*df(u,x)  - 2*u
  {----,--------------------------------------}}}
    2                     6


comment -------------------------------------------------------------
The next example demonstrates that one can specify an ansatz
for the characteristic function of one or more equations of the
PDE-system. In this example all conservation laws of the wave
equation which is written as a first order system are calculated
such that the characteristic functions of the first of both
equations is proportional to df(u,x,2). (This will include zero
as it is a multiple of df(u,x,2) too.)

In the following input the equations are solved for the t-derivatives,
so the t-derivatives will be substituted in the conservation-law-
conditions, so the ansatz for q_1 should have no t-derivatives of u
included. Therefore the function r in q_1 below is specified as
depending on t,x,u,v,df(u,x),df(v,x). 
In the call of conlaw2 the list of variables is {t,x} and x is
the second of the variables (could equally well be in reverse order).
Therefore df(u,x) takes the form u!`2 when the dependencies of r
are specified (see conlaw.tex);


nodepnd {u,v,r}$


depend u,x,t$


depend v,x,t$


depend r,t,x,u,v,u!`2,v!`2$


q_1:=r*df(u,x,2)$


conlaw2({{df(u,t)=df(v,x),
          df(v,t)=df(u,x) }, {u,v}, {t,x}},
        {2, 2, t, {r}, {}})$


--------------------------------------------------------------------------

This is CONLAW2 - a program for calculating conservation laws of DEs

The DEs under investigation are :

u =v
 t  x

v =u
 t  x

for the function(s): u(x,t), v(x,t)

======================================================
A special ansatz of order 2 for the characteristic
function(s) is investigated.


Conservation law:

( u   ) * ( u  - v  )
   2x        t    x

+

( v   ) * (  - u  + v  )
   2x           x    t

 = 

        1    2    1    2
df(  - ---*u   - ---*v  , t )
        2   x     2   x

+

df( u *u  - u *v  + v *v , x )
     t  x    x  x    t  x

======================================================

{{{df(u,x,2),df(v,x,2)},

               2          2
     - (df(u,x)  + df(v,x) )
  {--------------------------,
               2

   df(u,t)*df(u,x) - df(u,x)*df(v,x) + df(v,t)*df(v,x)}}}

clear q_1$


nodepnd {q_1}$



comment -------------------------------------------------------------
For the Burgers equation the following example finds all conservation
laws of zero'th order in the characteristic function up to the solution
of the linear heat equation. This is an example for what happens when 
not all conditions could be solved, but it is also an example which 
shows that not only characteristic functions of polynomial or rational
form can be found;


nodepnd {u}$


depend u,x,t$


conlaw1({{df(u,t)=df(u,x,2)+df(u,x)**2/2}, {u}, {t,x}}, 
        {0, 0, t, {}, {}}                              )$


--------------------------------------------------------------------------

This is CONLAW1 - a program for calculating conservation laws of DEs

The DE under inve, vlist1 und 2
  vlist1:=cadr a$               %   Var. nach d. erfolglos sep. wurde
  vlist2:=caddr a$              %   Var. nach denen nicht sep. wurde
  eql:=cdr eql$
  if vlist2 then <<             %   verbleibende Var. nach denen zu sep. ist
   x:=car vlist2$
   vlist2:=cdr vlist2$
   if my_freeof(cdar a,x) then if vlist2 then eql:=cons(list(car a,vlist1,vlist2),eql)
                                % to be investigated wrt. the remaining vlist2
                                         else eql1:=cons(a,eql1)
                                % finished with this expression
                          else
   if member(x,argset smemberl(ftem,list cdar a))
   then eql:=cons(list(car a,cons(x,vlist1),vlist2),eql)
                                % not separable now but perhaps later
   else <<
    l:=sumsep(cdar a,x,nonrat)$ %   Liste der Gl. die sich durch Sep.
                                %   nach x ergeben
    if l then if vlist1 or
                 vlist2 then eql:=append(varapp(l,caar a,nil,append(vlist1,vlist2)),
                                         eql)
                                %   nach erfolgr. Sep. wird nach bisher
                                %   erfolglosen Var. sep.
                        else eql1:=append(varapp(l,caar a,nil,nil),eql1)
         else if vlist2 then eql:=cons(list(car a,cons(x,vlist1),vlist2),eql)
                        else eql1:=cons(a,eql1)
   >>
  >>         else eql1:=cons(a,eql1)    %   erfolgloses Sep.,x wird als
 >>$                                    %   erfolglose Var. registriert
 return eql1$
end$

symbolic procedure varapp(l,a,v1,v2)$
%   an jede Gl. aus l werden v1 und v2 angehaengt
if null l then nil
else
cons(list(cons(cons(caar l,a),cdar l),v1,v2),varapp(cdr l,a,v1,v2))$

symbolic procedure sep(p,ftem,varl,nonrat)$
%  Die Gl. p (in LISP-Notation) wird nach den Var. aus varl separiert
%  varl Liste der Variabl.
begin scalar eql,eqlist,a,q$
  if pairp p and (car p='QUOTIENT) then
  <<q:=cdr err_catch_fac(caddr p)$
    if length q>1 then q:=cons('TIMES,q)
                  else q:=car q$
    p:=cadr p
  >>$
  if pairp p and (car p='PLUS) then
  a:=cons(nil,if not q then cdr p
                       else for each b in cdr p
                            collect list('QUOTIENT,b,q))
                               else
  if not q then a:=list(nil,p)
           else a:=list(nil,List('QUOTIENT,p,q))$
                                       %   Gl. als Liste von Summanden
  eql:=list(list(a,nil,varl))$
                                       %   Listen der Var. anhaengen
  eql:=eqsep(eql,ftem,nonrat)$

  while eql do
  <<a:=caar eql$                  %   Listen der Var. streichen
    if cddr a then a:=cons(car a,cons('PLUS,cdr a))
              else a:=cons(car a,cadr a)$       %   PLUS eintragen
    if car a then
    if cdar a then a:=cons(cons('TIMES, car a),cdr a)
              else a:=cons(caar a,cdr a)
             else a:=cons(1,cdr a)$
    eqlist:=cons(a,eqlist)$
    eql:=cdr eql
  >>$

  return eqlist
end$

symbolic procedure separ2(p,ftem,varl)$
%  Die Gl. p (in LISP-Notation) wird nach den Var. aus varl separiert
%  varl Liste der Variabl.
begin scalar eqlist$
  if p and not zerop p then
  if not (pairp p and (car p='QUOTIENT) and
         intersection(argset smemberl(ftem,cadr p),varl)) then
  <<eqlist:=sep(p,ftem,varl,nil)$
    % because called from specialsol in crint, a more restrictive
    % conditions is ok, as long as it separates, so nil as 4th
    % argument to sep(), i.e. nonrational ftem may occur in the
    % explicit supposed to be linear indep. factors
    if eqlist then eqlist:=union(cdr eqlist,list car eqlist)$
  >>;   % else eqlist is nil

  return eqlist
end$

symbolic procedure separ(p,ftem,varl,nonrat)$
%  Die Gl. p (in LISP-Notation) wird nach den Var. aus varl separiert
%  varl Liste der Variabl.
begin scalar eql,eqlist,a,b,l,s$
  if p and not zerop p then
  if not (pairp p and (car p='QUOTIENT) and
        intersection(argset smemberl(ftem,cadr p),varl)) then
  <<if (pairp p) and (car p = 'TIMES) then p:=reval p$
    eqlist:=sep(p,ftem,varl,nonrat)$
    if eqlist then eql:=union(cdr eqlist,list car eqlist)$
    eqlist:=nil$
    while eql do
    <<a:=car eql$
      l:=eql:=cdr eql$
      for each b in l do
      <<s:=reval list('QUOTIENT,cdr b,cdr a)$
        if not smemberl(append(varl,ftem),s) then
        <<eql:=delete(b,eql)$
          a:=cons(reval list('PLUS,car a,list('TIMES,s,car b)),cdr a)>>
      >>$
      eqlist:=cons(a,eqlist)
    >>
  >>                                                     else
  eqlist:=list cons(1,p)        % FTEM functions in the DENR of p
                     else eqlist:=list cons(0,0)$
  return eqlist
end$

endmodule$

end$
                   9
eta_v=u  *v + 2*u  *v  + 3*u *v   - 6*u *v *t - 3*u *v *u - ---*u *v *v
       3x        2x  x      x  2x      x  x        x  x      2   x  x

                        2    3      2      9        2    3      3
 + 6*u *t*u*v + 6*u *t*v  + ---*u *u *v + ---*u *u*v  + ---*u *v  + 2*u *v*x
      x            x         2   x         2   x         2   x         x

 - v   + 4*v  *t + 2*v  *u + 2*v  *v + 5*v  *v  - 6*v  *t*u - 6*v  *t*v
    4x      3x        3x        3x        2x  x      2x          2x

    3       2    9             3       2                 2      9    2
 - ---*v  *u  - ---*v  *u*v - ---*v  *v  - 2*v  *x - 6*v  *t - ---*v  *u
    2   2x       2   2x        2   2x         2x        x       2   x

       2             2                         2    1      3    9      2
 - 3*v  *v + 3*v *t*u  + 12*v *t*u*v + 3*v *t*v  + ---*v *u  + ---*v *u *v
      x         x            x            x         2   x       2   x

    9        2               1      3                       2
 + ---*v *u*v  + 2*v *u*x + ---*v *v  + 2*v *v*x + 3*u*v + v
    2   x           x        2   x         x

-------- 2. Symmetry:

xi_t=0

xi_x=0

                                                               3       2
eta_u=u   + 2*u  *u + 2*u  *v + 4*u   + 5*u  *u  + 3*u  *v  + ---*u  *u
       4x      3x        3x        3x      2x  x      2x  x    2   2x

    9                       3       2                 2      9    2         2
 + ---*u  *u*v + 6*u  *u + ---*u  *v  + 6*u  *v + 3*u  *u + ---*u  *v + 6*u
    2   2x          2x      2   2x         2x        x       2   x         x

               9                                   1      3    9      2
 + 2*u *v   + ---*u *v *u + 3*u *v *v + 6*u *v  + ---*u *u  + ---*u *u *v
      x  2x    2   x  x        x  x        x  x    2   x       2   x

         2    9        2                1      3         2            3      3
 + 3*u *u  + ---*u *u*v  + 12*u *u*v + ---*u *v  + 3*u *v  + v  *u + ---*v *u
      x       2   x            x        2   x         x       3x      2   x

    9      2           2    3        2
 + ---*v *u *v + 6*v *u  + ---*v *u*v  + 6*v *u*v
    2   x           x       2   x           x

                                                 9
eta_v=u  *v + 2*u  *v  + 3*u *v   - 3*u *v *u - ---*u *v *v - 6*u *v
       3x        2x  x      x  2x      x  x      2   x  x        x  x

    3      2      9        2               3      3         2
 + ---*u *u *v + ---*u *u*v  + 6*u *u*v + ---*u *v  + 6*u *v  - v   + 2*v  *u
    2   x         2   x           x        2   x         x       4x      3x

                                 3       2    9                       3       2
 + 2*v  *v + 4*v   + 5*v  *v  - ---*v  *u  - ---*v  *u*v - 6*v  *u - ---*v  *v
      3x        3x      2x  x    2   2x       2   2x          2x      2   2x

              9    2         2         2    1      3    9      2           2
 - 6*v  *v - ---*v  *u - 3*v  *v - 6*v   + ---*v *u  + ---*v *u *v + 3*v *u
      2x      2   x         x         x     2   x       2   x           x

    9        2                1      3         2
 + ---*v *u*v  + 12*v *u*v + ---*v *v  + 3*v *v
    2   x            x        2   x         x

-------- 3. Symmetry:

xi_t=0

xi_x=0

                                                                 3       2
eta_u=u   + 2*u  *u + 2*u  *v + 5*u  *u  + 3*u  *v  + 2*u  *t + ---*u  *u
       4x      3x        3x        2x  x      2x  x      2x     Wed Jul 16 11:06:37 MET DST 2003
REDUCE Development Version, 20-Jun-2003 ...

1: 
2: 2: 2: 2: 2: 2: 2: 2: 2: 
*** airy_ai already defined as operator 

*** airy_bi already defined as operator 

*** odesolve-specfn* already defined as operator 

*** odesolve-solns* already defined as operator 

3: 3: %*******************************************************************%
%                                                                   %
%                      C O N L A W . T S T                          %
%                      -------------------                          %
%  conlaw.tst  contains test examples for the programs conlaw0.red  %
%  conlaw1.red, conlaw2.red, conlaw3.red, conlaw4.red. To run       %
%  this test read in the files crack.red, conlaw0.red, conlaw1.red, %
%  conlaw2.red, conlaw3.red, conlaw4.red or load their compiled     %
%  version before.                                                  %
%                                                                   %
%  Author: Thomas Wolf                                              %
%  Date:   15. June 1999, 6. May 2003                               %
%                                                                   %
%  Details about the syntax of conlaw1-4 are given in conlaw.tex.   %
%  To run this file read in or load crack, conlaw0 before.          %
%                                                                   %
%  The statement lisp(print_:=nil); suppresses output of the        %
%  computation. To see details of it do lisp(print_:=50).           %
%                                                                   %
%*******************************************************************%

load crack ;

 % ,conlaw0,conlaw1,conlaw2,conlaw3,conlaw4$

lisp(depl!*:=nil)$

     % clearing of all dependencies
setcrackflags()$

       % standart flags
lisp(print_:=nil)$

     % no output of the calculation

%% off batch_mode$

comment -------------------------------------------------------------
The following example calculates all conservation laws of the KdV-
equation with a characteristic function of order not higher than two;


nodepnd {u}$

           % deletes all dependencies of u
depend u,x,t$

          % declares u to be a function of x,t
conlaw4({{df(u,t) = u*df(u,x)+df(u,x,3)}, {u}, {t,x}},
        {0, 2, t, {}, {}}                             )$


--------------------------------------------------------------------------

This is CONLAW4 - a program for calculating conservation laws of DEs

The DE under investigation is :

u =u   + u *u
 t  3x    x

for the function(s): u(t,x)

======================================================
Currently conservation laws with characteristic
function(s) of order 0 are determined
======================================================

Conservation law:

( u ) * ( u  - u   - u *u )
           t    3x    x

 = 

     1   2
df( ---*u , t )
     2

+

                1    2    1   3
df(  - u  *u + ---*u   - ---*u , x )
        2x      2   x     3

======================================================

Conservation law:

( t*u + x ) * ( u  - u   - u *u )
                 t    3x    x

 = 

     1     2
df( ---*t*u  + u*x, t )
     2

+

                          1    2           1     3    1   2
df(  - u  *t*u - u  *x + ---*u  *t + u  - ---*t*u  - ---*u *x, x )
        2x        2x      2   x       x    3          2

======================================================

Conservation law:

( 1 ) * ( u  - u   - u *u )
           t    3x    x

 = 

df( u, t )

+

              1   2
df(  - u   - ---*u , x )
        2x    2

======================================================
Currently conservation laws with characteristic
function(s) of order 1 are determined
======================================================

There is no conservation law of this order.

======================================================
Currently conservation laws with characteristic
function(s) of order 2 are determined
======================================================

Conservation law:

              2
(  - 2*u   - u  ) * ( u  - u   - u *u )
        2x             t    3x    x

 = 

      2    1   3
df( u   - ---*u , t )
     x     3

+

                    2        2    1   4
df(  - 2*u *u  + u    + u  *u  + ---*u , x )
          t  x    2x     2x       4

======================================================

                     2
{{{ - 2*df(u,x,2) - u },

             2    3
    3*df(u,x)  - u
  {-----------------,
           3

                                      2                2    4
     - 8*df(u,t)*df(u,x) + 4*df(u,x,2)  + 4*df(u,x,2)*u  + u
   -----------------------------------------------------------}},
                                4

                            2
           - 2*df(u,x,2) - u
 {{1},{u,---------------------}},
                   2

 {{t*u + x},

    u*(t*u + 2*x)
  {---------------,
          2

                                                  2                      3
   ( - 6*df(u,x,2)*t*u - 6*df(u,x,2)*x + 3*df(u,x) *t + 6*df(u,x) - 2*t*u

          2
     - 3*u *x)/6}},

 {{u},

     2                               2      3
    u     - 6*df(u,x,2)*u + 3*df(u,x)  - 2*u
  {----,--------------------------------------}}}
    2                     6


comment -------------------------------------------------------------
The next example demonstrates that one can specify an ansatz
for the characteristic function of one or more equations of the
PDE-system. In this example all conservation laws of the wave
equation which is written as a first order system are calculated
such that the characteristic functions of the first of both
equations is proportional to df(u,x,2). (This will include zero
as it is a multiple of df(u,x,2) too.)

In the following input the equations are solved for the t-derivatives,
so the t-derivatives will be substituted in the conservation-law-
conditions, so the ansatz for q_1 should have no t-derivatives of u
included. Therefore the function r in q_1 below is specified as
depending on t,x,u,v,df(u,x),df(v,x). 
In the call of conlaw2 the list of variables is {t,x} and x is
the second of the variables (could equally well be in reverse order).
Therefore df(u,x) takes the form u!`2 when the dependencies of r
are specified (see conlaw.tex);


nodepnd {u,v,r}$


depend u,x,t$


depend v,x,t$


depend r,t,x,u,v,u!`2,v!`2$


q_1:=r*df(u,x,2)$


conlaw2({{df(u,t)=df(v,x),
          df(v,t)=df(u,x) }, {u,v}, {t,x}},
        {2, 2, t, {r}, {}})$


--------------------------------------------------------------------------

This is CONLAW2 - a program for calculating conservation laws of DEs

The DEs under investigation are :

u =v
 t  x

v =u
 t  x

for the function(s): u(x,t), v(x,t)

======================================================
A special ansatz of order 2 for the characteristic
function(s) is investigated.


Conservation law:

( u   ) * ( u  - v  )
   2x        t    x

+

( v   ) * (  - u  + v  )
   2x           x    t

 = 

        1    2    1    2
df(  - ---*u   - ---*v  , t )
        2   x     2   x

+

df( u *u  - u *v  + v *v , x )
     t  x    x  x    t  x

======================================================

{{{df(u,x,2),df(v,x,2)},

               2          2
     - (df(u,x)  + df(v,x) )
  {--------------------------,
               2

   df(u,t)*df(u,x) - df(u,x)*df(v,x) + df(v,t)*df(v,x)}}}

clear q_1$


nodepnd {q_1}$



comment -------------------------------------------------------------
For the Burgers equation the following example finds all conservation
laws of zero'th order in the characteristic function up to the solution
of the linear heat equation. This is an example for what happens when 
not all conditions could be solved, but it is also an example which 
shows that not only characteristic functions of polynomial or rational
form can be found;


nodepnd {u}$


depend u,x,t$


conlaw1({{df(u,t)=df(u,x,2)+df(u,x)**2/2}, {u}, {t,x}}, 
        {0, 0, t, {}, {}}                              )$


--------------------------------------------------------------------------

This is CONLAW1 - a program for calculating conservation laws of DEs

The DE under inve, vlist1 und 2
  vlist1:=cadr a$               %   Var. nach d. erfolglos sep. wurde
  vlist2:=caddr a$              %   Var. nach denen nicht sep. wurde
  eql:=cdr eql$
  if vlist2 then <<             %   verbleibende Var. nach denen zu sep. ist
   x:=car vlist2$
   vlist2:=cdr vlist2$
   if my_freeof(cdar a,x) then if vlist2 then eql:=cons(list(car a,vlist1,vlist2),eql)
                                % to be investigated wrt. the remaining vlist2
                                         else eql1:=cons(a,eql1)
                                % finished with this expression
                          else
   if member(x,argset smemberl(ftem,list cdar a))
   then eql:=cons(list(car a,cons(x,vlist1),vlist2),eql)
                                % not separable now but perhaps later
   else <<
    l:=sumsep(cdar a,x,nonrat)$ %   Liste der Gl. die sich durch Sep.
                                %   nach x ergeben
    if l then if vlist1 or
                 vlist2 then eql:=append(varapp(l,caar a,nil,append(vlist1,vlist2)),
                                         eql)
                                %   nach erfolgr. Sep. wird nach bisher
                                %   erfolglosen Var. sep.
                        else eql1:=append(varapp(l,caar a,nil,nil),eql1)
         else if vlist2 then eql:=cons(list(car a,cons(x,vlist1),vlist2),eql)
                        else eql1:=cons(a,eql1)
   >>
  >>         else eql1:=cons(a,eql1)    %   erfolgloses Sep.,x wird als
 >>$                                    %   erfolglose Var. registriert
 return eql1$
end$

symbolic procedure varapp(l,a,v1,v2)$
%   an jede Gl. aus l werden v1 und v2 angehaengt
if null l then nil
else
cons(list(cons(cons(caar l,a),cdar l),v1,v2),varapp(cdr l,a,v1,v2))$

symbolic procedure sep(p,ftem,varl,nonrat)$
%  Die Gl. p (in LISP-Notation) wird nach den Var. aus varl separiert
%  varl Liste der Variabl.
begin scalar eql,eqlist,a,q$
  if pairp p and (car p='QUOTIENT) then
  <<q:=cdr err_catch_fac(caddr p)$
    if length q>1 then q:=cons('TIMES,q)
                  else q:=car q$
    p:=cadr p
  >>$
  if pairp p and (car p='PLUS) then
  a:=cons(nil,if not q then cdr p
                       else for each b in cdr p
                            collect list('QUOTIENT,b,q))
                               else
  if not q then a:=list(nil,p)
           else a:=list(nil,List('QUOTIENT,p,q))$
                                       %   Gl. als Liste von Summanden
  eql:=list(list(a,nil,varl))$
                                       %   Listen der Var. anhaengen
  eql:=eqsep(eql,ftem,nonrat)$

  while eql do
  <<a:=caar eql$                  %   Listen der Var. streichen
    if cddr a then a:=cons(car a,cons('PLUS,cdr a))
              else a:=cons(car a,cadr a)$       %   PLUS eintragen
    if car a then
    if cdar a then a:=cons(cons('TIMES, car a),cdr a)
              else a:=cons(caar a,cdr a)
             else a:=cons(1,cdr a)$
    eqlist:=cons(a,eqlist)$
    eql:=cdr eql
  >>$

  return eqlist
end$

symbolic procedure separ2(p,ftem,varl)$
%  Die Gl. p (in LISP-Notation) wird nach den Var. aus varl separiert
%  varl Liste der Variabl.
begin scalar eqlist$
  if p and not zerop p then
  if not (pairp p and (car p='QUOTIENT) and
         intersection(argset smemberl(ftem,cadr p),varl)) then
  <<eqlist:=sep(p,ftem,varl,nil)$
    % because called from specialsol in crint, a more restrictive
    % conditions is ok, as long as it separates, so nil as 4th
    % argument to sep(), i.e. nonrational ftem may occur in the
    % explicit supposed to be linear indep. factors
    if eqlist then eqlist:=union(cdr eqlist,list car eqlist)$
  >>;   % else eqlist is nil

  return eqlist
end$

symbolic procedure separ(p,ftem,varl,nonrat)$
%  Die Gl. p (in LISP-Notation) wird nach den Var. aus varl separiert
%  varl Liste der Variabl.
begin scalar eql,eqlist,a,b,l,s$
  if p and not zerop p then
  if not (pairp p and (car p='QUOTIENT) and
        intersection(argset smemberl(ftem,cadr p),varl)) then
  <<if (pairp p) and (car p = 'TIMES) then p:=reval p$
    eqlist:=sep(p,ftem,varl,nonrat)$
    if eqlist then eql:=union(cdr eqlist,list car eqlist)$
    eqlist:=nil$
    while eql do
    <<a:=car eql$
      l:=eql:=cdr eql$
      for each b in l do
      <<s:=reval list('QUOTIENT,cdr b,cdr a)$
        if not smemberl(append(varl,ftem),s) then
        <<eql:=delete(b,eql)$
          a:=cons(reval list('PLUS,car a,list('TIMES,s,car b)),cdr a)>>
      >>$
      eqlist:=cons(a,eqlist)
    >>
  >>                                                     else
  eqlist:=list cons(1,p)        % FTEM functions in the DENR of p
                     else eqlist:=list cons(0,0)$
  return eqlist
end$

endmodule$

end$
                   9
eta_v=u  *v + 2*u  *v  + 3*u *v   - 6*u *v *t - 3*u *v *u - ---*u *v *v
       3x        2x  x      x  2x      x  x        x  x      2   x  x

                        2    3      2      9        2    3      3
 + 6*u *t*u*v + 6*u *t*v  + ---*u *u *v + ---*u *u*v  + ---*u *v  + 2*u *v*x
      x            x         2   x         2   x         2   x         x

 - v   + 4*v  *t + 2*v  *u + 2*v  *v + 5*v  *v  - 6*v  *t*u - 6*v  *