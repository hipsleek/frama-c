data node{
	int val;
	node next;
}.

HeapPred P1(node a).



/*
infer_exact [P1]
P1(yy)
|- (exists y,q36: P1(q36) & y=q36 & q36=yy)
.
print residue.
*/
/*
# sp-7e.slk

These two examples gave different results.
Presumably it is due to not using eq_map for
equality on the RHS?

Entail (1) : Valid. 
 <1>emp&{FLOW,(19,20)=__norm}[]
 inferred hprel: [emp --> P1(q36_41); P1(yy) --> emp]


Entail (2) : Valid. 
 <1>emp&{FLOW,(19,20)=__norm}[]
 inferred hprel: [P1(yy) --> P1(yy)]



*/


/*
# sp-7e.slk

Obtained below:
 <1>emp&{FLOW,(19,20)=__norm}[]
 inferred hprel: [P1(q36_22) --> P1(q36_22); P1(yy) --> emp]

where P1(yy) is accounted twice

@1!   residue before matching: : P1(yy)&{FLOW,(19,20)=__norm}[]
@1!   new_lhs: : P1(q36_22)
@1!   new_es_formula: : P1(yy)&{FLOW,(19,20)=__norm}[]

P1(q36_22) is from smart subs, while P1(yy) is the original LHS.
After the folding, why is P1(yy) still be kept?

*/

/*
infer_exact [P1]
P1(yy)
|- (exists y,q36: P1(q36) & y=q36 & q36=yy)
.
print residue.


infer_exact [P1]
P1(yy)
|- (exists y,q36: P1(q36) & y=q36 & y=yy)
.
print residue.

//3
infer_exact [P1]
P1(yy) & yy = y1 & y1 = y2 & y2=yy
|-  (exists y2,q36: P1(q36) & y2=q36 & y2=yy)
.
print residue.
*/
//4
infer_exact [P1]
P1(yy) & yy = y1
|-  (exists y2,q36: P1(q36) & y2=q36 & y1=y2 )
.
print residue.