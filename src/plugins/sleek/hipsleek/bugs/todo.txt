================================================================
# bug5a-norm10-4.slk

Why does ll has actual root?
This isn't with ptr arithmetic.
Can we fix it as None instead..

 view ll{}[]<n:int>= 
  view_domains: 
   view ll<n:int>= 
    EList
      :EBase 
         (* lbl: *){1}->emp&self=null & n=0&{FLOW,(1,26)=__flow#E}[]
      || :EBase 
            exists (Impl)[Anon_12; 
            q](* lbl: *){2}->(exists flted_6_14: (* lbl: *){2}->self::node<Anon_12,q>@M * 
                                                                q::ll<flted_6_14>@M&
            flted_6_14+1=n & 0<n&{FLOW,(1,26)=__flow#E}[])


  actual_root: 
  Some((self, true))
================================================================
# test3.slk # DONE 

Inference has three basic problems in above file/

//(4).
infer[n] x::ll<n> |- x::node<_,null>.
print residue.
/*
This is WRONG! Previously, we got n=1 as inferred constraint.

Entail (4) : Fail.
*/

//(10).
infer[Q] x::node<_,y> * y::ll<n2> & 
Q(n1-1, n2, n3) & n1>0 |- x::ll<n3> & Q(n1,n2,n3).
print residue.
/*
The RELASS are wrong here. n3=n2+1 should have been instantiated
and n3=1 occurs when n2=0 presumably.

 <1>emp&Q(-1+n1,n2,n3) & 0<n1 & Anon_183=Anon_21 & r_184=y & n3=n2+1 & n3=1&{FLOW,(19,20)=__norm}[]
 inferred rel: [RELASS [Q]: ( Q(-1+n1,n2,n3)) -->  n3=n2+1; 
                RELASS [Q]: ( Q(-1+n1,n2,n3)) -->  n3=1; 
                RELDEFN Q: ( 1<=n1 & 0<=n2 & Q(-1+n1,n2,n3)) -->  Q(n1,n2,n3)]
*/



#



added memo_Pure re-patch;
      should do it more selectively

has assert been specialised?
  --> specialised on the fly

qsort
=====
 q is existential.. 
 prune baga conditions: (self,q)-163,(self)-162
 

use propagation and simplication for pruning conditions?

xform has redundancy (e.g. bugs/llrb5.slk)

A node with Derived became Original after lemma folding! which example?

view_unfold_num should be made into a verifier option

view_original should be changed from bool to integer
  0 -> original
  1,2,.. -> derived

Printing very indented:
                            [c<=1(IP)& 0<=c(IP)]  [true]  alias set:[@]
                          [d]:  [d<=2(IP)& 0<=d(IP)]  [true]  alias set:
                          [@])) &
                         {FLOW,(52,53)=__norm,}
                           ECase case {c=1 -> ECase case {d=0 -> EAssume 36:
                                                                   EXISTS(bh_123,
                                                                   flted_0_114,
                                                                   flted_0_115,
                                                                   flted_0_116: 

# graph2.txt: DONE

Why do two equivalent expression below give different result!

checkentail
x4::ls<x5>
* x3::node<x4>
* x4::ls<x7>
* x4::node<q>
* q::ls<x6> & x4!=x6
& x5!=x7
& x1=x2 & x2=x3
|- false.


checkentail
x3::node<x4>
* x4::ls<x5>
* x4::ls<x7>
* x4::node<q>
* q::ls<x6> & x4!=x6
& x5!=x7
& x1=x2 & x2=x3
|- false.

# test-5a.slk

How come explicit instantiation still have "exist" wrapper?

 checkentail x::sll<n> & n>2 |- [q] x::node<_,q>.

/*

Why is there an EXIST q wrapper for explicit instantiation?

 <1>EXISTS(q,flted_8_243: q::sll<flted_8_243>@M[0][Orig]&n=flted_8_243+1 & 2<n & q=q&{FLOW,(19,20)=__norm})[]


*/
@2! vheap: c'::node<Anon_12'@L,nn'@L>@L[Orig]&true&{FLOW,(1,25)=__flow}[]
@2! vheap 2: c'::node<Anon_12'@L,nn'@L>@L[Orig]&true&{FLOW,(1,25)=__flow}[]


dprint: bind2.ss:16: ctx:  List of Failesc Context: [FEC(0, 0, 1  )]

Successful States:
[
 Label: 
 State:c::node<Anon_11@M,p@M>@M[Orig]&c=c' & 0<=0 & Anon_11=Anon_33' & nn_34'=p&{FLOW,(22,23)=__norm}[]
       es_var_measures: MayLoop
       es_trace: empty

 ]

dprint: bind2.ss:20: ctx:  List of Failesc Context: [FEC(0, 0, 1  )]

Successful States:
[
 Label: 
 State:hfalse&false&{FLOW,(22,23)=__norm}[]

# bind2b1.ss (vs bind2b.ss)  TEMP FIXED fields-->@M

node paper_fix (node c)
  requires c::node<_,p>
  ensures res=p;
{
      node t;
      bind c to (vv,nn) in { t = nn; };
      dprint;
      return t;
}

/*

Why is this bind inferred as @M?
@7! >>>>>> bind type-checker <<<<<<
@7! node:c
@7! fields:[vv_32,nn_33]
@7! node ann:@M
@7! fields ann:[@L,@L]
@7! read-only:false

It should be @L; as in bind2b.ss with
@7! >>>>>> bind type-checker <<<<<<
@7! node:c
@7! fields:[val_15_762,next_15_763]
@7! node ann:@L
@7! fields ann:[@A,@L]
@7! read-only:true
@7!bind2b.ss:15: 10: bind: unfolded context:



*/


# bind2b2.ss   DONE

node paper_fix (node c)
  requires c::node<_,p>
  ensures res=p;
{
      node t;
      t = bind c to (vv,nn) in nn ;
      dprint;
      return t;
}

/*

Why is there a parsing error for bind in the RHS of assignment?

File "bind2b2.ss", line 15, characters 8-9
 --error: Stream.Error("[expression] expected after EQ (in [assignment_expression])")


*/

# bind2e.ss

 bind node lost during exception!

bind node not released by exception!
  1. restore
  2. use try-catch for bind?

dprint: bind2e.ss:17: ctx:  List of Failesc Context: [FEC(0, 1, 0 )]
Escaped States:
[
 
 Try-Block:0::
 [
  Path: 
  State:emp&c=c' & 0<=0 & Anon_11=Anon_36' & nn_37'=p & nn_37'=res&{FLOW,(16,17)=__Return}[]
        es_var_measures: MayLoop
        es_trace: empty

  ]
 ]


# bind2{e3,e4}.ss  DONE 
     (via CF.normalize_max_renaming_list_failesc_context_4_bind)

dprint: bind2e4.ss:18: ctx:  List of Failesc Context: [FEC(0, 1, 0 )]
!!! bind:tmp_res1:[ Escaped States:
 [
  
  Try-Block:62::
  [
   Path: 
   State:emp&c=c' & 0<=0 & Anon_11=Anon_36' & nn_37'=p & nn_37'=res&{FLOW,(16,17)=__Return}[]
         es_var_measures: MayLoop
         es_trace: empty

   ];
  
  ]]

bind2e3.ss

!!! bind:tmp_res1:[ 
 Successful States:
 [
  Label: 
  State:emp&c=c' & 0<=0 & Anon_11=Anon_36' & nn_37'=p & nn_37'=res&{FLOW,(16,17)=__Return}[]
        es_var_measures: MayLoop
        es_trace: empty

  ]]


# TODO how about field level access for bind2{e3,e4}.ss

Trung:

Could you try fix the type problem below 
at default branch? If possible, please also
support type annotation at the infer parameter
list by changing the parser, e.g:
  infer [(x:int)] x=3 & x=x' |-  x>4.

# bugs/cll-type.slk

// why "could not find coherent-type below" ?
// x & x' has the same int type
infer [x] x=3 & x=x'
 |-  x>4.

# cll-t2.slk  FIXED by Trung

infer [x] x::node<val_35_804,next_35_805> & y=null
 |-  y!=null.

/*
Got error which is not present in sa_logging branch.

ERROR: at _0:0_0:0 
Message: x is not found in both sides
 caught

It is not necessary for x to be on both sides;
just one side is sufficient.
*/

infer [x] x::node<val_35_804,next_35_805> & x=y
 |-  x!=null.

/*
Got error which is not present in sa_logging branch.

ERROR: at _0:0_0:0 
Message: x is not found in both sides
 caught

But x ia already on both sides!
*/
==============================================
# bugs/app-2.slk  FIXED

checkentail x::ll_tail2<tx,nnn>@M 
 |-  tx::node<a,b>@L. 
// |-  tx::node<a,b>. 

-dd tracing

It seems that lemmas are not being triggered for@L.

With @L, I got

!!!:0: 0: do_base_case_unfold attempt for :  r_121::ll_tail2<tx_118,flted_12_119>@M[1][Orig]
!!!:0: 0: do_base_case_unfold attempt : unsuccessful for :  r_121::ll_tail2<tx_118,flted_12_119>@M[1][Orig]
!!!:0: 0: process_action :
 ### action =  LHSCaseAnalysis =>
                    Type: MaterializedArg (tx,partial,) view_defn_mater
                    LHS: x::ll_tail2<tx,nnn>@M[0][Orig][LHSCase]
                    RHS: tx::node<a,b>@L[Orig]
 lhs_rest: Hole[93]
 rhs_rest: emp
 ### estate =  x::ll_tail2<tx,nnn>@M[0][Orig][LHSCase]&true&{FLOW,(19,20)=__norm}[]
 ### conseq =  tx::node<a,b>@L[Orig]&true&{FLOW,(19,20)=__norm}[]


!!!:0: 0: do_lhs_case : unsuccessful for :  x::ll_tail2<tx,nnn>@M[0][Orig][LHSCase]
Entail (1) : Fail.


With @M, I got:

!!!:0: 0: process_action :
 ### action =  Lemma ==> ll_tail2 =>
                       Type: MaterializedArg (tx_116,partial,) coerc_defn_mater: ==> ll_tail2
                       LHS: r_119::ll_tail2<tx_116,flted_12_117>@M[1][Orig]
                       RHS: tx::node<a,b>@M[Orig]
 lhs_rest: x::node<Anon_118,r_119>@M[Orig]
 rhs_rest: emp
 ### estate =  x::node<Anon_118,r_119>@M[Orig] * r_119::ll_tail2<tx_116,flted_12_117>@M[1][Orig]&nnn=flted_12_117+1 & r_119!=null & tx=tx_116&{FLOW,(19,20)=__norm}[]
 ### conseq =  tx::node<a,b>@M[Orig]&true&{FLOW,(19,20)=__norm}[]


!!!:0: 0: do_coercion: estate : es_formula: 
  x::node<Anon_118,r_119>@M[Orig] * 
  r_119::ll_tail2<tx_116,flted_12_117>@M[1][Orig]&nnn=flted_12_117+1 & 
  r_119!=null & tx=tx_116&{FLOW,(19,20)=__norm}[]
 es_pure: true
 es_orig_ante: None

============================================================
# bug-base-case-2.slk  FIXED (lhs-case disabled by default)

performance bug

lhs-case-analysis seem to have triggered many alternatives:
Is there a way to apply lemma wo resorting to LHS case analysis,
so that (1) would work

Entail (2) : Valid. 

 <1>
    emp&q3=t & q=self & n!=self & q3=t & Anon_16=Anon_17 & q3!=self&
    {FLOW,(19,20)=__norm}[]
    or emp&n!=self & q3!=t & Anon_16=Anon_17 & self!=t&
       {FLOW,(19,20)=__norm}[]
    
<2>
   emp&q3=t & q=self & n!=self & q3=t & Anon_16=Anon_17&
   {FLOW,(19,20)=__norm}[]
   or emp&n!=self & q3!=t & Anon_16=Anon_17 & self!=t&{FLOW,(19,20)=__norm}[]
   
<3>emp&n!=self & Anon_16=Anon_17 & self!=t&{FLOW,(19,20)=__norm}[]
<4>
   emp&q3=t & q=self & n!=self & Anon_16=Anon_17 & q3=t & q3!=self&
   {FLOW,(19,20)=__norm}[]
   or emp&n!=self & Anon_16=Anon_17 & q3!=t & self!=t&{FLOW,(19,20)=__norm}[]
   
<5>
   emp&q3=t & q=self & n!=self & Anon_16=Anon_17 & q3=t & q3!=self&
   {FLOW,(19,20)=__norm}[]
   or emp&n!=self & Anon_16=Anon_17 & q3!=t & self!=t&{FLOW,(19,20)=__norm}[]

--dis-lhs-case

Entail (2) : Valid. 

 <1>emp&n!=self & Anon_16=Anon_17 & self!=t&{FLOW,(19,20)=__norm}[]

================================================================================================
# bug-lem-2.slk  FIXED

lemma "dll_r5_tail2" self::dll_r5<p,t,n>  
  <- self::dll_r5<p,q,t> * t::node<_,q,n> & self!=n.

/*

find_materialized_prop@1
find_materialized_prop inp1 :[self,p,t,n]
find_materialized_prop inp2 : {1}->EXISTS(p_13,t_14,q_15,n_16,q,Anon_11: 
 self::node<p_13,q,t_14>@M[Orig] * t::node<Anon_11,q_15,n_16>@M[Orig]
   &n!=self & p=p_13 & t=t_14 & q=q_15 & 
  n=n_16&{FLOW,(1,22)=__flow})[]

find_materialized_prop@1 EXIT out :[ (self,full,), (t,full,)]

find_materialized_prop@2
find_materialized_prop inp1 :[self,p,t,n]
find_materialized_prop inp2 : 
EXISTS(q_32,Anon_12,q: 
 self::dll_r5<p,q,t>@M#O[dll_r5_tail2][0][Derv][LHSCase] * 
 t::node<Anon_12,q_32,n>@M[Derv]&n!=self & q=q_32&{FLOW,(1,22)=__flow})[]

find_materialized_prop@2 EXIT out :[ (n,full,[dll_r5]), (p,full,[dll_r5]), (self,full,[dll_r5]), (t,partial,)]

find_materialized_prop@3@2
find_materialized_prop inp1 :[self,p,t,n]
find_materialized_prop inp2 : EXISTS(q_33,Anon_12,
q: self::dll_r5<p,q,t>@M#O[dll_r5_tail1][0][Derv][LHSCase] * 
t::node<Anon_12,q_33,n>@M[Derv]&q=q_33&{FLOW,(1,22)=__flow})[]
find_materialized_prop@3 EXIT out :[ (n,full,[dll_r5]), (p,full,[dll_r5]), (self,full,[dll_r5]), (t,partial,)]

EXPECT:
 find_materialized_prop@3 EXIT out :[(self,full,[dll_r5]), (t,partial,)]

*/

pred A<> == self=null  or  self::tree<c>* c::B<>
 inv true.
pred B<> == self=null or  self::node<c>* c::A<>
 inv true.

===================================================================

# mut-bug-1.slk  FIXED

Why is B<> pick as a type decaration rather
than view declaration? In mut-1.slk, we can
have mutual predicates with more than 1 parameter.

SOLN : If type declaration is not found, please
 assume that it is a view declaration.


ERROR: at mut-bug-1.slk_15:42_15:48 
Message: no type declaration named B is found
 
ERROR: at mut-bug-1.slk_17:41_17:47 
Message: no type declaration named A is found
===================================================================
# bugs/rose-bug-type.ss 

Why is there a type: check_child$node~tree~null

ERROR: at rose-bug-type.ss_31:15_31:45 
Message: trans_exp :: case CallNRecv :: procedure 2 check_child$node~tree~null is not found
 Stop Omega... 26 invocations Halting Reduce... 
caught
===================================================================
# bugs/rose-bug-type2.ss 

Typechecker has failed to pick error below with check_child(t.children,t,t)

Why wasn't check_child(t.children,t,t) flagged
as a type error. The error only appeared during trans_exp

ERROR: at rose-bug-type2.ss_32:15_32:42 
Message: trans_exp :: case CallNRecv :: procedure 2 check_child$node~tree~tree is not found
===================================================================
# swl.ss --en-logging-txt -tp om
./hip bugs/schorr-waite-list.ss -tp om --en-logging-txt  > a

PROBLEMS (i) could simplifier help push existential inwards
             and/or eliminate them, e.g nxt can be elim, while
             Mnt can be pushed inwards
(ii) Why ante/conseq seems to be wrong way for some examples
     such as 149 below.
-------------------- 
 id: 150; prover: ; loc: swl_ss_12:11_12:43; kind: Pred_Check_Inv
 Simplify:  exists(Mnxt:exists(nxt:M=union(Mnxt,bag({self})) & s!=self & self!=null & 
nxt!=s))
 res:  exists(Mnxt:exists(nxt:M=union(Mnxt,bag({self})) & s!=self & self!=null & 
nxt!=s))
 -------------------- 
 id: 149; prover: ; loc: swl_ss_12:11_12:43; kind: Pred_Check_Inv
 Imply: ante: s!=self
	     conseq:  (exists(Mnxt:exists(nxt:M=union(Mnxt,bag({self})) & s!=self & self!=null & 
nxt!=s)) | (self=null & M=bag() & s!=self))
 res: false
 -------------------- 
We have 4 large timeout from the above. Two of them seem to have exceeded
the 5s timeout we impose on mona proof. Why is this so?

no_eps_proof_log_bugs_schorr-waite-list_ss.txt:358: id: 192; prover: MONA; TIME: 17.149072; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:417: id: 196; prover: MONA; TIME: 4.832302; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:790: id: 234; prover: MONA; TIME: 26.361647; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:806: id: 235; prover: MONA; TIME: 4.880305; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC

However, when I run it separately as a sleek command (see time.slk);
it seems to have adhered to the default time limits of 5seconds.

----------------


no_eps_proof_log_bugs_schorr-waite-list_ss.txt:358: id: 192; prover: MONA; TIME: 21.965372; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:417: id: 196; prover: MONA; TIME: 9.73661; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:790: id: 234; prover: MONA; TIME: 31.249953; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:806: id: 235; prover: MONA; TIME: 9.732609; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC

--------

no_eps_proof_log_bugs_schorr-waite-list_ss.txt:358: id: 192; prover: MONA; TIME: 16.365021; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:417: id: 196; prover: MONA; TIME: 3.908244; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:790: id: 234; prover: MONA; TIME: 25.205576; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:806: id: 235; prover: MONA; TIME: 3.864241; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:1749: id: 314; prover: MONA; TIME: 42.110632; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC

-------


----------

which seems to have exceeded the 3 sec timeout we placed
for imply_timeout. Can we check why these are not being
enforced by mona prover?

imply_timeout@34
imply_timeout inp1 : Mc=union(Mnxt_1007,bag({cur_1016})) & cur_1016!=sentinel_1008 & 
s_1004=sentinel_1008 & cur=cur_1016 & prev=prev_1015 & sentinel=sentinel' & 
cur!=null & sentinel=sentinel_1008 & sentinel=sentinel_1009 & 
n_50'=nxt_1006 & next_33_1014=nxt_1006 & cur_1016=prev_1027 & 
cur_1026=n_50' & cur_1026!=sentinel' & !(v_bool_37_944') & 
cur_1026!=sentinel' & !(v_bool_37_944') & cur_1026=null & v_bool_38_945' & 
cur_1026=null & v_bool_38_945' & cur'=prev_1027 & prev'=null & 
exists(sentinel_1061:cur'=sentinel_1061) & Mc_1030=bag() & 
exists(sentinel_1062:prev'!=sentinel_1062) & Mp_1031=bag() & 
(((exists(Mnxt:Mnxt_1007=union(Mnxt,bag({nxt_1006}))) & nxt_1006!=s_1004 & 
nxt_1006!=null) | (nxt_1006=null & Mnxt_1007=bag() & nxt_1006!=s_1004))) & 
(((exists(M1:Mp=union(bag({prev}),M1)) & prev!=sentinel_1009 & prev!=null) | 
(prev=sentinel_1009 & Mp=bag()))) & cur_1016!=null
imply_timeout inp2 : cur'=sentinel'
imply_timeout inp3 :timeout:3.
imply_timeout inp4 :234
imply_timeout@34 EXIT out :false
[mona.ml]:Timeout exception


 id: 234; prover: MONA; TIME: 31.249953; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
 Imply: ante: Mc=union(Mnxt_1007,bag({cur_1016})) & cur_1016!=sentinel_1008 & 
s_1004=sentinel_1008 & cur=cur_1016 & prev=prev_1015 & sentinel=sentinel' & 
cur!=null & sentinel=sentinel_1008 & sentinel=sentinel_1009 & 
n_50'=nxt_1006 & next_33_1014=nxt_1006 & cur_1016=prev_1027 & 
cur_1026=n_50' & cur_1026!=sentinel' & !(v_bool_37_944') & cur_1026=null & 
v_bool_38_945' & cur'=prev_1027 & prev'=null & Mc_1030=bag() & 
exists(sentinel_1108:prev'!=sentinel_1108) & Mp_1031=bag() & 
(((exists(Mnxt_1107:Mnxt_1007=union(Mnxt_1107,bag({nxt_1006}))) & 
nxt_1006!=s_1004 & nxt_1006!=null) | (nxt_1006=null & Mnxt_1007=bag() & 
nxt_1006!=s_1004))) & (((exists(M1_1106:Mp=union(bag({prev}),M1_1106)) & 
prev!=sentinel_1009 & prev!=null) | (prev=sentinel_1009 & Mp=bag()))) & 
cur_1016!=null
	     conseq:  cur'=sentinel'
 res: false

===================================================================
# swl-num.ss

Why ante/conseq seem to be reversed here? Is this
really required since we known inv is just an approx.

id: 150; prover: OMEGA CALCULATOR; loc: swl-num_ss_12:11_12:40; kind: Pred_Check_Inv
 Imply: ante: 0<=n & s!=self
	     conseq:  ((n=0 & self=null & self<=(s-1)) | (s<self & self!=null & 1<=n) | 
(self!=null & self<s & 1<=n) | (n=0 & s<self & self=null))
 res: false
===================================================================
# "bug-lbl-1.ss"

lg<"n":s,"b":M> == true & ["n":self = null & self != s; "b":M = {}] 
	or self::node<_,nxt> * nxt::lg<s,Mnxt> & ["b": M = union(Mnxt,{self}); "n": self != s]
inv ["n":self!=s];

since inv is supposed to contain just pure, why can't
we have:
inv ["n":self!=s];

Parsing file "bug-lbl-1.ss" by default parser...
File "bug-lbl-1.ss", line 9, characters 4-5
 --error: Stream.Error("[exl_pure] expected after OSQUARE (in [cexp_w])")
 at:(Program not linked with -g, cannot print stack backtrace)
===================================================================
# swl-lbl.ss -tp om --en-logging-txt

poor exists formation at expense of labels.
On the LHS, perhaps existential can be removed by
simply replacing with free vars. On the RHS,
existentials must be kept.

 id: 157; prover: MONA; loc: swl-lbl_ss_8:4_8:87; kind: Compute_Base_Case
 Simplify:  exists(Mnxt:exists(nxt:nxt!=s & nxt!=null & 
exists(Mnxt_858:Mnxt=union(Mnxt_858,bag({nxt})))) & M=union(Mnxt,
bag({self})))
 res:  exists(Mnxt:exists(nxt:nxt!=s & nxt!=null & 
exists(Mnxt_858:Mnxt=union(Mnxt_858,bag({nxt})))) & M=union(Mnxt,
bag({self})))

how did we get a [b,n]:

 id: 161; prover: MONA; loc: swl-lbl_ss_8:4_8:87; kind: Compute_Base_Case
 Sat:  (((AndList ([],self!=null) & ([b],M=union(bag(),bag({self})))
 & ([n],self=null & s!=self & s!=self & s!=null)) ) | 
((AndList ([b,n],exists(Mnxt:exists(nxt:nxt!=s & nxt!=null & 
          exists(Mnxt_858:Mnxt=union(Mnxt_858,bag({nxt})))) & M=union(Mnxt,
          bag({self}))) & s!=self & self!=null)
 & ([n],self=null & s!=self)) ))
 res: UNSAT

===================================================================
./hip bugs/schorr-waite-list.ss -tp om --en-logging-txt  > a

We have 4 large timeout from the above. Two of them seem to have exceeded
the 5s timeout we impose on mona proof. Why is this so?

no_eps_proof_log_bugs_schorr-waite-list_ss.txt:358: id: 192; prover: MONA; TIME: 17.149072; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:417: id: 196; prover: MONA; TIME: 4.832302; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:790: id: 234; prover: MONA; TIME: 26.361647; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:806: id: 235; prover: MONA; TIME: 4.880305; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC

However, when I run it separately as a sleek command;
it seems to have adhered to the default time limits.
----------------


no_eps_proof_log_bugs_schorr-waite-list_ss.txt:358: id: 192; prover: MONA; TIME: 21.965372; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:417: id: 196; prover: MONA; TIME: 9.73661; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:790: id: 234; prover: MONA; TIME: 31.249953; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:806: id: 235; prover: MONA; TIME: 9.732609; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC

--------

no_eps_proof_log_bugs_schorr-waite-list_ss.txt:358: id: 192; prover: MONA; TIME: 16.365021; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:417: id: 196; prover: MONA; TIME: 3.908244; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:790: id: 234; prover: MONA; TIME: 25.205576; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:806: id: 235; prover: MONA; TIME: 3.864241; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:1749: id: 314; prover: MONA; TIME: 42.110632; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC

-------


----------

which seems to have exceeded the 3 sec timeout we placed
for imply_timeout. Can we check why these are not being
enforced by mona prover?

imply_timeout@34
imply_timeout inp1 : Mc=union(Mnxt_1007,bag({cur_1016})) & cur_1016!=sentinel_1008 & 
s_1004=sentinel_1008 & cur=cur_1016 & prev=prev_1015 & sentinel=sentinel' & 
cur!=null & sentinel=sentinel_1008 & sentinel=sentinel_1009 & 
n_50'=nxt_1006 & next_33_1014=nxt_1006 & cur_1016=prev_1027 & 
cur_1026=n_50' & cur_1026!=sentinel' & !(v_bool_37_944') & 
cur_1026!=sentinel' & !(v_bool_37_944') & cur_1026=null & v_bool_38_945' & 
cur_1026=null & v_bool_38_945' & cur'=prev_1027 & prev'=null & 
exists(sentinel_1061:cur'=sentinel_1061) & Mc_1030=bag() & 
exists(sentinel_1062:prev'!=sentinel_1062) & Mp_1031=bag() & 
(((exists(Mnxt:Mnxt_1007=union(Mnxt,bag({nxt_1006}))) & nxt_1006!=s_1004 & 
nxt_1006!=null) | (nxt_1006=null & Mnxt_1007=bag() & nxt_1006!=s_1004))) & 
(((exists(M1:Mp=union(bag({prev}),M1)) & prev!=sentinel_1009 & prev!=null) | 
(prev=sentinel_1009 & Mp=bag()))) & cur_1016!=null
imply_timeout inp2 : cur'=sentinel'
imply_timeout inp3 :timeout:3.
imply_timeout inp4 :234
imply_timeout@34 EXIT out :false
[mona.ml]:Timeout exception


 id: 234; prover: MONA; TIME: 31.249953; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
 Imply: ante: Mc=union(Mnxt_1007,bag({cur_1016})) & cur_1016!=sentinel_1008 & 
s_1004=sentinel_1008 & cur=cur_1016 & prev=prev_1015 & sentinel=sentinel' & 
cur!=null & sentinel=sentinel_1008 & sentinel=sentinel_1009 & 
n_50'=nxt_1006 & next_33_1014=nxt_1006 & cur_1016=prev_1027 & 
cur_1026=n_50' & cur_1026!=sentinel' & !(v_bool_37_944') & cur_1026=null & 
v_bool_38_945' & cur'=prev_1027 & prev'=null & Mc_1030=bag() & 
exists(sentinel_1108:prev'!=sentinel_1108) & Mp_1031=bag() & 
(((exists(Mnxt_1107:Mnxt_1007=union(Mnxt_1107,bag({nxt_1006}))) & 
nxt_1006!=s_1004 & nxt_1006!=null) | (nxt_1006=null & Mnxt_1007=bag() & 
nxt_1006!=s_1004))) & (((exists(M1_1106:Mp=union(bag({prev}),M1_1106)) & 
prev!=sentinel_1009 & prev!=null) | (prev=sentinel_1009 & Mp=bag()))) & 
cur_1016!=null
	     conseq:  cur'=sentinel'
 res: false

===================================================================
# bug-2-swl.ss -tp om -nxpure 0

Procedure lscan$node~node~node FAIL-2

Exception Failure("Mona translation failure!!\nError in file monatemp line  column ") Occurred!
(Program not linked with -g, cannot print stack backtrace)

Error(s) detected when checking procedure lscan$node~node~node
Stop Omega... 37 invocations 
1 false contexts at: ( (42,24) )

Total verification time: 30.165884 second(s)
	Time spent in main process: 0.380023 second(s)
	Time spent in child processes: 29.785861 second(s)
===================================================================
# bug-3-view-swl.ss -tp om  # FIXED

when the invariant of a view fail, it did not report
a view name which could be helpful.
===================================================================
# bug-2-swl.ss

find_order@36
find_order inp1 : (!((Mc_r36=union(Mnxt_1017_r36,{cur_1026_r36}) & 
cur_1026_r36!=sentinel_1018_r36 & s_1014_r36=sentinel_1018_r36 & 
cur_1026_r36=cur_r36 & prev_1025_r36=prev_r36 & sentinel_r36=sentinel_r36' & 
cur_r36!=null & sentinel_1018_r36=sentinel_r36 & 
sentinel_1019_r36=sentinel_r36 & n_50_r36'=nxt_1016_r36 & 
next_39_1024_r36=nxt_1016_r36 & cur_1026_r36=prev_1037_r36 & 
cur_1036_r36=n_50_r36' & cur_1036_r36!=sentinel_r36' & 
!(v_bool_43_957_r36') & NULLV_r36=cur_1036_r36 & v_bool_44_958_r36' & 
cur_r36'=prev_1037_r36 & NULLV_r36=prev_r36' & Mc_1040_r36={} & 
nxt_1016_r36!=s_1014_r36 & (((NULLV_r36=nxt_1016_r36 & Mnxt_1017_r36={}) | 
(nxt_1016_r36!=null & Mnxt_1017_r36!=({})))) & 
(((prev_r36=sentinel_1019_r36 & Mp_r36={}) | (prev_r36!=sentinel_1019_r36 & 
Mp_r36!=({}) & prev_r36!=null))) & cur_1026_r36!=null & NULLV_r36=null)) | 
prev_r36'!=sentinel_1064_r36)
find_order inp2 :
find_order res2 :; (sentinel_1019_r36 1); (v_bool_43_957_r36' 2); (prev_r36 1); (prev_r36' 1); (Mp_r36 2); (s_1014_r36 1); (prev_1037_r36 1); (cur_1026_r36 1); (Mc_r36 2); (sentinel_r36 1); (sentinel_1018_r36 1); (cur_r36' 1); (cur_1036_r36 1); (prev_1025_r36 1); (Mnxt_1017_r36 2); (n_50_r36' 1); (v_bool_44_958_r36' 2); (nxt_1016_r36 1); (next_39_1024_r36 1); (sentinel_r36' 1); (cur_r36 1); (sentinel_1064_r36 0); (prev_r36' 0); (Mc_1040_r36 2); (NULLV_r36 1)
find_order@36 EXIT out :?

# bug-2-swl.slk

find_order@3
find_order inp1 : (!((Mc_r3=union(Mnxt_1017_r3,{cur_1026_r3}) & 
cur_1026_r3!=sentinel_1018_r3 & s_1014_r3=sentinel_1018_r3 & 
cur_1026_r3=cur_r3 & prev_1025_r3=prev_r3 & sentinel_r3=sentinel_r3' & 
cur_r3!=null & sentinel_1018_r3=sentinel_r3 & sentinel_1019_r3=sentinel_r3 & 
n_50_r3'=nxt_1016_r3 & next_39_1024_r3=nxt_1016_r3 & 
cur_1026_r3=prev_1037_r3 & cur_1036_r3=n_50_r3' & 
cur_1036_r3!=sentinel_r3' & !(v_bool_43_957_r3') & NULLV_r3=cur_1036_r3 & 
v_bool_44_958_r3' & cur_r3'=prev_1037_r3 & NULLV_r3=prev_r3' & 
Mc_1040_r3={} & nxt_1016_r3!=s_1014_r3 & (((NULLV_r3=nxt_1016_r3 & 
Mnxt_1017_r3={}) | (nxt_1016_r3!=null & Mnxt_1017_r3!=({})))) & 
(((prev_r3=sentinel_1019_r3 & Mp_r3={}) | (prev_r3!=sentinel_1019_r3 & 
Mp_r3!=({}) & prev_r3!=null))) & cur_1026_r3!=null & NULLV_r3=null)) | 
prev_r3'!=sentinel_1064_r3)
find_order inp2 :
find_order res2 :; (sentinel_1018_r3 1); (sentinel_1019_r3 1); (s_1014_r3 1); (Mc_1040_r3 2); (sentinel_r3 1); (cur_r3' 1); (prev_1037_r3 1); (NULLV_r3 1); (sentinel_r3' 1); (v_bool_43_957_r3' 2); (n_50_r3' 1); (prev_r3 1); (cur_r3 1); (cur_1026_r3 1); (v_bool_44_958_r3' 2); (Mp_r3 2); (Mnxt_1017_r3 2); (sentinel_1064_r3 1); (next_39_1024_r3 1); (nxt_1016_r3 1); (cur_1036_r3 1); (prev_r3' 1); (prev_1025_r3 1); (Mc_r3 2)
find_order@3 EXIT out :?
===================================================================
# ../hip schorr-waite-list-2.ss -tp om --en-logging-txt

The time-out for MONA is currently 5s. However, some tasks
are taking much longer. Is this due to some batch mode task
rather than interactive tasks? Is it possible to always
use interactive MONA proving? Why do we need batch MONA proving?

no_eps_proof_log_schorr-waite-list-2_ss.txt:350: id: 192; prover: MONA; TIME: 15.412962; loc: schorr-waite-list-2_ss_48:2_48:26; kind: PRE_REC
no_eps_proof_log_schorr-waite-list-2_ss.txt:392: id: 195; prover: MONA; TIME: 4.94431; loc: schorr-waite-list-2_ss_48:2_48:26; kind: PRE_REC
no_eps_proof_log_schorr-waite-list-2_ss.txt:685: id: 233; prover: MONA; TIME: 13.892869; loc: schorr-waite-list-2_ss_48:2_48:26; kind: PRE_REC

===================================================================
# schorr-waite-list-lbl.ss -tp om --en-sleek-logging-txt

There are two problems:
 (i) printing of ANDLIST can be more compact (see sleek log file)
 (ii) we have a failure below. can we figure out why?

 id: 98; caller: []; line: 27; classic: false; kind: [POST,
Check_Specs]; hec_num: 4; evars: [sentinel_1404,M_1405]; infer_vars: []; c_heap: 
prev::lg<sentinel_1255,Mp>@M * cur_1262::node<Anon_1251,prev_1261>@M

 checkentail nxt_1252::ls<p_1250,M1_1253>@M&
AndList[ []:cur=cur_1262 & prev=prev_1261 & n_42'=nxt_1252 & 
         next_33_1260=nxt_1252 & cur_1262=prev' & cur'=n_42' & 
         cur'=sentinel & v_bool_37_933' & cur'=sentinel & v_bool_37_933'
 ; ["n"]:cur_1262!=sentinel_1254 & p_1250=sentinel_1254 & cur!=sentinel & 
   sentinel=sentinel_1254 & sentinel=sentinel_1255 & 
   exists(sentinel_1404:sentinel_1255=sentinel_1404 & prev'!=sentinel_1404)
 ; ["s"]:Mc=union({cur_1262},M1_1253) & exists(M_1405:M_1405=union(Mp,
   {prev'}))] &
{FLOW,(22,23)=__norm}[]
 |-  EXISTS(sentinel_1404,M_1405: emp&
AndList[ ["n"]:cur'=sentinel & sentinel=sentinel_1404 & 
         sentinel_1255=sentinel_1404 & prev'!=sentinel_1404
 ; ["s"]:M_1405=union(Mc,Mp) & M_1405=union(Mp,{prev'})] &
{FLOW,(22,23)=__norm})[]. 
res:  failctx
         fe_kind: MAY
         fe_name: logical bug
         fe_locs: {
                   fc_message: failed in entailing pure formula(s) in conseq
                   fc_current_lhs_flow: {FLOW,(22,23)=__norm}}
===================================================================
# swl-x2b.slk  CG fixing label.ml

"" should be treated as a common label, so that below
succeeds.

checkentail true &
 ["": x=5;
  "n": y>x]
 |- true & 
     ["n":y>5].
===================================================================
# ll-back-3a.ss

This example works in default but not sa_logging branch!

Parsing file "ll-back-3a.ss" by default parser...

!!!  processing primitives "["prelude.ss"]
Starting Omega...oc

!!! dumping for finalize on hipStop Omega... 1 invocations caught
(Program not linked with -g, cannot print stack backtrace)

Exception occurred: Not_found
Error3(s) detected at main 

====================================================================
# 13-5.slk --sa-en-cont

infer [H1] H1(y)  |- y::lseg<null> .
print residue.

WARNING : Pushing 2 stk_estate (4)
Message: unsat_xpure : encountered a disjunctive formula 
!!! WARNING logtime exception:0.004caught
(Program not linked with -g, cannot print stack backtrace)
Entailment Failure (1) Failure("unsat_xpure : encountered a disjunctive formula \n")
===================================================================
# i13-5.slk

xform has self>0 instead of self!=null

  {1}->emp&p=self&{FLOW,(1,22)=__flow}[]
   || {2}->(exists p_12,q: self::node<q>@M * q::lseg<p_12>@M&p!=self & 
      p=p_12&{FLOW,(1,22)=__flow})[]
  xform: ((p!=self & self>0) | p=self)

===================================================================
# i13-5a.slk  (in bugs)

infer [H1] H1(y) & (x=2 | x>5)  |- y::lseg<null> .

./sleek i13-5a.slk --sa-en-cont --iesa --dsd

Using above triggers an unsat_xpure exception

!!! infer_deep_ante_issues triggered by --iesa
!!! if stk_estate > 1, can cause unsat_xpure exception
!!! Thai : can we convert below to single ctx by using pure or rather than CtxOr
!!! new_ante_fmls:[ HP_40(flted_18_39)&flted_18_39=null&{FLOW,(19,20)=__norm}[]]

ISSUES 
 1. added a flag --infer-en-split-ante that
    would trigger deep_lhs split of antecedent for pure inference
 2. Added simplify_with_pairwise to reduce disjunction
 3. To address
    - minimise on stk-estate
    - use pure disjunct rather than heap disjunct
    - balanced use of deep_lhs
      (i) try normal infer_pure first
      (ii) if fail, try deep_lhs cases?

keyword in code :  infer_deep_ante_issues 

For i13-5a example, the following are points to note:

This example added:

!!! WARNING : deep-ante-split activated
!!! split-1:[ x=2, 5<x]
!!! split-2:[ ((x=2 | 5<x)) & (((flted_18_41!=y & y!=null) | flted_18_41=y))]WARNING : Pushing 2 stk_estate (4)
 
However, we later generated two identical LHS term, that was
triggered by split of [x=2, 5<x]. Such split is probably
not meaningful since x is not an inferrable var but is
currently triggered by --iesa

It later generated two identical residue, and probably two
rel assumption, as well.

!!! new_ante_fmls:[ 
HP_42(flted_18_41)&flted_18_41=null&{FLOW,(19,20)=__norm}[], 
HP_42(flted_18_41)&flted_18_41=null&{FLOW,(19,20)=__norm}[]
]

I think you should do 2 things (i) first; then (ii)
(i) combine new_ante_fmls into a single pure-or always so
    that the unsat exception do not occur
(ii) allow infer_pure_m to be triggered on its own first;
     if it succeeds do not do deep_ante_split
(iii) there is also an issue with identical rel_assume 
    being introduced; but as this is harmless I think u
    may skip it first.

===================================================================
# baga-2.slk

pred l4<q> == 
  self::node<q>*q::node<_>
inv self!=null.
// baga {self,q}

pred l5<k> == 
  self::node<q>*q::node<_> & k=q
inv self!=null.

l4 is Ok but l5 is missing on 
a baga address.

need to get visible parameters and
extract equality from pure formula 
for substitution in xpure_symbolic

 missing on k for baga formula
 addr vars: self
  uni_vars: []
  bag of addr: self
  view_complex_inv: None
===================================================================
# baga-2.slk

(i) duplicated calls to formula_2_mem..
(ii) are they critical?

formula_2_mem@1
formula_2_mem inp1 : {1}->(exists q,Anon_11: self::node<q>@M * q::node<Anon_11>@M&k=q & q!=self&
{FLOW,(1,22)=__flow})[]
formula_2_mem@1 EXIT out : [[self,q]]

formula_2_mem@3
formula_2_mem inp1 : {1}->(exists q,Anon_11: self::node<q>@M * q::node<Anon_11>@M&k=q & q!=self&
{FLOW,(1,22)=__flow})[]
formula_2_mem@3 EXIT out : [[self,q]]

!!! xform(mix): exists(q:k=q & q!=self & q!=null) & self!=null
!!! view_addr_vars:[self]
!!! view_vars:[k]
!!! view_baga:[self,q]
!!! new_baga:[self]

formula_2_mem@5
formula_2_mem inp1 : {1}->(exists q,Anon_11: self::node<q>@M * q::node<Anon_11>@M&k=q & q!=self&
{FLOW,(1,22)=__flow})[]
formula_2_mem@5 EXIT out : [[self,q]]

formula_2_mem@7
formula_2_mem inp1 : {1}->(exists q,Anon_11: self::node<q>@M * q::node<Anon_11>@M&k=q & q!=self&
{FLOW,(1,22)=__flow})[]
formula_2_mem@7 EXIT out : [[self,q]]

formula_2_mem@9
formula_2_mem inp1 : {1}->self::node<q>@M * q::node<Anon_11>@M&k=q & q!=self&
{FLOW,(1,22)=__flow}[]
formula_2_mem@9 EXIT out : [[self,q]]

===================================================================
# baga-3.slk

pred l3a<> == 
  self::node<q>*q::node<_>  & self=q
inv self!=null.

  prune baga conditions: ([q])-1,([self])-2
should be:
  prune baga conditions: ([q])-1,([self,self])-2

pred l6<q:node> == 
  q::node<_> & self=null
  or self::node<r>*r::node<_> & r=q
inv q!=null.

Got:
  prune invs:3:
   ,[{1,2} -> {[q]} [ q!=null]; {1} -> {[q]} [ self=null; q!=null]; 
   {2} -> {[self]} [ q!=null; self!=null]]
Should be:
  prune invs:3:
   ,[{1,2} -> {[q]} [ q!=null]; {1} -> {[q]} [ self=null; q!=null]; 
   {2} -> {[self,q]} [ q!=null; self!=null]]

pred l7<q:node> == 
  self=null & q=null
  or self::node<r>*r::node<_> & r=q
inv true.

GOT:
  prune invs:3:
   ,[{4,5} -> {[]} []; {4} -> {[]} [ self=null; q=null]; 
   {5} -> {[self]} [ self!=null; q!=null]]
should be:
  prune invs:3:
   ,[{4,5} -> {[]} []; {4} -> {[]} [ self=null; q=null]; 
   {5} -> {[self,q]} [ self!=null; q!=null]]

===================================================================
# bug-classic-4a.slk: FIXED

infer_exact
[P1] n::node<_,null> & self=null
|- P1(self).
print residue.

 <1>(exists flted_23_51: emp&flted_23_51=null & self=null&{FLOW,(19,20)=__norm})[]
 inferred hprel: [// Sleek_Entail(2)
n::node<Anon_14,flted_23_51>@M&flted_23_51=null & 
self=null --> P1(self)]

PROBLEM : why did we include an unrelated n::node<_,null>
 when folding with unknown predicate?
===================================================================
# sp-5a.slk, sp-5b.slk: FIXED

These are very basic examples. I am surprised that they could
be wrong..

//(3)
infer_exact [P1] 
   self=null
|- P1(p) & self=p.
print residue.
// expect self=null --> P1(self)
/*
 <1>emp&self=null & p=null&{FLOW,(19,20)=__norm}[]
 inferred hprel: [// Sleek_Entail(1)
emp --> P1(p_18); 
// Sleek_Entail(1)
P1(p) --> emp&
p=null]
*/


//(3)
infer [P1] 
   self=null
|- P1(p) & self=p.
print residue.
// expect self=null --> P1(self)
/*
// Sleek_Entail(2)
P1(p) --> emp&
p=null]
*/

Entail (3) : Valid. 



//(3)
infer [P1] 
   self=null
|- P1(self) & self=p.
print residue.
// expect self=null --> P1(self)

/*
 <1>emp&self=null & p=self&{FLOW,(19,20)=__norm}[]
 inferred hprel: [// Sleek_Entail(3)
emp --> P1(p)]
*/


===================================================================
# sp-5c.slk: # sp-5e.slk: FIXED

//4
infer [P1] 
   self::node<_,_> 
|- P1(self) & self!=null.
print residue.

/*
// expecting it to succeed
// self::node<_,_> --> P1(self)

c_heap should come from LHS..

 --------------------
!!!  
id: 11; caller: []; line: 0; classic: false; kind: Sleek_Entail(4); hec_num: 4; evars: []; infer_vars: []; c_heap: P1(self)
 checkentail emp&{FLOW,(19,20)=__norm}[]
 |-  emp&self!=null&{FLOW,(19,20)=__norm}[]. 

*/

===================================================================
# baga-test-fail.slk

Unsound as below succeeded, even though it is supposed
to fail. The error was introduced when merging from default.

pred l6<q:node> == 
  q::node<_> & self=null
  or self::node<r>*r::node<_> & r=q
inv q!=null.
// baga {q}

// (9) Fail
checkentail x::l6<_> * x::l6<_> |- false.
===================================================================
# err-pure-inf.slk

Old branch (term-si) supports both inference below.
However, sa_logging fails for the second one. Why?
It seems pure inference is now somewhat broken here.

infer [a,b]   b=c |- a>b.
print residue.

infer [a,c]   b=c |- a>b.
print residue.

Old branch @ term_si give correct result:

Entail (1) : Valid. 
 <1>Base emp&b=c & b<a&{FLOW,(19,20)=__norm}[]
 inferred pure: [b<a]


Entail (2) : Valid. 
 <1>Base emp&b=c & c<a&{FLOW,(19,20)=__norm}[]
 inferred pure: [c<a]

# run-fast-test

Total number of errors: 5 in files:
  infer/infer5.slk({E3#Fail}) infer/infer12.slk({E14#Fail},{E3#Valid}) infer/infer13.slk({E5#Valid}) infer/infer14.slk({E14#Valid},{E16#Valid}) infer/infer16.slk({E5#Valid},{E6#Valid}).
T
===================================================================
# bugs/bubble-1.ss --esl --en-inf -p bubble

Can we tidy printing for --esl. It could be
an option that is on by default (e.g. --print-tidy)

 --------------------
!!!dumping for bubble$node FAIL2
!!!  
id: 423; caller: []; line: 51; TIME: 0.83; classic: false; kind: POST; hec_num: 5; evars: [n_2565,k1_2566,sm1_2567]; infer_vars: []; c_heap: emp
 checkentail r_1706::lls<flted_35_1704,k_1702,sm_1703>@M * xs'::node<v_1705,r_1528>@M * 
r_1528::node<v_1527,r_1706>@M&0<n_1540 & 0<n_1540 & 0<n_1540 & 0<n_1540 & 
k1_1566!=n_1540 & n_1540=flted_35_1704+1 & k1_1566<n_1540 & 
v_1705<=sm1_1567 & k1_1566=k_1702 & sm1_1567=sm_1703 & 0<n_1540 & 0<n_1540 & 
k!=n & n=flted_35_1526+1 & k<n & v_1527<=sm & k=k_1524 & sm=sm_1525 & 0<n & 
xs=xs' & k!=n & r_1528!=null & !(v_bool_57_1175') & r_1528!=null & 
!(v_bool_57_1175') & flted_35_1526=n_1540 & k_1524=k_1541 & 
sm_1525=sm_1542 & k_1541!=n_1540 & k_1524<=flted_35_1526 & 0<=k_1524 & 
tmp_2563 & k1_1566=1+k_1541 & sm1_1567<=sm_1542 & k_1541!=n_1540 & 
k_1541<=n_1540 & 0<=k_1541 & v_1705<v_1527 & !(v_bool_65_1173') & 
v_1705<v_1527 & !(v_bool_65_1173') & v_1527=val_70_1736 & 
v_1705=val_71_1748 & flag_2564 & v_boolean_76_1174' & flag_2564 & 
res=v_boolean_76_1174'&{FLOW,(26,27)=__norm}[]
 |-  (exists n_2565,k1_2566,sm1_2567: xs::lls<n_2565,k1_2566,sm1_2567>@M&
{FLOW,(26,27)=__norm})[]. 

===================================================================
 ./run-fast-tests.pl sleek_fracperm

Total number of errors: 7 in files:
  fracperm/norm1.slk({E4#Valid}) fracperm/norm3.slk({E2#Valid},{E3#Valid},{E4#Valid},{E5#Valid},{E6#Valid},{E7#Valid}) fracperm/norm4.slk({E2#Valid},{E3#Valid}) fracperm/combine_data.slk({E1#Valid},{E11#Valid},{E2#Valid},{E3#Valid},{E4#Valid},{E7#Valid},{E8#Valid},{E9#Valid}) fracperm/combine_simple.slk({E1#Valid},{E2#Valid},{E4#Valid},{E7#Valid}) fracperm/split-combine.slk({E14#Valid},{E15#Valid}) fracperm/combine2.slk({E1#Valid},{E2#Valid},{E4#Valid}).

===================================================================
# Shuffle-v.ss  vs rev-1.ss

unsoundness of hip ; log of sleek contains failure.

===================================================================
# sh-rev.sh


unsound lemma problem with

lemma_safe self::lseg<n,r>  <- self::lseg<m,q>*q::node<_,r> & n=m+1.

checkentail ni::node<_, l> * l::node<_,null> |- ni::lseg<2, l> * l::node<_, null>.
// valid but should fail

checkentail ni::node<_, l> * l::node<_,null> |- ni::lseg<1, l>*l::node<_,null>.

checkentail x::lseg<n,r> & n>0 |- x::lseg<n-1, l>*l::node<_,r>.
// fail but shd succeed?

print residue.
===================================================================
# sh-rev2.slk

lemma_safe self::lseg<n,r>  <- self::lseg<m,q>*q::node<_,r> & n=m+2.

checkentail_exact  self::node<_,r> & n=m+2 & m=0 & self=q
  |- self::lseg<n,r>.
// valid : base case
print residue.

/*
Why is a RD_lemma triggered?? when the RHS did not contain a node?
This lemma should only be triggered by a folding when both
LHS and RHS are x::lseg<..>

===================================================================
# sh-rev3a.slk  (unsoundness in lemma)

Must add sh-rev3a.slk and sh-rev3b.slk to run-fast-test!

Why was false triggered by lemma proving?
I guess it is not properly normalized.
I am concerned that unnormalized form leads to unsoundness.

id: 1; caller: []; line: 0; classic: true; kind: Verify_Lemma; hec_num: 5; evars: []; infer_vars: []; c_heap: emp
 checkentail q::node<_,r>@M&n=2+m & m=0 & q=self&{FLOW,(21,22)=__norm}[]
 |-  self::lseg<n,r>@M&{FLOW,(21,22)=__norm}[]. 
res:  1[
   hfalse&false&{FLOW,(21,22)=__norm}[]
   ]


Below came from sleek proving where the RHS was normalized as:
 |-  (exists n1,r1: self::lseg<n1,r1>@M & n1=n & r1=r). 

However, it is a weirf that we have instead:
 |-  (exists n,r: self::lseg<n,r>@M & ...)

--------

id: 20; caller: []; line: 25; classic: true; kind: Sleek_Entail(1); hec_num: 5; evars: [n_166,r_167]; infer_vars: []; c_heap: emp
 checkentail q::node<_,r>@M&q=self & m=0 & n=m+2&{FLOW,(21,22)=__norm}[]
 |-  (exists n,r: self::lseg<n,r>@M&{FLOW,(21,22)=__norm})[]. 
res:  1[
   emp&n=m+2 & m=0 & q=self & Anon_14=v_168 & q_169=r & exists(flted_5_176:flted_5_176=0) & exists(p_175:p_175=q_169) & exists(r_167:q_169=r_167) & exists(n_166:n_166=0+1)&{FLOW,(21,22)=__norm}[]
   ]
 
id: 28; caller: []; line: 25; classic: true; kind: Sleek_Entail(1); hec_num: 4; evars: [n_166,r_167]; infer_vars: []; c_heap: q::node<_,r>@M
 checkentail emp&exists(n_166:n_166=0+1) & exists(r_167:q=r_167) & 
exists(p_175:p_175=q) & exists(flted_5_176:flted_5_176=0) & q=r & Anon=v & 
q1=self & m=0 & n=m+2&{FLOW,(21,22)=__norm}[]
 |-  (exists n1,r1: emp&q=r1 & n1=0+1 & r=r1 & n=n1&{FLOW,(21,22)=__norm})[]. 
res:  failctx
         fe_kind: MUST
         fe_name: logical bug
         fe_locs: {
                   fc_message:  n=0+2 |-  n=1+0. LOCS:[24;5] (must-bug)
                   fc_current_lhs_flow: {FLOW,(3,4)=__Error}}

=======

!!! LP.lhs: (exists q_51,_,m_53: self::lseg<m_53,q_51>@M * q_51::node<_,r>@M&n=2+m_53&
{FLOW,(21,22)=__norm})[]
!!! LP.fv_lhs:[self,r,n]
!!! LP.lhs(unfolded): 
 (exists q_54,_,m_56: q_54::node<_,r>@M&q_54=self & m_56=0 & n=2+m_56&
 {FLOW,(21,22)=__norm})[]
 or (exists p_68,flted_5_69,v_70,q_71,q_54,_,m_56: self::node<v_70,q_71>@M * 
    q_71::lseg<flted_5_69,p_68>@M * q_54::node<_,r>@M&m_56=flted_5_69+1 & 
    p_68=q_54 & n=2+m_56&{FLOW,(21,22)=__norm})[]
 
!!! LP.rhs: EBase (exists n_45,r_46: self::lseg<n_45,r_46>@M&n=n_45 & r=r_46&
       {FLOW,(21,22)=__norm})[]

!!! LP.new_rhs: EBase (exists n_45,r_46: self::lseg<n_45,r_46>@M&n=n_45 & r=r_46&
       {FLOW,(21,22)=__norm})[]

>>> Calling process_coercion_check
>>> How come rhs lost some info

!!! LP.glob_vs_rhs:[]
!!! LP.fv_rhs:[]
!!! LP.rhs(after unfold): EBase self::lseg<n,r>@M&{FLOW,(21,22)=__norm}[]
!!! iconseq: EBase self_lem_13::lseg<n,r>@M&{FLOW,(21,22)=__norm}[]
===================================================================

without rd_lemma
----------------
Total number of errors: 2 in files:
  lemmas/lseg.slk({L1#Valid},{L2#Valid}) lemmas/rlseg.slk({L3#Valid}).
Total verification time: 0.00 second

Checking append-tail.ss
error at: append-tail.ss append

Total number of errors: 1 in files:
 error at: append-tail.ss append

with rd_lemma
-------------
Total number of errors: 1 in files:
  lemmas/lseg.slk({L1#Valid},{L2#Valid}).

Leads to unsoundness of sh-rev3a.slk

===================================================================
checkentail
 self=nx & bk=pr |- self::dll<bk,b,a>.
print residue.
/*
# fold-dll-1.slk

why fail?
                          es_must_error: Some(Cannot infer heap and pure 2)
                          es_trace:  COND ==>  UnmatchedRHSData ==> 
                          es_infer_vars_rel: []] <1>emp&self=nx & bk=pr&{FLOW,(21,22)=__norm}[]
===================================================================
# bug1.slk implict-var need to be disabled..

To add below,and to make disable the default (for smt-compete esp)
--dis-implicit-var
--en-implicit-var

checkentail_exact x1::ls<x2> * x2::node<next = x1> 
 |- x3::ls<x2> * x2::node<next = x3> .
print residue.

/*


run_infer:
 x1::ls<x2> * x2::node<x1>&{FLOW,(21,22)=__norm}[] [] |-  EBase exists (Expl)[](Impl)[x3](ex)[](exists x2_28: x3::ls<x2_28> * 
       x2::node<x3>&x2_28=x2&{FLOW,(21,22)=__norm})[]

*/
===================================================================
# ll2a.ss 

without --imm

int length (node x)
	infer[@term]
	requires x::ll<n>@L
        ensures res=n;

Checking procedure length$node... Proving binding in method length$node for spec  EAssume 
   emp&{FLOW,(24,25)=__norm}[]
   , Line 10

( [(,1 ); (,2 )]) bind: node  x'::node<val_13_1183',next_13_1184'> cannot be derived from context
ll2a.ss_13:24_13:30

===================================================================
# mapreduce.ss -tp parahip --eps -perm fperm --classic

 where is __false
 where is primitives Line 64?

!!!Full processing file "mapreduce.ss"
Parsing file "mapreduce.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc

Last Proving Location: 1 File "primitives",Line:64,Col:0

ERROR: at _0:0_0:0 
Message: Can not find flow of __false
 Stop Omega... 0 invocations caught
 (Program not linked with -g, cannot print stack backtrace)

Exception occurred: Failure("Can not find flow of __false")
Error3(s) detected at main 
===================================================================
# infer13.slk

GOT

Entail (1) : Valid. 
Residue:
 <1>emp&q=z & z=inf_z_54&{FLOW,(4,5)=__norm#E}[]
 inferred heap: [z::lseg{}<inf_z_54>]
 inferred pure: [z=inf_z_54]
[[ SEARCH ==>  Match(x,x) ==>  COND ==>  InferHeap ==>  Match(z,q) ==> ]]

Why did we infer z::lseg<inf_z_54>? where did inf_z_54 came from?

===================================================================
# infer13a.slk

infer [z@NI] x::node<z>   |- x::node<q>*q::lseg<z> .

Can we support @NI or non-instantiating selective variable?

===================================================================
# bugs/bug22b-infer5a.slk

infer [x] true   |- x::node<3>.
print residue.
/*
Expect : x::node<i1> & i1=3 

Entail (1) : Fail.(may) cause:Cannot infer: infer_collect_hp_rel 3b
Residue:
 <1>htrue&{FLOW,(4,5)=__norm#E}[]
[[ COND ==>  UnmatchedRHSData ==> ]]
*/

# bugs/bug22-infer5a.slk

infer [x] true   |- x::node<3,null>.
print residue.

Expect :: x::node<i1,i2> & i1=3 & i2=null

Entail (4) : Fail.(may) cause:Cannot infer: infer_collect_hp_rel 3b
Residue:
 <1>htrue&{FLOW,(4,5)=__norm#E}[]
[[ COND ==>  UnmatchedRHSData ==> ]]
===================================================================
# ex31b.slk

Why is there a parser error?

 checkentail x::cellp(1/2)<v1> |-  x::cellp(1/4)<v1>.

File "ex31b-split-fracperm.slk", line 10, characters 20-21
 error: Stream.Error("[cexp] expected after OPAREN (in [perm])")
 at:error at: 
===================================================================
# ex31a.slk --en-para -perm fperm -tp redlog

Why are there so many nested timer interrupt?

Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Why are there two similar residues?

Residue:
 <1>x::cellp{}( f2_84)<v_93>&v_93=v1 & perm_13_65=FLOAT 1. & Anon_full_perm=FLOAT 1. & FLOAT 0.<f2_84 & perm_13_65=f2_84+FLOAT 0.5 & FLOAT 0.<FLOAT 0.5&{FLOW,(4,5)=__norm#E}[]
[[ SEARCH ==>  COND ==> (Match-->try split/combine) ==>  SEARCH ==>  (Lemma ==> split2(x,x)) ==>  Match(x,x) ==> ]]

<2>x::cellp{}( f2_103)<v_112>&v_112=v1 & perm_13_65=FLOAT 1. & Anon_full_perm=FLOAT 1. & FLOAT 0.<f2_103 & perm_13_65=f2_103+FLOAT 0.5 & FLOAT 0.<FLOAT 0.5&{FLOW,(4,5)=__norm#E}[]
[[ SEARCH ==>  (Lemma ==> split2(x,x)) ==>  Match(x,x) ==> ]]
===================================================================
  infer/infer13.slk({E5#Valid}) 
  infer/infer16.slk({E5#Valid},{E6#Valid}) 
  vperm/vperm.slk({E10#Valid},{E11#Valid},{E2#Valid},{E4#Valid},{E5#Valid},{E9#Valid}).
!!! WARNING: for "no result" errors please check the script's options, provers' settings, etc.
===================================================================
# ex32-vperm.slk

Why isn't LHS false?
checkentail @full[x3]*@value[x3]  |- @full[x3].
print residue.
// why isn't there a contracdicition on LHS
   Moreover there is a residue

Residue:
 <1>htrue*@full[x3]&{FLOW,(4,5)=__norm#E}[]
===================================================================
# ex41b: FIXED

infer [H2] x::node<z> * H2(z,x)  |- x::lseg<z> .
print residue.

1. x!=null already on LHS

Expected answer:
 H2(z,x)&true --> emp&x=z 
===================================================================
# ex42a.slk

HeapPred H3(node y,node@NI x).
infer_exact [H3] x::node<z> * H3(z,x)  |- x::lseg<z> .
print residue.

How come we are not getting an lseg like below:
 inferred hprel: [H2(q_91,x)&true --> q_91::lseg<q_91> * HP_96(x,q_91@NI)&
                   true; 
                  HP_96(x,z@NI)&true --> emp&x!=z]

We do not instantiate x, but we ought to allow q_91 
to be instantiated!

Entail (4) : Valid. 

Residue:
 <1>H3(z,x)&x!=null & q_107!=x & q_107=z&{FLOW,(4,5)=__norm#E}[]
 inferred hprel: [H3(z,x@NI)&true --> emp&x!=z]
===================================================================
# ex42a.slk

HeapPred H2(node y,node x).

infer_exact [H2] x::node<z> * H2(z,x)  |- x::lseg<z> .
print residue.

WHy does this fail now?

Entail (1) : Fail.(must) cause:UnionR[residue is forbidden.(1),residue is forbidden.(1)]

Residue:
 <1>x::node<z> * H2(z,x)&{FLOW,(4,5)=__norm#E}[]
[[ Fold ==> ]]

===================================================================
# ex11a2.ss -tp z3 --smtinp: FIXED

Why did we generate P twice?

WARNING: _0:0_0:0:Z3 error message: 
(error "line 304 column 25: invalid declaration, function 'P' (whith the given signature) already declared")

Checking procedure foo$int[]... 
!!! **wrapper.ml#271:Calling wrap_arr_as_var
WARNING: _0:0_0:0:Z3 error message: 
(error "line 304 column 25: invalid declaration, function 'P' (whith the given signature) already declared")
>>> GENERATED SMT INPUT:

;Variables declarations
(declare-fun a_primed () (Array Int Int))
(declare-fun a () (Array Int Int))
(declare-fun v_int_11_1152_primed () Int)
;Relations declarations
(declare-fun P (Int) Bool)
(declare-fun P (Int) Bool)
;Axioms assertions
;Antecedent
(assert (= a_primed a))
(assert (P (select a 5)))
(assert (= v_int_11_1152_primed 5))
;Negation of Consequence
(assert (not false))
(check-sat)
===================================================================
# ex47a

# why message appears twice?

WARNING: _0:0_0:0:* between overlapping heaps: ( x::node<nnn,Anon_15>@M, x::node<mmm,Anon_16>@M)

WARNING: _0:0_0:0:* between overlapping heaps: ( x::node<nnn,Anon_15>@M, x::node<mmm,Anon_16>@M)
[Warning] False ctx

===================================================================
# bugs/ex1a.slk (ann2.slk) --imm


# how to make new instantiation work for phase mechanism of imm?

infer [] y::node<_,_>@I |- y::node<a,b>@v & v<:@I.

# expect Valid but pure missing from phase reasoning
# soln : add pure back into reasnoning for earlier phases

Entail (1) : Fail.(may) cause: @I<:v |-  v<:@I. LOCS:[0;7] (may-bug)

Residue:
 
MaybeErr Context: 
                   fe_kind: MAY
                   fe_name: logical bug
                   fe_locs: {
                             fc_message:  @I<:v |-  v<:@I. LOCS:[0;7] (may-bug)
                             fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}}
[[ SEARCH ==>  Match(y,y) ==> ]]
CEX:false

------------------------------------------------------------
--imm -dre  "heap_entail\|heap_n_" 

(==solver.ml#7639==)
heap_entail_non_empty_rhs_heap@15@14@13@12@11@10@9@8@7@6@5@4@3@2@1
heap_entail_non_empty_rhs_heap inp1 : y::node<Anon_12,Anon_13>@I&{FLOW,(20,21)=__norm#E}[]
 es_gen_impl_vars: [v; b; a]
 es_infer_vars_rel: []
 es_unsat_flag: false
heap_entail_non_empty_rhs_heap inp2 :LHS base: y::node<Anon_12,Anon_13>@I&{FLOW,(20,21)=__norm#E}[]
heap_entail_non_empty_rhs_heap inp3 :RHS base: y::node<a,b>@v&{FLOW,(20,21)=__norm#E}[]
heap_entail_non_empty_rhs_heap inp4 :ante    : y::node<Anon_12,Anon_13>@I&{FLOW,(20,21)=__norm#E}[]
heap_entail_non_empty_rhs_heap inp5 :conseq  : y::node<a,b>@v&{FLOW,(20,21)=__norm#E}[]
heap_entail_non_empty_rhs_heap inp6 :matched_set:[]
heap_entail_non_empty_rhs_heap@15 EXIT:( 
[
 y::node<Anon_12,Anon_13>@[@I, @v]&@I<:v & a=Anon_12 & b=Anon_13&
   {FLOW,(20,21)=__norm#E}[]
 ]
,<Pure>
Success
</Pure>
)

(==solver.ml#7215==)
heap_entail_conjunct_helper#3@14@13@12@11@10@9@8@7@6@5@4@3@2@1
heap_entail_conjunct_helper#3 inp1 : y::node<Anon_12,Anon_13>@I&{FLOW,(20,21)=__norm#E}[]
 es_gen_impl_vars: [v; b; a]
 es_infer_vars_rel: []
 es_unsat_flag: false
heap_entail_conjunct_helper#3 inp2 : y::node<a,b>@v&{FLOW,(20,21)=__norm#E}[]
heap_entail_conjunct_helper#3@14 EXIT: 
[
 y::node<Anon_12,Anon_13>@[@I, @v]&@I<:v & a=Anon_12 & b=Anon_13&
   {FLOW,(20,21)=__norm#E}[]
 ]

(==solver.ml#6556==)
heap_entail_conjunct#5@13@12@11@10@9@8@7@6@5@4@3@2@1
heap_entail_conjunct#5 inp1 :false
heap_entail_conjunct#5 inp2 : y::node<Anon_12,Anon_13>@I&{FLOW,(20,21)=__norm#E}[]
 es_gen_impl_vars: [v; b; a]
 es_infer_vars_rel: []
 es_unsat_flag: false
heap_entail_conjunct#5 inp3 : y::node<a,b>@v&{FLOW,(20,21)=__norm#E}[]
heap_entail_conjunct#5@13 EXIT: 
[
 y::node<Anon_12,Anon_13>@[@I, @v]&@I<:v & a=Anon_12 & b=Anon_13&
   {FLOW,(20,21)=__norm#E}[]
 ]


(==solver.ml#6357==)
heap_entail_split_lhs_phases@12@11@10@9@8@7@6@5@4@3@2@1
heap_entail_split_lhs_phases inp1 : y::node<Anon_12,Anon_13>@I&{FLOW,(20,21)=__norm#E}[]
 es_gen_impl_vars: [v; b; a]
 es_infer_vars_rel: []
heap_entail_split_lhs_phases inp2 :RHS: y::node<a,b>@v&{FLOW,(20,21)=__norm#E}[]
heap_entail_split_lhs_phases@12 EXIT: 
[
 y::node<Anon_12,Anon_13>@[@I, @v]&@I<:v & a=Anon_12 & b=Anon_13&
   {FLOW,(20,21)=__norm#E}[]
 ]

------------------------------------------------------------

--field-imm -dre  "heap_entail\|heap_n_" 

(==solver.ml#7639==)
heap_entail_non_empty_rhs_heap@12@11@10@9@8@7@6@5@4@3@2@1
heap_entail_non_empty_rhs_heap inp1 : y::node<Anon_12,Anon_13>@I&{FLOW,(20,21)=__norm#E}[]
 es_gen_impl_vars: [v; b; a]
 es_infer_vars_rel: []
heap_entail_non_empty_rhs_heap inp2 :LHS base: y::node<Anon_12,Anon_13>@I&{FLOW,(20,21)=__norm#E}[]
heap_entail_non_empty_rhs_heap inp3 :RHS base: y::node<a,b>@v&v<:@I&{FLOW,(20,21)=__norm#E}[]
heap_entail_non_empty_rhs_heap inp4 :ante    : y::node<Anon_12,Anon_13>@I&{FLOW,(20,21)=__norm#E}[]
heap_entail_non_empty_rhs_heap inp5 :conseq  : y::node<a,b>@v&v<:@I&{FLOW,(20,21)=__norm#E}[]
heap_entail_non_empty_rhs_heap inp6 :matched_set:[]
heap_entail_non_empty_rhs_heap@12 EXIT:( 
[
 y::node<Anon_12,Anon_13>@A&v=@I & a=Anon_12 & b=Anon_13&
   {FLOW,(20,21)=__norm#E}[]
 ]
(==solver.ml#7215==)
heap_entail_conjunct_helper#3@11@10@9@8@7@6@5@4@3@2@1
heap_entail_conjunct_helper#3 inp1 : y::node<Anon_12,Anon_13>@I&{FLOW,(20,21)=__norm#E}[]
 es_gen_impl_vars: [v; b; a]
 es_infer_vars_rel: []
heap_entail_conjunct_helper#3 inp2 : y::node<a,b>@v&v<:@I&{FLOW,(20,21)=__norm#E}[]
heap_entail_conjunct_helper#3@11 EXIT: 
[
 y::node<Anon_12,Anon_13>@A&v=@I & a=Anon_12 & b=Anon_13&
   {FLOW,(20,21)=__norm#E}[]
 ]


(==solver.ml#5721==)
heap_entail_conjunct#1@10@9@8@7@6@5@4@3@2@1
heap_entail_conjunct#1 inp1 :false
heap_entail_conjunct#1 inp2 : y::node<Anon_12,Anon_13>@I&{FLOW,(20,21)=__norm#E}[]
 es_gen_impl_vars: [v; b; a]
 es_infer_vars_rel: []
heap_entail_conjunct#1 inp3 : y::node<a,b>@v&v<:@I&{FLOW,(20,21)=__norm#E}[]
heap_entail_conjunct#1@10 EXIT: 
[
 y::node<Anon_12,Anon_13>@A&v=@I & a=Anon_12 & b=Anon_13&
   {FLOW,(20,21)=__norm#E}[]
 ]


(==solver.ml#5173==)
heap_entail_conjunct_lhs#1@9@8@7@6@5@4@3@2@1
heap_entail_conjunct_lhs#1 inp1 :prog_decl
heap_entail_conjunct_lhs#1 inp2 :false
heap_entail_conjunct_lhs#1 inp3 : y::node<Anon_12,Anon_13>@I&{FLOW,(20,21)=__norm#E}[]
 es_gen_impl_vars: [v; b; a]
 es_infer_vars_rel: []
heap_entail_conjunct_lhs#1 inp4 : y::node<a,b>@v&v<:@I&{FLOW,(20,21)=__norm#E}[]
heap_entail_conjunct_lhs#1 inp5 :1 File "",Line:0,Col:0
heap_entail_conjunct_lhs#1@9 EXIT:
 ctx =  
[
 y::node<Anon_12,Anon_13>@A&v=@I & a=Anon_12 & b=Anon_13&
   {FLOW,(20,21)=__norm#E}[]
 ]

==============================================================
# ex48c.slk (FIXED by changing to expl inst)

# I guess the renaming on RHS is caused by axx2 being global.

 ### conseq =  EBase (exists axx2_44,flted_25_43: x::ll{}<flted_25_43,axx2_44>@M&
       flted_25_43=1+n & 1<n & axx2_44=axx2&{FLOW,(20,21)=__norm#E}[]

# ann subs not complete..

(==solver.ml#7245==)
subst@70
subst inp1 :[(axx2_44,axx2_53),(flted_25_43,flted_25_54)]
subst inp2 : x::ll<flted_25_43,axx2_44>@M&flted_25_43=1+n & 1<n & axx2_44=axx2&
{FLOW,(20,21)=__norm#E}[]
subst@70 EXIT: x::ll<flted_25_54,axx2_44>@M&flted_25_54=1+n & 1<n & axx2_53=axx2&
{FLOW,(20,21)=__norm#E}[]

===================================================================
# ex47b.slk --field-imm (FIXED)

checkentail x::ll<n> * y::ll<n> & x=y |- x=null.

# why did --field-imm fail for this example?

(==mcpure.ml#2282==)
generate_action@3
generate_action inp1 :[ x::ll{}<n>@M, y::ll{}<n_34>@M]
generate_action inp2 :emap[{n,n_34};{x,y}]
generate_action@3 EXIT: Unfold 1 =>
             LHS: x::ll{}<n>@M
             RHS: x::ll{}<n>@M

# why below see only one predicate?

--field-imm
(==mcpure.ml#2282==)
generate_action@3
generate_action inp1 :[ x::ll{}<n>@M]
generate_action inp2 :emap[{n,n_34};{x,y}]
generate_action@3 EXIT: NothingToDo => No duplicated nodes!

===================================================================
# ex48b.slk --field-imm

checkentail x::node<a@M, r@M> * r::node<b@M, r2@M> * r2::ll<n, v2> |- x::ll<n + 2, v2>.

# why is there an exception?

Entail 1: EXCast. Failure("imm_to_spec_var do do not provide support for nested TempAnn/TempRes@[@M, @v2]")
: no residue 

Exception(compatible_ann):Failure("Cpure.ml currently we do not provide support for nested TempAnn/TempRes")
Exception(h_formula_2_mem):Failure("Cpure.ml currently we do not provide support for nested TempAnn/TempRes")
Exception(xpure_heap_symbolic):Failure("Cpure.ml currently we do not provide support for nested TempAnn/TempRes")
Exception(xpure_heap):Failure("Cpure.ml currently we do not provide support for nested TempAnn/TempRes")
Exception(xpure_imply):Failure("Cpure.ml currently we do not provide support for nested TempAnn/TempRes")
Exception(sem_imply_add):Failure("Cpure.ml currently we do not provide support for nested TempAnn/TempRes")
Exception(do_base_case_unfold_only):Failure("Cpure.ml currently we do not provide support for nested TempAnn/TempRes")
Exception(process_action):Failure("Cpure.ml currently we do not provide support for nested TempAnn/TempRes")
Exception(process_action):Failure("Cpure.ml currently we do not provide support for nested TempAnn/TempRes")
Exception(heap_entail_non_empty_rhs_heap):Failure("Cpure.ml currently we do not provide support for nested TempAnn/TempRes")
Exception(heap_entail_conjunct_helper):Failure("Cpure.ml currently we do not provide support for nested TempAnn/TempRes")
===================================================================
Total number of errors: 2 in files:
  infer/infer13.slk({E5#Valid}) infer/infer16.slk({E5#Valid},{E6#Valid}).
!!! WARNING: for "no result" errors please check the script's options, provers' 
===================================================================
# ex52a2.slk (-debug dd.log or -dre "infer")

$ compare with ex52a3.slk and ex52a4.slk

Entail (1) : Fail.(may) cause:AndR[ x!=null |-  x!=z. LOCS:[15;16;17];  inf_p=null & x!=null |-  inf_p=z. LOCS:[15;16;17];  R(fld5) |-  fld5=null. LOCS:[13;17] (may-bug).]

==omega.ml#1151==)
infer_pure_m_1@6@5@4@3
infer_pure_m_1 inp1 :estate :( pr_entail_state_short : emp&x!=null & inf_p=null & R(fld5)&{FLOW,(20,21)=__norm#E}[]
 es_heap:emp
 es_infer_vars: [z; inf_p]
 es_infer_vars_rel: [R],[z,inf_p])
infer_pure_m_1 inp2 :lhs xpure : true & x!=null & inf_p=null
infer_pure_m_1 inp3 :lhs xpure0 : x!=null & inf_p=null & R(fld5)
infer_pure_m_1 inp4 :rhs xpure : fld5=null & inf_p=z & x!=z
infer_pure_m_1 inp5 :inf vars :[fld5,z,inf_p]
infer_pure_m_1@6 EXIT:(new es,inf pure,rel_ass) :(None,Some( ((z=0 & fld5=null) | (fld5!=null & inf_p!=0) | (fld5=null & inf_p!=0 & z!=0))),[])

(==infer.ml#1572==)
infer_pure_m_1@5@4@3
infer_pure_m_1 inp1 :estate :( pr_entail_state_short : emp&x!=null & inf_p=null & R(fld5)&{FLOW,(20,21)=__norm#E}[]
 es_heap:emp
 es_infer_vars: [z; inf_p]
 es_infer_vars_rel: [R],[z,inf_p])
infer_pure_m_1 inp2 :lhs xpure : R(fld5) & x!=null & inf_p=null
infer_pure_m_1 inp3 :lhs xpure0 : x!=null & inf_p=null & R(fld5)
infer_pure_m_1 inp4 :rhs xpure : fld5=null & inf_p=z & x!=z
infer_pure_m_1 inp5 :inf vars :[z,inf_p]
infer_pure_m_1@5 EXIT:(new es,inf pure,rel_ass) :(None,None,[])
===================================================================
# ex52a5.slk --print-type

# Why is x not Object type?

 <1>emp&x:TVar[28]!=null & inf_p:TVar[28]=null & R:RelT([])(fld5:node) & 
        z:TVar[28]=0 & fld5:node=null&{FLOW,(20,21)=__norm#E}[]
 inferred pure: [z:TVar[28]=0]
 inferred rel: [RELASS [R:RelT([])]: ( R:RelT([])(fld5:node)) -->  fld5:node=null]
===================================================================
# ex52c2.slk -dre "infer_pure"

# Why is this not working?

infer[R,z,inf_p]  
 R(fld5) & inf_p=null & x!=null
     |-  fld5=null
  .

(==omega.ml#1151==)
infer_pure_m_1@4@3@2@1
infer_pure_m_1 inp1 :estate :( pr_entail_state_short : emp&x!=null & inf_p=more enull & R(fld5)&{FLOW,(20,21)=__norm#E}[]
 es_heap:emp
 es_infer_vars: [z; inf_p]
 es_infer_vars_rel: [R],[z,inf_p])
infer_pure_m_1 inp2 :lhs xpure : true & x!=null & inf_p=null
infer_pure_m_1 inp3 :lhs xpure0 : x!=null & inf_p=null & R(fld5)
infer_pure_m_1 inp4 :rhs xpure : fld5=null
infer_pure_m_1 inp5 :inf vars :[fld5,z,inf_p]
infer_pure_m_1@4 EXIT:(new es,inf pure,rel_ass) :(None,Some( (inf_p!=0 | fld5=null)),[])
===================================================================
# ex12a.slk --en-para -perm bperm -tp redlog

# Why is b1!=b2 missing now? 
# What is barrier?

(==cvutil.ml#1186==)
h_formula_2_mem@107@106@105
h_formula_2_mem inp1 : b1::barrier( (c1,t1,a1))<p1>@M * b2::barrier( (c2,t2,a2))<p2>@M
h_formula_2_mem inp2 : b2!=b1 & t1!=t2
h_formula_2_mem inp3 :[]
h_formula_2_mem@107 EXIT: []

!!! **WARNING****cvutil.ml#1045:Data Pure Inv (not tested) 
!!! **WARNING****cvutil.ml#1045:Data Pure Inv (not tested) 
(==cvutil.ml#1781==)
xpure_heap_mem_enum#6@106@105
xpure_heap_mem_enum#6 inp1 : b1::barrier( (c1,t1,a1))<p1>@M * b2::barrier( (c2,t2,a2))<p2>@M
xpure_heap_mem_enum#6 inp2 : b2!=b1 & t1!=t2
xpure_heap_mem_enum#6 inp3 :1
xpure_heap_mem_enum#6@106 EXIT: b1!=null & c1>=0 & (t1+a1)>=c1 & t1>=0 & b2!=null & c2>=0 & (t2+a2)>=c2 & 
 t2>=0 #  []

(==solver.ml#2797==)
xpure_heap#1@105
xpure_heap#1 inp1 : b1::barrier( (c1,t1,a1))<p1>@M * b2::barrier( (c2,t2,a2))<p2>@M
xpure_heap#1 inp2 : b2!=b1 & t1!=t2
xpure_heap#1 inp3 :1
xpure_heap#1@105 EXIT:( b1!=null & c1>=0 & (t1+a1)>=c1 & t1>=0 & b2!=null & c2>=0 & (t2+a2)>=c2 & 
 t2>=0,[], [])#true
Nested Timer(stop)
===================================================================
# ex61a-lseg_complex.slk --lem-norm-w-coerc

# Why does normalize with coercion go into a loop?

ntailing lemma SPLIT: Valid.

Valid Lemmas : [SPLIT:<==>] added to lemma store.

!!! WARNING : split equiv lemma into two -> lemmas 
!!! **WARNING****solver.ml#14480:into normalization_with_coerc? why?

===================================================================
# ex61a-lseg_complex.slk --lem-norm-w-coerc

# Why does normalize with coercion go into a loop?

ntailing lemma SPLIT: Valid.

Valid Lemmas : [SPLIT:<==>] added to lemma store.

!!! WARNING : split equiv lemma into two -> lemmas 
!!! **WARNING****solver.ml#14480:into normalization_with_coerc? why?
===================================================================
# ex49a.ss

# Why is there imm_inference even though there
  isn't any @imm

!!! **imminfer.ml#328:imm infer start
!!! **imminfer.ml#331:imm infer end
!!! **typechecker.ml#4392:imm infer end20

===================================================================
# ex54a.slk --en-para -perm fperm -tp redlog --old-norm-w-coerc 

# why does (Perm.allow_perm ()) need a different way of building
  to_ante and to_conseq? Need to integrate properly.

!!! **WARNING****solver.ml#9594:impl_inst and to_conseq not properly built
WARNING: _0:0_0:0:* between overlapping heaps: ( x::cellp( f2_310)<v_319>@M, x::cellp( f1_309)<v1>@M)
!!! **WARNING****solver.ml#14548:into normalization_with_coerc? why?

# this is being investigated from --warn-nonempty-perm-vars
===================================================================
Total number of errors: 1 in files:
  infer/infer14.slk({E16#Valid}).
===================================================================
Total number of errors: 1 in files: (FIXED)
  classic/classic1b.slk({E19#Fail},{E22#Fail},{E23#Fail},{E25#Fail}).
!!! WARNING: for "no result" errors please check the script's options, provers' 
===================================================================
Total number of errors: 2 in files:
  lemmas/nlseg4e.slk({L2#Valid})
   lemmas/nlseg4e1.slk({E1#Valid},{E2#Valid},{E3#Valid}).
===================================================================
# ex55f.slk (FIXED with --old-do-match-infer-heap)

# BUT --new-do-match-infer-heap UNSOUND

infer [H1]  H1(y) |- y::node<a,null> .

Residue:
 <1>HP_27(flted_9_26)&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [H1(y)&
                   true |#|3  --> y::node<a_25,flted_9_26>@M * 
                                  HP_27(flted_9_26)&
                   true]
 [[ COND ==>  InferHeap]]

# EXPECTS
    HP_27(flted_9_26)&true |#|3  --> emp&flted_9_26=null]
===================================================================
# ex55h.ss (FIXED on filtering cond for mater_list)


void append(node x, node tx, node y, node ty)
	requires x::ll_tail2<tx, n> * y::ll_tail2<ty, m>
        ensures x::ll_tail2<ty, m+n> ;
{
	tx.next = y;
}

# Why bind failure?

Exception Failure("bind failure exception") Occurred!

==============================================================
# ex55g1.slk (FIXED via ex55g3.slk)

pred lseg<n, p> == self = p & n = 0
         or self::node<next = r> * r::lseg<n - 1, p>
         inv n >= 0.

	 "<==" implication: : Valid.

Failed to prove lem_12:<==> in current context.
Removing invalid lemma ---> lemma store restored.

# Would case-spec solve this?

==============================================================
# ex55g1.slk (FIXED by adding existential es_evars)

lemma_safe self::lseg<n, p> & n = a + b & a,b >=0 <-> 
     self::lseg<a, r> * r::lseg<b, p>.

# should r be implicit, and p free & existential?

# why free var warning?

!!! **lem_store.ml#27:XXXX add_LEFT_coercion
!!! **lem_store.ml#28:[Lemma "lem_12_left":  self::lseg<n,p>@M&n=b+a & 0<=a & 0<=b&{FLOW,(20,21)=__norm#E}[] ==> (exists r: self::lseg<a,r>@M * r::lseg<b,p>@M&{FLOW,(20,21)=__norm#E}[])
 head match:lseg
 body view:lseg
 coercion_univ_vars: [a,b]
 materialized vars:  [(self,full,[lseg])]
 coercion_case: Simple
 head:  self::lseg<n,p>@M&n=b+a & 0<=a & 0<=b&{FLOW,(20,21)=__norm#E}[]
 body:  (exists r: self::lseg<a,r>@M * r::lseg<b,p>@M&{FLOW,(20,21)=__norm#E}[])
 head_norm:  (exists n_67,p_68: self::lseg<n_67,p_68>@M&
n=b+a & 0<=a & 0<=b & n_67=n & p_68=p&{FLOW,(20,21)=__norm#E}[])
 body_norm:  EBase 
   exists (Impl)[r](exists a_55,b_56,
   p_57: self::lseg<a_55,r>@M * r::lseg<b_56,p_57>@M&
   a_55=a & b_56=b & p_57=p&{FLOW,(20,21)=__norm#E}[])
 coercion_univ_vars: [a,b]
 coercion_case: Simple
 coercion_origin: user-given
 coercion_kind: LEM_SAFE
 coercion_fold: None
]

!!! **WARNING****solver.ml#4230:FREE VAR IN HEAP RHS :[p_429]
impl/expl vars:[]
LHS:
  r_359::lseg<b_358,p>@M&
r_366=r_360 & Anon_365=Anon_361 & 0<=b_358 & 0<=(flted_5_362+1) & 
n=b_358+flted_5_362+1 & 0<=b_356 & 0<=a_357 & n=b_356+a_357&
{FLOW,(20,21)=__norm#E}[]
RHS:
 EBase 
   (exists r_547,a_548,b_549,a_550,
   b_551: r_359::lseg<a_548,r_547>@M * r_547::lseg<b_549,p_429>@M&
   b_514=b_551+a_550 & 0<=a_550 & 0<=b_551 & b_514=b_549+a_548 & 0<=a_548 & 
   0<=b_549&{FLOW,(20,21)=__norm#E}[])

--warn-free-vars-conseq

Total number of errors: 30 in files:
 error at: vperm/ho_vperm_check.ss test1
error at: vperm/ho_vperm_check.ss test3
error at: vperm/task_decompose.ss creator
error at: parahip/cell.ss test
error at: parahip/ordered-locking.ss func
error at: parahip/ordered-locking.ss main
error at: parahip/unordered-locking.ss main
error at: veribsync/barrier-static-consistency.ss main
error at: veribsync/barrier-dynamic-exp4.ss main
error at: veribsync/barrier-dynamic-exp4.ss thread2
error at: conchip/mapreduce.ss count_helper
error at: conchip/mapreduce.ss countList
error at: conchip/mapreduce.ss destroyList
error at: conchip/mapreduce.ss main
error at: conchip/mapreduce.ss mapper_helper
error at: conchip/mapreduce.ss mapper
error at: conchip/mapreduce.ss reducer1
error at: conchip/mapreduce.ss reducer2
error at: conchip/multi-join2.ss main
error at: conchip/multi-join2.ss thread1
error at: conchip/multi-join2.ss thread2
error at: conchip/latch-exp2.ss main
error at: conchip/latch-exp2.ss thread1
error at: conchip/deadpool.ss destroyDeadPool
error at: conchip/deadpool.ss forkHelper
error at: conchip/deadpool.ss forkThreads
error at: conchip/deadpool.ss joinHelper
error at: conchip/deadpool.ss joinThreads
error at: conchip/deadpool.ss main
error at: conchip/deadpool.ss thread

Total number of errors: 28 in files:
 error at: vperm/ho_vperm_check.ss test1
error at: vperm/ho_vperm_check.ss test3
error at: vperm/task_decompose.ss creator
error at: parahip/ordered-locking.ss main
error at: parahip/unordered-locking.ss main
error at: veribsync/barrier-static-consistency.ss main
error at: veribsync/barrier-dynamic-exp4.ss main
error at: veribsync/barrier-dynamic-exp4.ss thread2
error at: conchip/mapreduce.ss count_helper
error at: conchip/mapreduce.ss countList
error at: conchip/mapreduce.ss destroyList
error at: conchip/mapreduce.ss main
error at: conchip/mapreduce.ss mapper_helper
error at: conchip/mapreduce.ss mapper
error at: conchip/mapreduce.ss reducer1
error at: conchip/mapreduce.ss reducer2
error at: conchip/multi-join2.ss main
error at: conchip/multi-join2.ss thread1
error at: conchip/multi-join2.ss thread2
error at: conchip/latch-exp2.ss main
error at: conchip/latch-exp2.ss thread1
error at: conchip/deadpool.ss destroyDeadPool
error at: conchip/deadpool.ss forkHelper
error at: conchip/deadpool.ss forkThreads
error at: conchip/deadpool.ss joinHelper
error at: conchip/deadpool.ss joinThreads
error at: conchip/deadpool.ss main
error at: conchip/deadpool.ss thread

===================================================================
# ex55g3.slk (OK)

lemma_safe self::lseg<n, p> & n = a + b & a,b >=0 
    <-> self::lseg<a, r> * r::lseg<b, p>.

# case-spec below help with proving

pred lseg<n, p> == 
   case {
      n=0 -> [] self = p ;
      n!=0 -> [] self::node<next = r> * r::lseg<n - 1, p>;
   }     inv n >= 0.

===================================================================
# ex55g4.slk --eci

# How come case-spec inference not working?

   view lseg<n:int,p:node>= 
    EList
      :EBase 
         (* lbl: *){3}->emp&self=p & n=0&{FLOW,(1,26)=__flow#E}[]
      || :EBase 
            exists (Impl)[Anon_17; r](* lbl: *){4}->(exists p_20,
            flted_5_19: (* lbl: *){4}->self::node<Anon_17,r>@M * 
                                       r::lseg<flted_5_19,p_20>@M&
            flted_5_19+1=n & p_20=p&{FLOW,(1,26)=__flow#E}[])

===================================================================
# rft sleek

Bugs with some lemmas due to changes in context.ml

 sleek9.slk({E3#Valid},{E4#Valid}) 
 lemmas/app-tail.slk({E1#Valid}) 
 lemmas/ll_tail.slk(no result  for {E}) 
 lemmas/nlseg4e.slk({L2#Valid}) 
 lemmas/nlseg4e1.slk({E2#Valid},{E3#Valid},{E4#Fail},{E5#Valid},{E6#Valid},{E7#Valid},{E8#Valid}) 
 lemmas/sll_tailL.slk({L2#Valid}) 
 lemmas/dseg-new.slk({L3#Valid}) lemmas/dseg1.slk({L1#Valid}) 
 lemmas/lseg_complex.slk({E3#Fail}).


===================================================================
--new-infer-heap

 infer/infer1.slk({E1#Valid},{E2#Valid},{E3#Valid},{E4#Valid},{E5#Valid},{E6#Valid},{E7#Valid}) 
infer/infer2.slk({E5#Valid}) 
 infer/infer5.slk({E4#Valid}) 
 infer/infer6.slk({E1#Valid}) 
 infer/infer7.slk({E10#Valid}) 
 infer/infer8.slk({E1#Valid},{E10#Valid},{E2#Valid},{E29#Valid},{E3#Valid}) infer/infer13.slk({E1#Valid},{E2#Valid},{E3#Valid},{E4#Valid},{E5#Valid}) infer/infer14.slk({E1#Valid},{E11#Valid},{E13#Valid},{E14#Valid},{E16#Valid},{E17#Valid},{E18#Valid},{E2#Valid},{E29#Valid},{E3#Valid}) 
 infer/infer15.slk({E1#Valid}) 
 lemmas/dseg-new.slk({L2#Fail}).
===================================================================
--old-infer-heap

Total number of errors: 1 in files:
  lemmas/dseg-new.slk({L2#Fail}).
===================================================================
ex55k-dseg-new-unsound.slk --lem-en-lhs-unfold --old-empty-to-conseq --dis-lem-gen

pred dseg<lm, rm:node,last> == self=rm & lm=last
  or self::node<_,lm, p> * p::dseg<self,rm,last>.

pred rlseg<rm> == self:node=rm
  or self::rlseg<q> * q::node<_,_,rm>.

lemma_safe "2" self::rlseg<rm> <- exists lm,last: self::dseg<lm,rm,last>.

# why can we prove this without lem_generation?

Entailing lemma 2: Valid.
Valid Lemmas : [2:<==] added to lemma store.
===================================================================
--old-kepp-all-matchres
!!! WARNING: for "no result" errors please check the script's options, provers' settings, etc.
Total verification time: 82.87 second
	Time spent in main process: 49.09 second
	Time spent in child processes: 33.77 second
	Number of false contexts: 93

Total verification time: 136.55 second
	Time spent in main process: 86.62 second
	Time spent in child processes: 49.93 second
	Number of false contexts: 414


--new-kepp-all-matchres
Total verification time: 87.70 second
	Time spent in main process: 47.10 second
	Time spent in child processes: 40.59 second
	Number of false contexts: 93

Total verification time: 137.75 second
	Time spent in main process: 87.44 second
	Time spent in child processes: 50.31 second
	Number of false contexts: 414

===================================================================
# ex55.slk --new-lemma-unfold (FIXED with a try-catch)

 lemma self::ll_tail<t, n> <-> self::lseg<n-1, t> * t::node<_, null>.

# Why did it cause problem below? 

ERROR: at ex55-sleek9.slk_28:30_28:67
Message: malfunction with float out exp: n-1
Exception(linearize_heap(dup)):Failure("malfunction with float out exp: n-1")
Exception(linearize_formula):Failure("malfunction with float out exp: n-1")
Exception(trans_formula):Failure("malfunction with float out exp: n-1")
Exception(manage_unsafe_lemmas):Failure("malfunction with float out exp: n-1")
Exception(process_list_lemma_helper):Failure("malfunction with float out exp: n-1")
Exception(process_list_lemma):Failure("malfunction with float out exp: n-1")

Exception processed: Failure("malfunction with float out exp: n-1")
error at: 
===================================================================
# ex56.slk --en-para -perm fperm -tp redlog --old-norm-w-coerc --old-lemma-settings --new-lemma-unfold

# unfolding affected normalization of some permissions lemma ..

!!! **WARNING****solver.ml#9915:impl_inst and to_conseq not properly built
!!! **cvutil.ml#893:h_formula_2_mem: [Begin] check fractional variable  perm_38_282 is full_perm

Entail 1: Fail.(may) cause:base case unfold failed

!!!:0: 0: **lemma.ml#230:ldef:
=>coerc split2
	 head: (emp ; (emp ; (self::cellp{}(f)<v>[HeapNode1]))) * ([] & (f = f1+f2) & ((f1 > 0.) & (f2 > 0.)))( FLOW __norm)
	 body:(emp ; (emp ; ((self::cellp{}(f1)<v>[HeapNode1]) * (self::cellp{}(f2)<v>[HeapNode1])))) * ([] & true)( FLOW __norm)lemmas(to be proved and saved)

!!!:0: 0: **lemma.ml#231:res_ldef:
=>coerc split2
	 head: (emp ; (emp ; (self::cellp{}(f)<v>[HeapNode1]))) * ([] & (f = f1+f2) & ((f1 > 0.) & (f2 > 0.)))( FLOW __norm)
	 body:(EX v_192 v_191 . (emp ; (emp ; ((self::cell{}()<v_191,>@M[HeapNode1]) * (self::cell{}()<v_192,>@M[HeapNode1]))))*([] & (((v_192:int)) = ((v:int))) & (((v_191:int)) = ((v:int))))( FLOW __norm))lemmas(to be proved and saved)
===================================================================
#ex63d.slk --adhoc-3

lemma_safe self::lseg<n, p> & n = a + b & a,b >=0 <-> self::lseg<a, r> * r::lseg<b, p>.

Entailing lemma lem_11: Fail. Details below:
         "==>" implication: : Valid.
         "<==" implication: : Fail. (cex)(must) cause: exception Failure("split_components: don't expect OR") in lemma proving
===================================================================
# ex62b.slk 

infer [x] x::ll<n> |- x::node<_,b>.

# performance problem with --en-ptr-arith
  scheduling repeated unfolds ..

[ Type: Root
 LHS: x::node<Anon_47,q_48>@M
 RHS: x::node<Anon_12,b>@M
 root_inst: None
 lhs_rest: q_48::ll<flted_7_46>@M
 rhs_rest: emp
 rhs_inst: [], 
  Type: Root
 LHS: q_48::ll<flted_7_46>@M
 RHS: x::node<Anon_12,b>@M
 root_inst: None
 lhs_rest: x::node<Anon_47,q_48>@M
 rhs_rest: emp
 rhs_inst: []]


===================================================================
# ex62b.slk

infer [x] x::ll<n> |- x::node<_,b>.
print residue.
expect Valid.

# why x=x not eliminated earlier?

!!! **context.ml#721:TODO: rename root:self
!!! **context.ml#722:root_pf: flted_7_46=flted_7_46
!!! **context.ml#727:rhs(to prove): x>=q_48
!!! **context.ml#728:rhs_ptr=root:false
!!! **WARNING****context.ml#712:TODO : check if share same base
!!! **context.ml#713:lhs_p2: flted_7_46+1=n
!!! **context.ml#714:rhs: x=x
===================================================================
# ex64.b.slk

# problem with complex lemma

Entailing lemma three: Fail. Details below:
	 "==>" implication: : Fail. (cex)(may) cause: OrL[
residue is forbidden.(1),
valid
]
	 "==>" implication: : Valid.

The first bad revision is:
changeset:   17436:78bf6a8733c9
branch:      infer-str
user:        chinwn@loris-laptop
date:        Wed Oct 21 04:38:03 2015 +0800
summary:     need to schedule complex lemma

===================================================================
# bugs/ex64c.slk

// (9)
infer [H1]  H1(y) |- (exists a: y::node<a,null> & a>0).
print residue.
expect Fail.
// It seems like pure field is always inferred;
// can we make it selective?

HeapPred HP_69(node flted_19_67, int@NI a_68, node@NI y).
Entail (2) : Valid. 
 <1>HP_69(flted_19_67,a_68,y)&1<=a_68 & y!=null & flted_19_67=null&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [HP_69(flted_19_67,a_68@NI,y@NI)&true --> emp&
                   1<=a_68 & flted_19_67=null; 
                  H1(y)&
                   true --> y::node<a_68,flted_19_67>@M * 
                            HP_69(flted_19_67,a_68@NI,y@NI)&
                   true]
[[ InferUnfold  ==>  InferHeap]]

===================================================================
# ex64d1.slk (fixed with --new-free-var-lhs)

Wrong
=====
Coercion_case: Simple
 head_norm:  (exists n_43: self::ll_s<n_43>@M&n_43=n&{FLOW,(20,21)=__norm#E}[])

Correct
=======
 head_norm:  (exists n: self::ll_s<n>@M&{FLOW,(20,21)=__norm#E}[])
===================================================================
# ex62c.slk --dis-mkeqn-opt

# picking up p=p for inference; need to avoid that
  in infer_lhs_comtra to avoid inferring p!=p

infer [H1] H1(p)* x::node<1,p> |- x::node<2,x2>*x2::node<b,q> & q=null.
print residue.


Entail (1) : Valid. 

Residue:

 <1>hfalse&false&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [H1(p)&true --> htrue&p!=p]

(==infer.ml#787==)
infer_lhs_contra#1@3@2
infer_lhs_contra#1 inp1 : flted_13_34=1 & x2=p & x2=p
infer_lhs_contra#1 inp2 :[p]
infer_lhs_contra#1 inp3 :M_infer_heap : x2::node<b,q>@M
infer_lhs_contra#1@3 EXIT:Some( p!=p)

===================================================================
# ex64k1b.slk

Is this unsound?

# swap rhs <-> lhs

lemma_safe "one" self::rlseg<p1>*p1::rlseg<p> <-> self::rlseg<p> & p!=null.

!!! **iast.ml#3984:swap_lhs_rhs:rhs_pure:p != null
!!! **astsimp.ml#4586:l_fnames:[self,p]
!!! **astsimp.ml#4587:rhs_fnames:[self,p1,p]

# Is this a correct way of handling universal guards?

check_coercion_struc inp1 :Lemma "one_left_right":  self::rlseg<p>@M&{FLOW,(20,21)=__norm#E}[]<== (exists p1_53: self::rlseg<p1_53>@M * p1_53::rlseg<p>@M&p!=null&

===================================================================
# ex64m.slk --en-sep-pure-fields

// (4)
infer [H1]  H1(y) |- y::node<a,b> * b::ll<m>.
print residue.

# infer_unfold not working? (FIXED)

# match not recorded..

(==solver.ml#13577==)
do_match@1
do_match inp1 : y::node<a_41,b_42>@M
do_match inp2 : y::node<a,b>@M
do_match inp3 :  emp&{FLOW,(20,21)=__norm#E}[]
 es_infer_hp_rel: [unknown H1(y) |#|  --> y::node<a_41,b_42>@M]
 es_gen_impl_vars(E): [a; b; c; d]
 es_gen_impl_vars: [a; b; c; d]
 es_trace:  InferUnfold  ==>  InferHeap
 es_infer_vars_hp_rel: [H1]
do_match inp4 : b::node<c,d>@M&{FLOW,(20,21)=__norm#E}[]
do_match inp5 :[]

[[ InferUnfold  ==>  InferHeap ==>  UnmatchedRHSData]]
 CEX:false

!!! **inferHP.ml#1459:root posn (H1):0
!!! **solver.ml#12061:do_infer_heap:entry:rhs: y::node<a,b>@M
!!! **inferHP.ml#243:Globals.infer_const_obj # is_pure_field :false
!!! **inferHP.ml#244: es.CF.es_infer_obj # is_pure_field_all:false
!!! **inferHP.ml#266:args12:[(b_42,@I)]
!!! **inferHP.ml#267:niu_svl_ni_total:[]
!!! **inferHP.ml#275:is_inf_pure_field:false
===================================================================
# bugs/ex64m1.slk (DONE)

# Why is do_match not captured in trace and -dd-steps by infer_unfold?

Entail (1) : Valid. 
Residue:
 <1>HP_47(flted_14_46,y)&flted_14_46=null & y!=null&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [HP_47(flted_14_46,y@NI)&true --> emp&flted_14_46=null; 
                  H1(y)&
                   true --> y::node<a_45,flted_14_46>@M * 
                            HP_47(flted_14_46,y@NI)&
                   true]
[[ InferUnfold  ==>  InferHeap]]

(==solver.ml#13577==)
do_match@1
do_match inp1 : y::node<a_41,b_42>@M
do_match inp2 : y::node<a,b>@M
do_match inp3 :  emp&{FLOW,(20,21)=__norm#E}[]
 es_infer_hp_rel: [unknown H1(y) |#|  --> y::node<a_41,b_42>@M]
 es_gen_impl_vars(E): [a; b; c; d]
 es_gen_impl_vars: [a; b; c; d]
 es_trace:  InferUnfold  ==>  InferHeap
 es_infer_vars_hp_rel: [H1]
do_match inp4 : b::node<c,d>@M&{FLOW,(20,21)=__norm#E}[]
do_match inp5 :[]

[[ InferUnfold  ==>  InferHeap ==>  UnmatchedRHSData]]
 CEX:false
===================================================================
# ex64k8.slk (FIXED)

# why old system  (in default) can prove below?

!!! **solver.ml#13660:lhs contra?:None
Entailing lemma three: Fail. (cex)(may) cause: OrL[
residue is forbidden.(1),
valid
]

lemma_safe "three"  
   self::node<_,q>*q::rlseg<p> 
    ->
   self::rlseg<p1>* p1::node<_,p> 
.

# new complex lemma
 body_norm:  EBase 
   exists (Impl)[p1; 
   Anon_12](exists p_40: self::rlseg<p1>@M * p1::node<Anon_12,p_40>@M&p_40=p&
   {FLOW,(20,21)=__norm#E}[])
 coercion_lhs_sig: Some([node,rlseg])


# old complex lemma (from default)
!!! WARNING : changing lemma from <- to -> 
 body_norm:  EBase 
   exists (Impl)[p1](exists p_40,
   Anon_12: self::rlseg<p1>@M * p1::node<Anon_12,p_40>@M&p_40=p&
   {FLOW,(20,21)=__norm#E}[])
 coercion_fold: None

===================================================================
# ex64k1d.slk

@ unsound?

# do not move p!=null to opposite site..
  as this is unsound, esp for free expressions

# swap rhs <-> lhs

 self::rlseg<p> & p!=null
  <- 
    self::rlseg<p1>*p1::rlseg<p> 

For:
 x::lseg<n,p> & a,b>=0 <-- x::lseg<a,q> * q::lseg<b,p>
we converted to:
 x::lseg<n,p>  <-- x::lseg<a,q> * q::lseg<b,p> & n=a+b
which seems OK as a weakening process..

Why are the two different?
If we do such weakening, we should give a warning as the
new lemma is weaker than the declared one.
===================================================================
# ex64k9b.slk

lemma_safe "one" 
  self::node<_,q>*q::rlseg<p>
  <->
  self::rlseg<p1>*p1::node<_,p>
.

# Why so long, and why need breaking lemma?


[[ Match(self_one_left_right,self_one_left_right) ==>  SEARCH ==>  (Lemma <== one_left_right(q_679,q_679)) ==>  Match(q_679,q_679) ==>  Fold ==>  Match(p1_680,p1_680) ==>  COND ==>  BaseCaseFold ==> ||OR|| ==>  Match(self_one_left_right,self_one_left_right) ==>  COND ==>  BaseCaseFold ==> ||OR|| ==>  Fold ==>  Match(self_one_left,self_one_left) ==>  SEARCH ==>  (Lemma ==> one_left(q_502,q_505)) ==> (Complex: one_left) ==>  SEARCH ==>  (Lemma <== one_left_right(q_502,q_505)) ==>  Match(q_502,q_505) ==>  Fold ==>  Match(p1_596,p1) ==> ||OR|| ==>  Fold ==>  Match(self_one_left,p1)]]
===================================================================
# ex64k9c.slk

lemma_safe "one" 
  self::rlseg<p1>*p1::node<_,p>
  <->
  self::node<_,q>*q::rlseg<p>

// this lemma direction is not as good as the other (see ex64k9b)
===================================================================
# ex64o.slk

# inferred false cumulatively!
# to avoid with a shared object?

# why is q_54 paired with x? How did we get q_54=x?

!!! **context.ml#3598:compute_action (steps) :
 ### RHS Cand :[ x::node<Anon_12,flted_11_43>@M]
 ### action :
 COND =>[
  Prio:1
  Match =>
    LHS: x::node<Anon_53,q_54>@M
    RHS: x::node<Anon_12,flted_11_43>@M;
  Prio:2
  Unfold 0 =>
    LHS: q_54::ll<flted_7_52>@M
    RHS: x::node<Anon_12,flted_11_43>@M
  ]
===================================================================
# bugs/ex64q2a.slk -dre "verify_lemma"

        let res = x_add Lemproving.verify_lemma 3 l2r r2l cprog name typ in 

# Below still loses x_loc even though we have x_add:

(====)
verify_lemma#3@8@7@6@5
verify_lemma#3 inp1 :[Lemma "lseg":  self::lseg<n,p>@M&n=a & 0<=a & 0<=b&{FLOW,(20,21)=__norm#E}[]==> (exists r: self::lseg<a,r>@M * r::lseg<b,p>@M&{FLOW,(20,21)=__norm#E}[])
 head match:lseg
 body view:lseg
 body pred_list:[lseg,lseg]
 coercion_univ_vars: [a,b]
 materialized vars:  [(self,full,[lseg])]
 coercion_case: Simple
 head:  self::lseg<n,p>@M&n=a & 0<=a & 0<=b&{FLOW,(20,21)=__norm#E}[]
 body:  (exists r: self::lseg<a,r>@M * r::lseg<b,p>@M&{FLOW,(20,21)=__norm#E}[])
 head_norm:  (exists n_135,p_136: self::lseg<n_135,p_136>@M&
===================================================================
# ex64r3.slk --dd-callers-all

infer [zzz,H1] H1(y)*x::node<zzz>   |- y::lseg<null> * x::lseg<zzz> .

# How come do_fold_w_ctx recursive here?

[do_fold_w_ctx@11.,do_fold@10,do_base_fold,pm_aux@9,process_action,pm_aux@8,process_action,heap_entail_non_empty_rhs_heap,heap_entail_conjunct_helper,heap_entail_conjunct,do_match,pm_aux@7,process_action,heap_entail_non_empty_rhs_heap,heap_entail_conjunct_helper,heap_entail_conjunct,heap_entail_conjunct_lhs,heap_entail_after_sat,heap_entail_one_context,helper_inner,helper_inner,heap_entail_conjunct_lhs_struc,heap_entail_after_sat_struc,heap_entail_one_context_struc,fold_op_1,do_fold_w_ctx@4,do_fold@3,do_full_fold,pm_aux@2,process_action,heap_entail_non_empty_rhs_heap,heap_entail_conjunct_helper,heap_entail_conjunct,heap_entail_conjunct_lhs,heap_entail_after_sat,heap_entail_one_context,helper_inner,heap_entail_conjunct_lhs_struc,heap_entail_after_sat_struc,heap_entail_one_context_struc,heap_entail_struc,heap_entail_struc_init,heap_entail_struc_init_bug_inv,sleek_entail_check,run_infer_one_pass,process_infer]
===================================================================
# ex64r6c.slk 

infer [zzz,H1] x::node<zzz>*H1(y)   |- y::node<null> * x::lseg<zzz> .

# Why is x::node<..> still there? if it is not a search?

!!! **WARNING****context.ml#825:pushing to infer
!!! **context.ml#3239:process_matches (steps) :
 ### LHS : x::node<zzz>@M * H1(y)
 ### RHS : y::node<flted_14_49>@M
 ### matches :
[ Type: Root
 LHS: H1(y)
 RHS: y::node<flted_14_49>@M
 root_inst: None
 lhs_rest: x::node<zzz>@M
 rhs_rest: emp
 alias set: [y]rhs_inst: []rhs_infer: None]
===================================================================
# ex64r7b.slk -dre "om_gist"

# gist not working properly ..

(====)
om_gist@29@27@26@25@24@21@20@2
om_gist inp1 : (z!=null | flted_13_52=null)
om_gist inp2 : 0+1=a & q_43=z & z=null & y!=null & x!=null & y!=x
om_gist@29 EXIT: (flted_13_52=null | z!=null)

===================================================================
# ex64s5.slk (OK)

# what is first argument of Some(true) for?

(==solver.ml#8957==)
infer_pure_top_level@3@2@1
infer_pure_top_level inp1 : true
infer_pure_top_level@3 EXIT:[(Some( true),Some( yyyy=6),[  H(fld5)&fld5=null&{FLOW,(20,21)=__norm#E}[]
 es_infer_hp_rel: [unknown H(fld5) |#|  --> emp&fld5=null]
 es_gen_impl_vars(E): []

# Why is infer pure missing?

infer[R,z,inf_p_40]
R(fld5) &
q_34=z & inf_ann_39=@M & inf_p_40=null & inf_p_40!=x & x!=null
|-x!=z & inf_p_40=z & fld5=null.

 inferred pure: [(z=null | (inf_p_40!=null & z!=null))]
 inferred rel: [RELASS [R]: ( R(fld5)) -->  fld5=null]

infer[H,z,inf_p_40]
H(fld5) &
q_34=z & inf_ann_39=@M & inf_p_40=null & inf_p_40!=x & x!=null
|-x!=z & inf_p_40=z &fld5=null.

 <1>H(fld5)&x!=null & fld5=null & z=q_34 & inf_ann_39=@M & inf_p_40=null&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [H(fld5)&true --> emp&fld5=null]
===================================================================
# ex64s5.slk 

 dre "infer_pure_top" --trace-log-num 1 


# logging lost when --dd-callers-all 
===================================================================
# ex64s7a.slk (FIXED)

if true (* CP.remove_dups_svl rel_ids = rel_ids *) then

 <1>q_66::ll<flted_7_64>@M * y::ll<m>@M&flted_7_64=n-1 & n<=1 & R1(n) & R1(m)&{FLOW,(20,21)=__norm#E}[]
 inferred rel: [RELASS [R1]: ( R1(n) & R1(m)) -->  (n!=0 | 0>m); 
                RELASS [R1]: ( R1(n)) -->  n<=1]
[[ Unfold 0 ==>  Match(x,x)]]


# -pnum 4

infer [R1,R2] x::ll<n> * y::ll<m> & R1(n) & R2(m) |- x::node<_,null>.

Entail (5) : Fail.(may) cause:OrL[
 x=null |-  x!=null. LOCS:[6;38] (must-bug),
valid
]

(====)
early_hp_contra_detection_add_to_list_context#1@7
early_hp_contra_detection_add_to_list_context#1 inp1 : ex_formula : y::ll<m>@M&R1(n) & R1(m) & n=0 & x=null&{FLOW,(20,21)=__norm#E}[]
 es_heap:emp
 es_infer_vars_rel: [R1]
early_hp_contra_detection_add_to_list_context#1 inp2 : x::node<Anon_16,flted_38_52>@M&flted_38_52=null&{FLOW,(20,21)=__norm#E}[]
early_hp_contra_detection_add_to_list_context#1@7 EXIT:(real_c:false,false,None,?)

# Why isn't contra detected?

# -pnum 5

infer [R1] x::ll<n> * y::ll<m> & R1(n) & R1(m) |- x::node<_,null>.

 <1>q_67::ll<flted_7_65>@M * y::ll<m>@M&flted_7_65=n-1 & n<=1 & R1(n) & R2(m)&{FLOW,(20,21)=__norm#E}[]
 inferred rel: [RELASS [R1,R2]: ( R1(n) & R2(m)) -->  (n!=0 | 0>m); 
                RELASS [R1]: ( R1(n)) -->  n<=1]
[[ Unfold 0 ==>  Match(x,x)]]

# Why use ( R1(n) & R2(m)) --> 
===================================================================
# ex64s7a.slk

# -pnum 6

infer [H,R1] H(n) * x::ll<n> * y::ll<m> & R1(m)
  |- x::node<_,null>.

# How about HeapPred?

 inferred rel: [RELASS [R1]: ( R1(m)) -->  0>m]
 inferred hprel: [H(n@NI)&true --> emp&n<=1]
===================================================================
# ex64u2.slk

checkentail x::lseg<nnn, p> & nnn > 9 |- [n1,n2] x::lseg<n1, r1> * r1::lseg<n2, p> & n1 >= 9 & n2 >= 2.

# simplify for Z3? large proof

 log(bigger)(>4s)(3):(15.,[(simplify:171<9:Z3,5.);(simplify:272<17:Z3,5.);(simplify:371<25:Z3,5.)])
===================================================================
# sleek7.slk

Checking sleek7.slk (runs with extra options:  --dis-lem-gen )
Unexpected result with : sleek7.slk (failed check(s): {E1#Valid},{E10#Valid},{E2#Valid},{E3#Valid},{E6#Valid},{E7#Valid},{E8#Valid}) 
===================================================================
  label-dll.slk(no result  for {E})
 sleek7.slk({E10#Valid}) sleek8.slk({E16#Valid}) sleek8.slk({E16#Valid}) 
 sleek9.slk({E3#Valid},{E4#Valid}) 
  lemmas/sll_tailL.slk({L1#Valid},{L2#Valid}) lemmas/dseg-new.slk({L2#Fail},{L3#Valid}) lemmas/dseg1.slk({L1#Valid}) fracperm/split_simple.slk({E2#Fail},{E4#Fail},{E5#Fail}) veribsync/barrier-dynamic2.slk({E2#Fail}).

odd-lseg.slk taking very long to compute..
===================================================================
3Dec

Total number of errors: 6 in files:
 
  lemmas/sll_tailL.slk({L1#Valid},{L2#Valid}) 
  lemmas/dseg-new.slk({L2#Fail},{L3#Valid}) 
  lemmas/dseg1.slk({L1#Valid}) 

  fracperm/split_simple.slk({E2#Fail},{E4#Fail},{E5#Fail}) 
  veribsync/barrier-dynamic2.slk({E2#Fail}).

===================================================================
# ex64r3a.slk (FIXED on --new-heap-contra)

infer [
  H1
  ] H1(y)*x::node<null>*z::node<null>  |- 
    x::ll<n> 
    .
print residue.

# why infer [H1] triggers failure in the above?
===================================================================
# ex64r3d.slk (FIXED)

  --pnum 2 -dre "infer_\|early_hp_" --trace-log-num 2  
   -show-push-list "es_infer" >1

infer [@classic,H1] 
    H1(y) * y::node<null>  & x=null  |- x=null
     .

# GOT

 <1>hfalse&false&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [H1(y)&y=null --> emp&true]

# expects:

 inferred hprel: [H1(y) --> y=null]

 above seems too weak to conclude false??

FIXED inside:

(==solver.ml#5669==)
add_infer_hp_contr_to_list_context@6@2@1
add_infer_hp_contr_to_list_context inp1 :[((H1, H1(yyy)),[yyy])]
add_infer_hp_contr_to_list_context inp2 :[ yyy!=null]
add_infer_hp_contr_to_list_context inp3 : [ hfalse&false&{FLOW,(20,21)=__norm
===================================================================
# ex63e1.slk

# why loop for lemma? derived must not fire lemma..


lemma_unsafe self::lseg<n, p> & n = a + b & a,b >=0 <-> self::lseg<a, r> * r::lseg<b, p>.


// 1
// going into a loop here..
checkentail x::lseg<n, p> & n = 7 |- x::lseg<n1, r1> * r1::lseg<n2, r2> & n1 
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
