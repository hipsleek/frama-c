data cell{int val;}void swap1 (ref int i, ref int j)requires true ensures i'= & j'= ; // fill in the final values{  int c=i;  i=j;  j=c;  }void swap2 (cell i, cell j)case { i!=j ->  ensures i::cell<b>*j::cell<a+b>;    // fill in the preconditions i=j -> ensures i::cell<2*a>;  }{	int c=i.val;	i.val = j.val;	j.val = c+j.val;	}int minf(int i, int j)  // fill in both the pre and post conditions, a case construct might come in handy{	if (i<j) return i;	else return j;}int maxf(int i, int j) // similarly fill in the specifications {	if (i<j) return j;	else return i;}int sum_down(int i) // what is the second postcondition? is termination guaranteed, try putting in some termination annotations?case { i<=0 -> requires ensures res=0; i>0 -> requires ensures ;}{	if (i>0) return 2*i+sum_down(i-1);	else return 0;}int sum_up(int i, int n) // fill in the specification, including termination annotationscase {	i<=n -> requires  ensures res = n*(n+1)-  ;	i>n -> requires ensures ;	}{	if (i==n) return 2*n;	else return 2*i+sum_up(i+1,n);} int sum_up_wrapp(int n) // what would be a precise specification? {	return sum_up(0,n);}  int sum_while_up(int n)requires n>0 ensures res = n*(n+1);{	int s=0;	int k=0;	while (k<=n)	   case 		 {		  k>n -> ensures s'=s;		  // can you fill in the rest of the specification?		 }	{		s+=2*k;		k=k+1;	}	return s;}int sum_while_up_nt(int n)requires n>0 ensures res = n*(n+1);{	int s=0;	int k=0;	while (k!=n+1) // if we ignore the context in which it is used, does this loop always terminates?	{		s+=2*k;		k=k+1;	}	return s;} int sum_while_down(int n)requires n>0 ensures res = n*(n+1);{	int s = 0;	int k=n;	while (k>0)  // what about this one?	{		s=s+2*k;		k=k-1;	}	return s;}int sum_while_down_nt(int n)requires n>0 ensures res = n*(n+1);{	int s = 0;	int k=n;	while (k!=0) // a last variation , possibly non terminating?	{		s=s+2*k;		k=k-1;	}	return s;}int Ack(int m, int n) // try and add some termination specifications for the first three casescase {  m<0 -> ensures false;  m=0 -> ensures res=n+1;  m>0 -> case           { 			n<0 -> ensures false;            n>=0 -> ensures res>0;          }  }{ 	if (m==0) return n+1;    else if (n==0) return Ack(m-1,1);  	else return Ack(m-1, Ack(m,n-1));}int gcd(int m, int n)// do all cases terminate? try and annotate and verify the termination case { m=n -> ensures res = m; m!=n ->	case {		m <= 0 -> ensures false;		m > 0 -> case {				n <= 0 -> ensures false;				n > 0 -> ensures res>0;			}	}}{   if(m == n) return m;   else if (m > n) return gcd(m-n, n);   else return gcd(m, n-m);}