data cell{int val;}void swap1 (ref int i, ref int j)  requires true   ensures i'=j & j'=i;{  int c=i;  i=j;  j=c;  }void swap2 (cell i, cell j) case  {   i!=j -> requires i::cell<a>*j::cell<b>            ensures i::cell<b>*j::cell<a+b>;   i=j -> requires i::cell<a>           ensures i::cell<2*a>; }{	int c=i.val;	i.val = j.val;	j.val = c+j.val;	}int minf(int i, int j)case {	i<j -> ensures res=i;	i>=j -> ensures res=j;}{	if (i<j) return i;	else return j;}int maxf(int i, int j)case {	i<j -> ensures res=j;	i>=j -> ensures res=i;}{	if (i<j) return j;	else return i;}int sum_down(int i)case { i<=0 -> requires Term [0] ensures res=0; i>0 -> requires Term[1,i] ensures res = i*(i+1);}{	if (i>0) return 2*i+sum_down(i-1);	else return 0;}int sum_up(int i, int n)case {	i<=n -> requires Term[n-i] ensures res = n*(n+1)-i*(i-1);	i>n -> requires Loop ensures false;	}{	if (i==n) return 2*n;	else return 2*i+sum_up(i+1,n);} int sum_up_wrapp(int n) requires n>0 ensures res = n*(n+1);{	return sum_up(0,n);}  int sum_while_up(int n)requires n>0 ensures res = n*(n+1);{	int s=0;	int k=0;	while (k<=n)	   case 		 {		  k<=n -> requires s=k*(k-1) & Term [1,n-k] ensures s'=n*(n+1);		  k>n -> requires Term [0] ensures s'=s;		 }	{		s+=2*k;		k=k+1;	}	return s;}int sum_while_up_nt(int n)requires n>0 ensures res = n*(n+1);{	int s=0;	int k=0;	while (k!=n+1)	   case 		 {		  k<=n+1 -> requires s=k*(k-1) & Term [n+1-k] ensures s'=n*(n+1);		  k>n+1 -> requires Loop ensures false;		 }	{		s+=2*k;		k=k+1;	}	return s;} int sum_while_down(int n)requires n>0 ensures res = n*(n+1);{	int s = 0;	int k=n;	while (k>0) 	case 	{		0<=k -> requires s = n*(n+1)- k*(k+1) & Term [1,k] ensures s' = n*(n+1);		k<0 -> requires Term[0] ensures s'=s;	}	{		s=s+2*k;		k=k-1;	}	return s;}int sum_while_down_nt(int n)requires n>0 ensures res = n*(n+1);{	int s = 0;	int k=n;	while (k!=0) 	case 	{		0<=k -> requires s = n*(n+1)- k*(k+1) & Term[k] ensures s' = n*(n+1);		k<0 -> requires Loop ensures false;	}	{		s=s+2*k;		k=k-1;	}	return s;}int Ack(int m, int n)case {  m<0 -> requires Loop ensures false;  m=0 -> requires Term[] ensures res=n+1;  m>0 -> case           { 			n<0 -> requires Loop ensures false;            n>=0 -> ensures res>0;          }  }{ 	if (m==0) return n+1;    else if (n==0) return Ack(m-1,1);  	else return Ack(m-1, Ack(m,n-1));}int gcd(int m, int n)case { m=n -> requires Term[0] ensures res = m; m!=n ->	case {		m <= 0 -> requires Loop ensures false;		m > 0 -> case {				n <= 0 -> requires Loop ensures false;				n > 0 -> requires Term [1,m+n] ensures res>0;			}	}}{   if(m == n) return m;   else if (m > n) return gcd(m-n, n);   else return gcd(m, n-m);}